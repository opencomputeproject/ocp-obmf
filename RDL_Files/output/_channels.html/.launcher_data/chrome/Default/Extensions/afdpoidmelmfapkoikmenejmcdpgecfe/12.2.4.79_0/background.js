// ReSharper disable All
this["AternityExtension"] = this["AternityExtension"] || {}; this["AternityExtension"]["background"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 56);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isSerializablePrimitive(value) {
    if (typeof value === "number" && isNaN(value)) {
        return false;
    }
    return typeof value === "string" ||
        typeof value === "boolean" ||
        typeof value === "number";
}
exports.isSerializablePrimitive = isSerializablePrimitive;
var HTTP_STATUS_CODE_REGEX = /HTTP\/\d\.\d (\d+)/;
/**
 * First try to get the status code from the details (available since Chrome 43),
 * if it isn't there try to parse it from the status line
 * According to RFC 2616:
 * Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
 *
 * @return Status code or null if the statusLine is invalid.
 */
function getStatusCode(details) {
    if (details.statusCode != null) {
        return details.statusCode;
    }
    var statusCode = details.statusLine.match(HTTP_STATUS_CODE_REGEX);
    return statusCode !== null ? parseInt(statusCode[1], 10) : null;
}
exports.getStatusCode = getStatusCode;
function startsWith(str, prefix) {
    return str.substring(0, prefix.length) === prefix;
}
exports.startsWith = startsWith;
function endsWith(str, suffix) {
    return str.substring(str.length - suffix.length) === suffix;
}
exports.endsWith = endsWith;
function capitalize(s) {
    return s[0].toUpperCase() + s.slice(1);
}
exports.capitalize = capitalize;
function getSubstring(str, start, end) {
    // Find start
    var startIndex = str.indexOf(start);
    if (startIndex === -1) {
        return "";
    }
    // Skip the hash if present
    var endIndex = str.indexOf(end);
    // Skip empty query
    if (endIndex === startIndex + 1) {
        return "";
    }
    // Return substring
    return str.substring(startIndex + 1, endIndex !== -1 ? endIndex : str.length);
}
/**
 * Parse url and extract query string.
 * The query string is parsed into key to value array.
 * Multiple values are supported.
 */
function getUrlParams(url) {
    var ret = {};
    // Get query string
    var query = getSubstring(url, "?", "#");
    if (query.length === 0) {
        return ret;
    }
    // Parse the query string
    var params = query.split("&");
    // No values, use the query as parameter name.
    if (params.length === 0) {
        pushOrInit(ret, query, "");
        return ret;
    }
    for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
        var param = params_1[_i];
        var nameIndex = param.indexOf("=");
        if (nameIndex === -1) {
            pushOrInit(ret, param, "");
            continue;
        }
        try {
            var name_1 = decodeURI(param.substring(0, nameIndex));
            var value = decodeURI(param.substring(nameIndex + 1));
            pushOrInit(ret, name_1, value);
        }
        catch (e) {
            // Do not add invalid URI params
        }
    }
    return ret;
}
exports.getUrlParams = getUrlParams;
/**
 * Pushes value to array property if key exists or create a new array.
 */
function pushOrInit(keyValueObj, key, value) {
    if (key in keyValueObj) {
        keyValueObj[key].push(value);
    }
    else {
        keyValueObj[key] = [value];
    }
}
exports.pushOrInit = pushOrInit;
/**
 * Concatenate value to array property if key exists or assign the values.
 */
function concatOrInit(
// tslint:disable-next-line readonly-array
keyValueObj, key, values) {
    if (key in keyValueObj) {
        var currentValues = keyValueObj[key];
        if (currentValues != null) {
            keyValueObj[key] = currentValues.concat(values);
            return;
        }
    }
    keyValueObj[key] = values;
}
exports.concatOrInit = concatOrInit;
/**
 * Set properties values from source into destination.
 * Makes a shallow copy of the first level properties.
 */
function populate(source, destination) {
    for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
            destination[prop] = source[prop];
        }
    }
}
exports.populate = populate;
function deepClone(obj) {
    if (obj == null) {
        return obj;
    }
    if (typeof obj === "number" || typeof obj === "boolean" || typeof obj === "string") {
        return obj;
    }
    // Array is a special case
    if (Array.isArray(obj)) {
        var retArray = new Array(obj.length);
        for (var i = 0; i < obj.length; i++) {
            retArray[i] = deepClone(obj[i]);
        }
        return retArray;
    }
    // Make sure the returned object has the same prototype as the original
    var proto = Object.getPrototypeOf != null
        ? Object.getPrototypeOf(obj)
        : obj.__proto__;
    if (!proto) {
        // This line would probably only be reached by very old browsers
        proto = obj.constructor.prototype;
    }
    var ret = Object.create(proto);
    for (var prop in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop))
            continue;
        // tslint:disable-next-line no-any no-unsafe-any
        ret[prop] = deepClone(obj[prop]);
    }
    return ret;
}
exports.deepClone = deepClone;
// tslint:enable readonly-array no-any no-unsafe-any
/**
 * Rewrites the object using given callback.
 * @param obj Object to rewrite
 * @param f Transformation function
 * @param leaveUndefined When set to 'true' it allows to set undefined value
 *  in case it is returned by the callback.
 * When set to 'false' the property is removed from the object
 *  when undefined value is returned from the callback.
 */
function rewriteObject(
// tslint:disable-next-line no-any
obj, 
// tslint:disable-next-line no-any
convert, leaveUndefined) {
    if (leaveUndefined === void 0) { leaveUndefined = true; }
    if (obj == null) {
        return;
    }
    for (var property in obj) {
        if (!obj.hasOwnProperty(property))
            continue;
        var value = convert(property, obj[property]);
        // Special case for undefined
        if (typeof value === "undefined" && !leaveUndefined) {
            delete obj[property];
        }
        else {
            obj[property] = value;
        }
    }
}
exports.rewriteObject = rewriteObject;
/**
 * Allows access to nested properties of an object using a string key path.
 *
 * @param obj The object to access.
 * @param path The nested path to access separated by dots (e.g. "attributes.id"). If path is ""
 * then the original object is returned.
 */
// tslint:disable-next-line no-any
function pick(obj, path) {
    if (path === "") {
        return obj;
    }
    var ret = obj;
    var keys = path.split(".");
    for (var i = 0; i < keys.length && typeof ret !== "undefined"; i++) {
        /* tslint:disable-next-line no-unsafe-any */
        ret = ret[keys[i]];
    }
    return ret;
}
exports.pick = pick;
function makeFunctionCall(f, args) {
    // tslint:enable max-line-length no-any
    var argsString = [];
    if (args != null) {
        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
            var v = args_1[_i];
            // tslint:disable-next-line no-unsafe-any
            argsString.push((typeof v === "string") ? "\"" + v + "\"" : v);
        }
    }
    return "(" + f + ")(" + argsString + ")";
}
exports.makeFunctionCall = makeFunctionCall;
function isValueOneOf(value, values) {
    return values.indexOf(value) !== -1;
}
exports.isValueOneOf = isValueOneOf;
var SUPPORTS_FREEZE = Object.freeze != null && Object.isFrozen != null && Object.getOwnPropertyNames != null;
function deepFreeze(obj) {
    if (!SUPPORTS_FREEZE) {
        return obj;
    }
    // As of Jan 2018 gmail overwrites Object.Freeze, causing it to add an object property.
    // The workaround is to grab the property list before freezing the object.
    var originalProps = Object.getOwnPropertyNames(obj);
    var objIsFunction = typeof obj === "function";
    Object.freeze(obj);
    for (var _i = 0, originalProps_1 = originalProps; _i < originalProps_1.length; _i++) {
        var prop = originalProps_1[_i];
        // Do not freeze special function properties.
        // PhantomJS doesn't like it.
        if (objIsFunction && (prop === "caller" || prop === "callee" || prop === "arguments")) {
            continue;
        }
        // Skip null
        // tslint:disable-next-line no-any
        if (obj[prop] === null) {
            continue;
        }
        // Recursively freeze only objects or functions
        // tslint:disable-next-line no-any
        if (typeof obj[prop] !== "object" && typeof obj[prop] !== "function") {
            continue;
        }
        // Do not freeze if frozen
        // tslint:disable-next-line no-any
        if (Object.isFrozen(obj[prop])) {
            continue;
        }
        // Freeze recursively.
        // tslint:disable-next-line no-any no-unsafe-any
        deepFreeze(obj[prop]);
    }
    return obj;
}
exports.deepFreeze = deepFreeze;
function asReadonly(obj) {
    return obj;
}
exports.asReadonly = asReadonly;
// tslint:enable readonly-array
/**
 * Add value to array only if it doesn't present in array.
 */
// tslint:disable-next-line readonly-array
function addUnique(array, value) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var elem = array_1[_i];
        if (elem === value) {
            return;
        }
    }
    array.push(value);
}
exports.addUnique = addUnique;
var REGEX_ESCAPED_CHARACTERS = /([\\^$.*+?()[\]{}|])/g; // Take the special characters
var REGEX_UNESCAPED_CHARACTERS = /\\([\\^$.*+?()[\]{}|])/g; // Take the special that are preceeded by \
function escapeRegExp(unescaped) {
    // Implementation copied from lodash implementation for escapeRegExp
    return (unescaped !== "" && REGEX_ESCAPED_CHARACTERS.test(unescaped))
        ? unescaped.replace(REGEX_ESCAPED_CHARACTERS, "\\$&")
        : unescaped;
}
exports.escapeRegExp = escapeRegExp;
/**
 * Unescape string into regex format
 */
function unescapeRegExp(escaped) {
    // Implementation ammended from lodash implementation for escapeRegExp
    return (escaped !== "" && REGEX_UNESCAPED_CHARACTERS.test(escaped))
        ? escaped.replace(REGEX_UNESCAPED_CHARACTERS, "$1")
        : escaped;
}
exports.unescapeRegExp = unescapeRegExp;
var DATA_REGEX = /^data\:/;
/**
 * @returns {string} Whether given URL is data URL.
 */
function isDataUrl(url) {
    return DATA_REGEX.test(url);
}
exports.isDataUrl = isDataUrl;
exports.isInternetExplorer = 
// Conditional compilation: https://docs.microsoft.com/en-us/scripting/javascript/reference/at-cc-on-statement-javascript
/*@cc_on!@*/ false; // || document.documentMode != null;
/**
 * Set property value if it doesn't present in the object.
 */
function setIfNotExist(data, property, value) {
    // tslint:disable-next-line no-unsafe-any
    if (!data.hasOwnProperty(property)) {
        data[property] = value;
    }
}
exports.setIfNotExist = setIfNotExist;
/**
 * Set property value using valueFactory if it doesn't present in the object.
 */
function setIfNotExistFactory(data, property, valueFactory) {
    // tslint:disable-next-line no-unsafe-any
    if (!data.hasOwnProperty(property)) {
        data[property] = valueFactory();
    }
}
exports.setIfNotExistFactory = setIfNotExistFactory;
/**
 * Search element in array.
 * @see Array.prototype.find
 */
function find(arr, condition) {
    for (var i = 0, n = arr.length; i < n; ++i) {
        var element = arr[i];
        if (condition(element)) {
            return element;
        }
    }
    return undefined;
}
exports.find = find;
/**
 * Converts a binary string to a Uint8Array
 * @param str input binary string to convert to a Uint8Array
 */
function binstring2Buf(str) {
    var buf = new Uint8Array(str.length);
    for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
    }
    return buf;
}
exports.binstring2Buf = binstring2Buf;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Function which does nothing.
 */
function emptyFunction() { }
// Global console object and window.console don't exist in IE by default.
// But it magically appears when opening developer tools.
function hasConsole() {
    return console != null;
}
// Bind is supported only in modern browsers
var SUPPORTS_BIND = Function.prototype.bind != null;
/**
 * Wrap log function with message and optional parameters.
 *
 * @param f console object function
 */
function wrapConsoleLogFunction(f) {
    if (!hasConsole()) {
        return emptyFunction;
    }
    // Resharper 2017.3 bug
    // ReSharper disable ImplicitAnyError
    // Validate function exist.
    // If function doesn't exist try using 'console.log'.
    if (console[f] == null) {
        if (f !== "log") {
            return wrapConsoleLogFunction("log");
        }
        else {
            return emptyFunction;
        }
    }
    // Use bind if possible
    try {
        if (SUPPORTS_BIND &&
            console[f] != null &&
            console[f].bind != null) {
            return console[f].bind(console);
        }
    }
    catch (e) {
    }
    return console[f];
    // ReSharper restore ImplicitAnyError
}
var emptyLogger = {
    debug: emptyFunction,
    log: emptyFunction,
    info: emptyFunction,
    warn: emptyFunction,
    error: emptyFunction,
    trace: emptyFunction
};
function wrapConsole() {
    return {
        debug: wrapConsoleLogFunction("debug"),
        log: wrapConsoleLogFunction("log"),
        info: wrapConsoleLogFunction("info"),
        warn: wrapConsoleLogFunction("warn"),
        error: wrapConsoleLogFunction("error"),
        trace: wrapConsoleLogFunction("trace")
    };
}
/**
 * @return Logger which logs if window.console present or logger stub which does nothing.
 */
function createConsoleLogger() {
    return hasConsole() ? wrapConsole() : emptyLogger;
}
// Current logger implementation
var currentLogger = emptyLogger;
function getLogger() {
    return currentLogger;
}
exports.getLogger = getLogger;
/**
 * Enable logs.
 */
function enableLogs() {
    currentLogger = createConsoleLogger();
}
exports.enableLogs = enableLogs;
/**
 * Disable logs.
 */
function disableLogs() {
    currentLogger = emptyLogger;
}
exports.disableLogs = disableLogs;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var browserInfo_1 = __webpack_require__(8);
var consts_1 = __webpack_require__(4);
var timeProvider_1 = __webpack_require__(3);
var utils_1 = __webpack_require__(0);
/**
 * Message from background to content script.
 */
var ContentMessageType;
(function (ContentMessageType) {
    ContentMessageType["RECONFIGURE"] = "reconfigure";
    ContentMessageType["UNINITIALIZE"] = "uninitialize";
})(ContentMessageType = exports.ContentMessageType || (exports.ContentMessageType = {}));
/**
 * Chrome only messages between background and content scripts
 */
var ChromeContentMessageType;
(function (ChromeContentMessageType) {
    ChromeContentMessageType["DOCUMENT_TITLE_UPDATE"] = "documentTitleUpdate";
    ChromeContentMessageType["DOCUMENT_TITLE_REQUEST"] = "documentTitleRequest";
    ChromeContentMessageType["DOCUMENT_TITLE_RESPONSE"] = "documentTitleResponse";
})(ChromeContentMessageType = exports.ChromeContentMessageType || (exports.ChromeContentMessageType = {}));
var MessageType;
(function (MessageType) {
    MessageType["EVENT"] = "event";
    MessageType["LOG"] = "log";
    MessageType["WPM_PAGELOAD_EVENT"] = "wpmpageloadevent";
    MessageType["WPM_ERROR_EVENT"] = "wpmerrorevent";
    MessageType["CONTENT_SCRIPT_LOAD"] = "contentscriptload";
    MessageType["GET_STATUS_CODE"] = "getstatuscode";
    MessageType["WAC_FROM_INJECTED"] = "MessageFromInjected";
    MessageType["WAC_TO_IE"] = "wac2ie";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 *
 * Messages from content script to background
 */
exports.CONTENT_MESSAGES = [
    MessageType.WAC_FROM_INJECTED,
    MessageType.CONTENT_SCRIPT_LOAD,
    MessageType.GET_STATUS_CODE
];
var HTTP_CHROME_WEBPAGE_PAGELOAD = "http:chrome:WebPage.PageLoad";
var WPM_PAGE_LOAD_UX = "wpm:chrome:Page.Load";
exports.WPM_PAGE_ERROR_UX = "wpm:chrome:Page.Error";
exports.NV_CHROME_WORKTIME_VIOLATION = "nv:chrome:WorkTime.Violation";
var OutgoingBaseNativeMessage = /** @class */ (function () {
    function OutgoingBaseNativeMessage(messageType, timeStamp) {
        this.messageType = messageType;
        this.timeStamp = timeStamp;
        this.browserName = browserInfo_1.browserInfo.name;
        this.browserVersion = browserInfo_1.browserInfo.version;
        this.extensionVersion = consts_1.EXTENSION_VERSION.getValue();
    }
    return OutgoingBaseNativeMessage;
}());
exports.OutgoingBaseNativeMessage = OutgoingBaseNativeMessage;
var OutgoingPageNativeMessage = /** @class */ (function (_super) {
    __extends(OutgoingPageNativeMessage, _super);
    function OutgoingPageNativeMessage(messageType, timeStamp) {
        var _this = _super.call(this, messageType, timeStamp) || this;
        _this.messageType = messageType;
        _this.timeStamp = timeStamp;
        return _this;
    }
    return OutgoingPageNativeMessage;
}(OutgoingBaseNativeMessage));
exports.OutgoingPageNativeMessage = OutgoingPageNativeMessage;
var OutgoingEventMessage = /** @class */ (function (_super) {
    __extends(OutgoingEventMessage, _super);
    function OutgoingEventMessage(eventType, timeStamp) {
        var _this = _super.call(this, MessageType.EVENT, timeStamp) || this;
        _this.messageData = {
            EventType: eventType,
            // tslint:disable-next-line no-any
            Data: [({})]
        };
        return _this;
    }
    return OutgoingEventMessage;
}(OutgoingPageNativeMessage));
exports.OutgoingEventMessage = OutgoingEventMessage;
var WacOutgoingNativeMessage = /** @class */ (function (_super) {
    __extends(WacOutgoingNativeMessage, _super);
    function WacOutgoingNativeMessage(wacMessageData) {
        var _this = _super.call(this, MessageType.WAC_TO_IE, timeProvider_1.timeProvider.now()) || this;
        _this.wacMessageData = wacMessageData;
        return _this;
    }
    return WacOutgoingNativeMessage;
}(OutgoingPageNativeMessage));
exports.WacOutgoingNativeMessage = WacOutgoingNativeMessage;
var OutgoingHttpChromeWebPageLoadEventMessage = /** @class */ (function (_super) {
    __extends(OutgoingHttpChromeWebPageLoadEventMessage, _super);
    function OutgoingHttpChromeWebPageLoadEventMessage(timeStamp) {
        return _super.call(this, HTTP_CHROME_WEBPAGE_PAGELOAD, timeStamp) || this;
    }
    return OutgoingHttpChromeWebPageLoadEventMessage;
}(OutgoingEventMessage));
exports.OutgoingHttpChromeWebPageLoadEventMessage = OutgoingHttpChromeWebPageLoadEventMessage;
var OutgoingWpmPageLoadUXMessage = /** @class */ (function (_super) {
    __extends(OutgoingWpmPageLoadUXMessage, _super);
    function OutgoingWpmPageLoadUXMessage() {
        return _super.call(this, WPM_PAGE_LOAD_UX, performance.timing.loadEventEnd) || this;
    }
    return OutgoingWpmPageLoadUXMessage;
}(OutgoingEventMessage));
exports.OutgoingWpmPageLoadUXMessage = OutgoingWpmPageLoadUXMessage;
var OutgoingWpmPageErrorUXMessage = /** @class */ (function (_super) {
    __extends(OutgoingWpmPageErrorUXMessage, _super);
    function OutgoingWpmPageErrorUXMessage() {
        return _super.call(this, exports.WPM_PAGE_ERROR_UX, performance.timing.loadEventEnd) || this;
    }
    return OutgoingWpmPageErrorUXMessage;
}(OutgoingEventMessage));
exports.OutgoingWpmPageErrorUXMessage = OutgoingWpmPageErrorUXMessage;
// ReSharper disable once InconsistentNaming
var OutgoingNVWorkTimeViolationUXMessage = /** @class */ (function (_super) {
    __extends(OutgoingNVWorkTimeViolationUXMessage, _super);
    function OutgoingNVWorkTimeViolationUXMessage(nvViolationData) {
        var _this = _super.call(this, exports.NV_CHROME_WORKTIME_VIOLATION, timeProvider_1.timeProvider.now()) || this;
        _this.messageData.Data = [utils_1.deepClone(nvViolationData)];
        return _this;
    }
    return OutgoingNVWorkTimeViolationUXMessage;
}(OutgoingEventMessage));
exports.OutgoingNVWorkTimeViolationUXMessage = OutgoingNVWorkTimeViolationUXMessage;
var OutgoingWpmPageLoadEventMessage = /** @class */ (function (_super) {
    __extends(OutgoingWpmPageLoadEventMessage, _super);
    function OutgoingWpmPageLoadEventMessage(title, url, responseTime, activityResponse, tcpConnectTime, redirectTime, dnsTime, requestTime, processingTime, loadTime, totalNetworkResponseTime, totalNetworkServerTime, clientTime, serverURL, userId, pageId, aixId) {
        var _this = _super.call(this, MessageType.WPM_PAGELOAD_EVENT, performance.timing.loadEventEnd) || this;
        _this.title = title;
        _this.url = url;
        _this.responseTime = responseTime;
        _this.activityResponse = activityResponse;
        _this.tcpConnectTime = tcpConnectTime;
        _this.redirectTime = redirectTime;
        _this.dnsTime = dnsTime;
        _this.requestTime = requestTime;
        _this.processingTime = processingTime;
        _this.loadTime = loadTime;
        _this.totalNetworkResponseTime = totalNetworkResponseTime;
        _this.totalNetworkServerTime = totalNetworkServerTime;
        _this.clientTime = clientTime;
        _this.serverURL = serverURL;
        _this.userId = userId;
        _this.pageId = pageId;
        _this.aixId = aixId;
        return _this;
    }
    return OutgoingWpmPageLoadEventMessage;
}(OutgoingPageNativeMessage));
exports.OutgoingWpmPageLoadEventMessage = OutgoingWpmPageLoadEventMessage;
var OutgoingWpmErrorEventMessage = /** @class */ (function (_super) {
    __extends(OutgoingWpmErrorEventMessage, _super);
    function OutgoingWpmErrorEventMessage(url, targetFrameName, statusCode) {
        var _this = _super.call(this, MessageType.WPM_ERROR_EVENT, performance.timing.loadEventEnd) || this;
        _this.url = url;
        _this.targetFrameName = targetFrameName;
        _this.statusCode = statusCode;
        return _this;
    }
    return OutgoingWpmErrorEventMessage;
}(OutgoingPageNativeMessage));
exports.OutgoingWpmErrorEventMessage = OutgoingWpmErrorEventMessage;
var OutgoingLogMessage = /** @class */ (function (_super) {
    __extends(OutgoingLogMessage, _super);
    function OutgoingLogMessage(level, message) {
        var _this = _super.call(this, MessageType.LOG, timeProvider_1.timeProvider.now()) || this;
        _this.level = level;
        _this.message = consts_1.EXTENSION_VERSION.getValue() + ": " + message;
        return _this;
    }
    return OutgoingLogMessage;
}(OutgoingPageNativeMessage));
exports.OutgoingLogMessage = OutgoingLogMessage;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * window.performance.now provider.
 */
var performanceNowProvider = {
    now: function () {
        return window.performance.now();
    }
};
/**
 * Returns current time using the best available option.
 */
exports.timeProvider = {
    // Some IE modes don't have Date.now.
    now: Date.now != null
        ? function () { return Date.now(); }
        : function () { return new Date().getTime(); }
};
// Validate window.performance exists and working correctly (IE bug !)
/*
    const HAS_PERFORMANCE_NOW =
    window.performance != null &&
    window.performance.now != null &&
    window.performance.now() !== Infinity;
    */
/**
 * Time provider for relative calculations.
 * It doesn't necessarily returns the current time.
 *
 * performance.now is too slow in IE, using inaccurate timeProvider now.
 */
exports.relativeTimeProvider = exports.timeProvider;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// import { chrome } from "./globalChrome";
var lazy_1 = __webpack_require__(5);
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 6] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 5] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 4] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 2] = "ERROR";
    LogLevel[LogLevel["FATAL"] = 1] = "FATAL";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
exports.EXTENSION_VERSION = new lazy_1.Lazy(function () { return chrome.runtime.getManifest().version; });
/**
 * Key name delimiter for nested structure.
 */
exports.KEY_DELIMITER = ".";
/**
 * Report everything.
 */
exports.REPORT_EVERYTHING = "Everything";
/**
 * WebRequest event regex.
 */
exports.WEBREQUEST_EVENT_RE = /^http\:chrome\:WebRequest/;
exports.WEBREQUEST_EVENT_NAMESPACE = "http:chrome:WebRequest";
/**
 * Required properties in WebRequest events.
 */
exports.WEBREQUEST_REQUIRED_PROPERTIES = [
    ["documentUrl", "type"],
    ["documentCommittedUrl", "type"]
];


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Lazy = /** @class */ (function () {
    function Lazy(generatorOrValue) {
        if (typeof generatorOrValue === "function") {
            this.generator = generatorOrValue;
            this.hasValue = false;
        }
        else {
            this.value = generatorOrValue;
            this.hasValue = true;
        }
    }
    Lazy.prototype.getValue = function () {
        // tslint:disable no-non-null-assertion
        if (!this.hasValue) {
            this.value = this.generator();
            this.hasValue = true;
        }
        return this.value;
        // tslint:enable no-non-null-assertion
    };
    Lazy.from = function (value) {
        return new Lazy(value);
    };
    /**
     * Extract value either from immediate or from lazy.
     */
    Lazy.extract = function (canbeLazy) {
        if (canbeLazy instanceof Lazy) {
            // ReSharper disable once TsResolvedFromInaccessibleModule
            return canbeLazy.getValue();
        }
        else {
            return canbeLazy;
        }
    };
    return Lazy;
}());
exports.Lazy = Lazy;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var Utils = __webpack_require__(0);
var lazy_1 = __webpack_require__(5);
// .NET style for case insensitive option
var DOTNET_CASE_INSENSITIVE = /^(\^?)\(\?i\)(\^?)(.*)/;
function isValidRegex(pattern) {
    try {
        // ReSharper disable once WrongExpressionStatement
        /* tslint:disable-next-line no-unused-expression*/
        new RegExp(pattern);
        return true;
    }
    catch (e) {
        log_1.getLogger().error("Invalid regular expression", pattern);
        return false;
    }
}
/**
 * A special class for optimized regular expression matching.
 */
var RegExpMatcher = /** @class */ (function () {
    function RegExpMatcher() {
    }
    /**
     * @param pattern Pattern to match.
     * @param isExact Whether to use exact match or equality
     * @param caseInsensitive Force case insensitive pattern. Valid only if isExact is false.
     */
    RegExpMatcher.prototype.addMatcher = function (pattern, isExact, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (isExact) {
            this.multiPattern =
                RegExpMatcher.addMultiPattern(this.multiPattern, "^" + Utils.escapeRegExp(pattern) + "$");
        }
        else {
            // Handle case insensitive option
            var groups = pattern.match(DOTNET_CASE_INSENSITIVE);
            var icase = groups != null ? (groups[1] !== "" ? groups[1] : groups[2]) : "";
            var matchPattern = groups != null ? (icase + groups[3]) : pattern;
            // Test regular expression
            if (!isValidRegex(matchPattern))
                return;
            if (groups != null || caseInsensitive) {
                // Store previous value
                var previMultiPattern = this.imultiPattern;
                // Get new pattern
                var newIMultiPattern = RegExpMatcher.addMultiPattern(this.imultiPattern, matchPattern);
                // If regex is not valid, restore previous value
                if (isValidRegex(newIMultiPattern)) {
                    // Update pattern and clear cache
                    this.imultiPattern = newIMultiPattern;
                    this.iregexMatcher = undefined;
                }
                else {
                    this.imultiPattern = previMultiPattern;
                    return;
                }
            }
            else {
                // Store previous value
                var prevMultiPattern = this.multiPattern;
                // Get new pattern
                var newMultiPattern = RegExpMatcher.addMultiPattern(this.multiPattern, matchPattern);
                // If regex is not valid, restore previous value
                if (isValidRegex(newMultiPattern)) {
                    // Update pattern and clear cache
                    this.multiPattern = newMultiPattern;
                    this.regexMatcher = undefined;
                }
                else {
                    this.multiPattern = prevMultiPattern;
                    return;
                }
            }
        }
    };
    RegExpMatcher.addMultiPattern = function (multiPattern, matchPattern) {
        return (multiPattern == null ? "" : multiPattern + "|") + matchPattern;
    };
    RegExpMatcher.prototype.isMatch = function (input) {
        if (this.multiPattern != null) {
            if (this.regexMatcher == null) {
                this.regexMatcher = new RegExp(this.multiPattern);
            }
            if (this.regexMatcher.test(lazy_1.Lazy.extract(input))) {
                return true;
            }
        }
        if (this.imultiPattern != null) {
            if (this.iregexMatcher == null) {
                this.iregexMatcher = new RegExp(this.imultiPattern, "i");
            }
            if (this.iregexMatcher.test(lazy_1.Lazy.extract(input))) {
                return true;
            }
        }
        return false;
    };
    RegExpMatcher.prototype.hasMatcher = function () {
        return this.multiPattern != null || this.imultiPattern != null;
    };
    return RegExpMatcher;
}());
exports.RegExpMatcher = RegExpMatcher;


/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable max-line-length
/* Chrome UserAgent:
 * "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36"
 * "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36"
 * "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
 * Chrome AppVersion:
 * "5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
 */
var CHROME_VERSION = /Chrome\/(([0-9]+)\.([0-9]+)\.([.0-9]+))/;
/* Safari UserAgent:
 * "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/601.6.17 (KHTML, like Gecko) Version/9.1.1 Safari/601.6.17"
 * "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.1 Safari/605.1.15"
 * Safari AppVersion:
 * "5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.1 Safari/605.1.15"
 */
var SAFARI_VERSION = /Version\/(([0-9])\.([0-9])\.([.0-9]+))\s+Safari/;
/*
 * Firefox UserAgent:
 * "Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0"
 * "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0"
 */
var FIREFOX_VERSION = /Firefox\/(([0-9]+)\.([0-9]+))/;
/*
 * Chromium Edge UserAgent (the new Chromium Edge introduced on 01/2020):
 * "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36 Edg/80.0.361.50"
 * Chromium Edge AppVersion:
 * "5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36 Edg/80.0.361.50"
 */
var CHROMIUM_EDGE_VERSION = /Edg\/(([0-9]+)\.([0-9]+)\.([.0-9]+))/;
function createBrowserInfo(name, matches) {
    var major = matches[2];
    var minor = matches[3];
    return {
        name: name,
        version: matches[1],
        major: parseInt(major, 10),
        minor: parseInt(minor, 10)
    };
}
/**
 * @return Browser name and version extracted from appVersion string or userAgent string, obtained from the window.navigator object.
 */
function getBrowserInfo(appVersion, userAgent) {
    // The Chromium Edge regex should be executed before the Chrome and the Safari regex, as its User Agent and App Version strings contain the later.
    // const matches = CHROMIUM_EDGE_VERSION.exec(appVersion);
    /*
    if (matches != null) {
        return createBrowserInfo(BrowserType.Edge, matches);
    }
    */
    var matches = CHROME_VERSION.exec(appVersion);
    if (matches != null) {
        return createBrowserInfo("Chrome" /* Chrome */, matches);
    }
    /*
    matches = SAFARI_VERSION.exec(appVersion);
    if (matches != null) {
        return createBrowserInfo(BrowserType.Safari, matches);
    }

    matches = FIREFOX_VERSION.exec(userAgent);
    if (matches != null) {
        return createBrowserInfo(BrowserType.Firefox, matches);
    }
    */
    return createBrowserInfo("N/A" /* NA */, ["", "0.0.0.0", "0", "0"]);
}
exports.getBrowserInfo = getBrowserInfo;
exports.browserInfo = getBrowserInfo(navigator.appVersion, navigator.userAgent);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
/**
 * Configuration version format.
 */
exports.CONFIGURATION_VERSION = 2;
exports.VISIBILITY_MONITORING_INTERVAL_MS = 300;
exports.ELEMENTS_DISCOVERY_INTERVAL_MS = 1500;
exports.DEFAULT_BACKOFF_GRACE_PERIOD = 1000;
exports.MAX_PROPERTY_LENGTH = 256;
var WORKTIME_THRESHOLD_ALLOW_ALL = [{ WorkTime: 1000000, TimeFrame: 1000000 }];
function makeMutableDefaultConfiguration(wpmUrl, eventConfig, allowEvents) {
    var ret = {
        ConfigurationVersion: exports.CONFIGURATION_VERSION,
        MaxPropertyLength: exports.MAX_PROPERTY_LENGTH,
        WPMDocumentUrlFiltersList: [wpmUrl],
        WPMCommittedUrlFiltersList: [wpmUrl],
        FullWpmFiltersList: [wpmUrl],
        EventConfig: eventConfig,
        WorkTimeThresholds: allowEvents ? WORKTIME_THRESHOLD_ALLOW_ALL : [],
        ConsolidatedEventConfig: {},
        VisibilityMonitoringIntervalMs: exports.VISIBILITY_MONITORING_INTERVAL_MS,
        ElementsDiscoveryIntervalMs: exports.ELEMENTS_DISCOVERY_INTERVAL_MS,
        BackoffGracePeriodMs: exports.DEFAULT_BACKOFF_GRACE_PERIOD
    };
    return ret;
}
function makeReadonlyDefaultConfiguration(wpmUrl, eventConfig, allowEvents) {
    var configurationData = makeMutableDefaultConfiguration(wpmUrl, eventConfig, allowEvents);
    // Workaround ReSharper 2017.3 bug, specify generic parameter explicitly
    return utils_1.deepFreeze(configurationData);
}
/** Default configuration, do nothing. */
exports.EMPTY_CONFIGURATION = makeReadonlyDefaultConfiguration("", {}, false);
/* Starting configuration to be overwritten by configuration from the Agent. */
exports.STARTING_CONFIGURATION = makeMutableDefaultConfiguration("", {}, false);
/** Report everything configuration */
exports.REPORT_EVERYTHING_CONFIGURATION = makeReadonlyDefaultConfiguration(".*", {
    Everything: [],
    "ui:chrome:Tab.Everything": [],
    "ui:chrome:Document.Everything": []
}, true);
/** Report wpm configuration */
exports.REPORT_WPM_CONFIGURATION = makeReadonlyDefaultConfiguration(".*", {
    "http:chrome:WebPage.Everything": [],
    "wpm:chrome:Page.Everything": []
}, true);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// ReSharper disable InconsistentNaming
exports.NV_CHROME_WORKTIME_VIOLATION = "nv:chrome:WorkTime.Violation";
exports.HTML_DESIGNER_EVENT_NAMESPACE = "ui:chrome:Document";
exports.HTML_ONAPP_EVENT_NAMESPACE = "ui:chrome:OnApp:Document";
exports.DOM_EVENT_NAMESPACE = "ui:chrome:OnApp:Dom";
exports.VISIBLE_EVENT_NAME = getFullDomEventName("Visible");
exports.INVISIBLE_EVENT_NAME = getFullDomEventName("Invisible");
// ReSharper restore InconsistentNaming
function getFullDomEventName(name) {
    return exports.DOM_EVENT_NAMESPACE + "." + name;
}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FrameType;
(function (FrameType) {
    FrameType["DOCUMENT"] = "document";
    FrameType["FRAME"] = "frame";
})(FrameType = exports.FrameType || (exports.FrameType = {}));
/**
 * @param {number} frameId Frame id to retrieve type from.
 * @returns {string} Return property 'type' value.
 */
function getFrameType(frameId) {
    return frameId === 0 ? FrameType.DOCUMENT : FrameType.FRAME;
}
exports.getFrameType = getFrameType;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Utils = __webpack_require__(0);
var ConfigurationUtils = __webpack_require__(18);
var ConfigurationData_1 = __webpack_require__(9);
var RegExpMatcher_1 = __webpack_require__(6);
var EventConfiguration_1 = __webpack_require__(19);
// tslint:disable-next-line no-require-imports
var SimpleLRU = __webpack_require__(21);
var MAX_CONFIGURATION_CACHE_SIZE = 100;
/**
 * Encapsulates Data.Configuration
 */
var Configuration = /** @class */ (function () {
    function Configuration(configurationData) {
        this.specializedEventConfiguration = {};
        this.configurationDataCache = new SimpleLRU(MAX_CONFIGURATION_CACHE_SIZE);
        this.configurationData = ConfigurationData_1.STARTING_CONFIGURATION;
        Utils.populate(configurationData, this.configurationData);
        this.maxPropertyLength =
            configurationData.MaxPropertyLength != null
                ? configurationData.MaxPropertyLength
                : ConfigurationData_1.VISIBILITY_MONITORING_INTERVAL_MS;
        this.visibilityMonitoringIntervalMs =
            configurationData.VisibilityMonitoringIntervalMs != null
                ? configurationData.VisibilityMonitoringIntervalMs
                : ConfigurationData_1.VISIBILITY_MONITORING_INTERVAL_MS;
        this.elementsDiscoveryIntervalMs =
            configurationData.ElementsDiscoveryIntervalMs != null
                ? configurationData.ElementsDiscoveryIntervalMs
                : ConfigurationData_1.ELEMENTS_DISCOVERY_INTERVAL_MS;
        // WPM
        this.wpmDocumentUrlFilters = new RegExpMatcher_1.RegExpMatcher();
        if (configurationData.WPMDocumentUrlFiltersList != null) {
            for (var _i = 0, _a = configurationData.WPMDocumentUrlFiltersList; _i < _a.length; _i++) {
                var wpmUrlFilter = _a[_i];
                this.wpmDocumentUrlFilters.addMatcher(wpmUrlFilter, false);
            }
        }
        this.wpmCommittedUrlFilters = new RegExpMatcher_1.RegExpMatcher();
        if (configurationData.WPMCommittedUrlFiltersList != null) {
            for (var _b = 0, _c = configurationData.WPMCommittedUrlFiltersList; _b < _c.length; _b++) {
                var wpmUrlFilter = _c[_b];
                this.wpmCommittedUrlFilters.addMatcher(wpmUrlFilter, false);
            }
        }
        // Full page
        this.httpWebPageLoadUrlFilters = new RegExpMatcher_1.RegExpMatcher();
        if (configurationData.FullWpmFiltersList != null) {
            for (var _d = 0, _e = configurationData.FullWpmFiltersList; _d < _e.length; _d++) {
                var fullWpmUrlFilter = _e[_d];
                this.httpWebPageLoadUrlFilters.addMatcher(fullWpmUrlFilter, false, true);
            }
        }
        var eventConfig = configurationData.EventConfig != null ? configurationData.EventConfig : {};
        this.globalEventConfiguration = new EventConfiguration_1.EventConfiguration(eventConfig);
        var consolidatedEventConfig = configurationData.ConsolidatedEventConfig;
        if (consolidatedEventConfig != null) {
            for (var consolidationProperty in consolidatedEventConfig) {
                if (!consolidatedEventConfig.hasOwnProperty(consolidationProperty))
                    continue;
                var consolidatedConfiguration = consolidatedEventConfig[consolidationProperty];
                for (var matcher in consolidatedConfiguration) {
                    if (!consolidatedConfiguration.hasOwnProperty(matcher))
                        continue;
                    if (this.specializedEventConfiguration[consolidationProperty] == null) {
                        this.specializedEventConfiguration[consolidationProperty] = {};
                    }
                    this.specializedEventConfiguration[consolidationProperty][matcher] =
                        new EventConfiguration_1.EventConfiguration(consolidatedConfiguration[matcher]);
                }
            }
        }
    }
    Configuration.prototype.getEventsForPage = function (consolidationKeys) {
        var key = JSON.stringify(consolidationKeys);
        var configurationDataFromCache = this.configurationDataCache.get(key);
        if (configurationDataFromCache != null) {
            return configurationDataFromCache;
        }
        var configuration = ConfigurationUtils.getEventsForPage(this.configurationData, consolidationKeys);
        this.configurationDataCache.set(key, configuration);
        return configuration;
    };
    Configuration.prototype.hasEventFilter = function (eventName) {
        // Check both in event filters and in everything prefixes.
        return this.globalEventConfiguration.eventFilters.hasFilter(eventName) || this.isMatchEverything(eventName);
    };
    /**
     * Check if the given monitoringEvent is monitored.
     *
     * For given event http:chrome:WebRequest.Start those even categories return true:
     * http:chrome:WebRequest
     * http:chrome
     * http
     *
     * @return true if monitored, false otherwise.
     */
    Configuration.prototype.isMonitoring = function (monitoringEvent) {
        // Check event filter
        if (this.hasEventFilter(monitoringEvent)) {
            return true;
        }
        // Check everything event filters by prefix
        for (var _i = 0, _a = this.globalEventConfiguration.everythingPrefixEvents; _i < _a.length; _i++) {
            var everythingEventFilter = _a[_i];
            if (Utils.startsWith(everythingEventFilter, monitoringEvent))
                return true;
        }
        // Check event filters by prefix
        for (var _b = 0, _c = this.globalEventConfiguration.eventFilters.getEventNames(); _b < _c.length; _b++) {
            var eventFilter = _c[_b];
            if (Utils.startsWith(eventFilter, monitoringEvent))
                return true;
        }
        return false;
    };
    Configuration.prototype.isMatchEvent = function (eventName, propertyName, input) {
        // Check both in event filters and in everything prefixes.
        return this.isMatchEverything(eventName) ||
            this.globalEventConfiguration.eventFilters.isMatch(eventName, propertyName, input);
    };
    Configuration.prototype.isMatchEverything = function (eventName) {
        return this.globalEventConfiguration.everythingPrefixEvents.some(function (p) { return Utils.startsWith(eventName, p); });
    };
    Configuration.prototype.isMatchWebRequestEvent = function (propertyName, input) {
        // First check whether event is in everything filters
        if (this.globalEventConfiguration.webRequestEverything) {
            return true;
        }
        return this.globalEventConfiguration.webRequestFilters.isMatch(propertyName, input);
    };
    Configuration.prototype.hasWebRequestFilter = function (propertyName) {
        // First check whether event is in everything filters
        if (this.globalEventConfiguration.webRequestEverything) {
            return true;
        }
        return this.globalEventConfiguration.webRequestFilters.hasFilter(propertyName);
    };
    Configuration.prototype.isMatchForWpmUrls = function (documentUrl, documentCommittedUrl) {
        if (this.wpmDocumentUrlFilters.isMatch(documentUrl)) {
            return true;
        }
        if (documentCommittedUrl != null) {
            return this.wpmCommittedUrlFilters.isMatch(documentCommittedUrl);
        }
        return false;
    };
    Configuration.prototype.isMatchForHttpWebPageLoadUrl = function (url) {
        return this.httpWebPageLoadUrlFilters.isMatch(url);
    };
    Configuration.prototype.hasWpmFilter = function () {
        return this.wpmDocumentUrlFilters.hasMatcher() ||
            this.wpmCommittedUrlFilters.hasMatcher() ||
            this.httpWebPageLoadUrlFilters.hasMatcher();
    };
    Configuration.prototype.getPropertyMatchers = function (eventName, propertyName) {
        var result = [];
        var eventConfig = this.configurationData.EventConfig[eventName];
        if (typeof eventConfig === "undefined") {
            return result;
        }
        for (var _i = 0, eventConfig_1 = eventConfig; _i < eventConfig_1.length; _i++) {
            var conditions = eventConfig_1[_i];
            var propertyConditions = conditions.Conditions[propertyName];
            if (typeof propertyConditions === "undefined") {
                continue;
            }
            for (var _a = 0, propertyConditions_1 = propertyConditions; _a < propertyConditions_1.length; _a++) {
                var propertyMatch = propertyConditions_1[_a];
                result.push(propertyMatch);
            }
        }
        return result;
    };
    Configuration.prototype.hasPropertyMatchers = function (eventName, propertyName) {
        var eventConfig = this.configurationData.EventConfig[eventName];
        if (typeof eventConfig === "undefined") {
            return false;
        }
        for (var _i = 0, eventConfig_2 = eventConfig; _i < eventConfig_2.length; _i++) {
            var conditions = eventConfig_2[_i];
            var propertyConditions = conditions.Conditions[propertyName];
            if (typeof propertyConditions === "undefined") {
                continue;
            }
            return true;
        }
        return false;
    };
    return Configuration;
}());
exports.Configuration = Configuration;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var RegExpMatcher_1 = __webpack_require__(6);
/**
 * Match property name by regular expression.
 * Use with caution !
 */
var REGEX_PROPERTY = /(.*)~$/;
var ConfigurationFilters = /** @class */ (function () {
    function ConfigurationFilters() {
        this.propertyFilters = {};
        // tslint:disable-next-line readonly-array
        this.regexPopertyFilters = [];
    }
    // tslint:disable-next-line readonly-array
    ConfigurationFilters.prototype.getExactPropertyNames = function () {
        return Object.getOwnPropertyNames(this.propertyFilters);
    };
    ConfigurationFilters.prototype.hasRegexPropertyNames = function () {
        return this.regexPopertyFilters.length > 0;
    };
    ConfigurationFilters.prototype.addFilter = function (propertyName, pattern, isExact) {
        // Special case for regular expression property name
        var regexProperty = propertyName.match(REGEX_PROPERTY);
        if (regexProperty != null) {
            this.addRegexPropertyFilter(regexProperty[1], pattern, isExact);
        }
        else {
            if (this.propertyFilters[propertyName] == null) {
                this.propertyFilters[propertyName] = new RegExpMatcher_1.RegExpMatcher();
            }
            this.propertyFilters[propertyName].addMatcher(pattern, isExact);
        }
    };
    ConfigurationFilters.prototype.addRegexPropertyFilter = function (property, pattern, isExact) {
        try {
            var re = new RegExp(property);
            var filter = void 0;
            // Add to existing
            for (var _i = 0, _a = this.regexPopertyFilters; _i < _a.length; _i++) {
                var propertyFilter = _a[_i];
                if (propertyFilter.property.toString() === re.toString()) {
                    filter = propertyFilter;
                }
            }
            // Or create a new one
            // ReSharper disable once ConditionIsAlwaysConst
            // ReSharper disable once HeuristicallyUnreachableCode
            if (filter == null) {
                filter = {
                    property: re,
                    matcher: new RegExpMatcher_1.RegExpMatcher()
                };
                this.regexPopertyFilters.push(filter);
            }
            // Add matcher
            // ReSharper disable once TsResolvedFromInaccessibleModule
            filter.matcher.addMatcher(pattern, isExact);
        }
        catch (e) {
            // Regular expression is not valid, skip it.
            return;
        }
    };
    ConfigurationFilters.prototype.hasFilter = function (propertyName) {
        return propertyName in this.propertyFilters ||
            this.regexPopertyFilters.some(function (f) { return f.property.test(propertyName); });
    };
    /**
     * First checking exact ones and then the regular expression.
     */
    ConfigurationFilters.prototype.isMatch = function (propertyName, input) {
        var filters = this.propertyFilters[propertyName];
        if (filters != null && filters.isMatch(input)) {
            return true;
        }
        else {
            return this.regexPopertyFilters.some(function (f) { return f.property.test(propertyName) && f.matcher.isMatch(input); });
        }
    };
    return ConfigurationFilters;
}());
exports.ConfigurationFilters = ConfigurationFilters;


/***/ }),
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Utils = __webpack_require__(0);
var RegExpMatcher_1 = __webpack_require__(6);
/**
 * Gets the configuration for given consolidation keys
 *
 * @param configurationData Configuration data to extract configuration from.
 * @param consolidationKeys Mapping from consolidation key to value.
 */
function getEventsForPage(configurationData, consolidationKeys) {
    var result = {};
    for (var property in consolidationKeys) {
        if (!consolidationKeys.hasOwnProperty(property))
            continue;
        var forProperty = configurationData.ConsolidatedEventConfig[property];
        if (forProperty == null)
            continue; // Then we don't have a consolidation by this property
        for (var filter in forProperty) {
            if (!forProperty.hasOwnProperty(filter))
                continue;
            var matcher = new RegExpMatcher_1.RegExpMatcher();
            matcher.addMatcher(filter, false);
            if (matcher.isMatch(consolidationKeys[property])) {
                var events = forProperty[filter];
                extendEventConfig(result, events);
            }
        }
    }
    var ret = {
        ConfigurationVersion: configurationData.ConfigurationVersion,
        MaxPropertyLength: configurationData.MaxPropertyLength,
        VisibilityMonitoringIntervalMs: configurationData.VisibilityMonitoringIntervalMs,
        BackoffGracePeriodMs: configurationData.BackoffGracePeriodMs,
        ElementsDiscoveryIntervalMs: configurationData.ElementsDiscoveryIntervalMs,
        WorkTimeThresholds: configurationData.WorkTimeThresholds,
        EventConfig: result,
        ConsolidatedEventConfig: {},
        // DE22560: WPM is part of the configuration intended for the background only -
        // it's of no use to the content script
        WPMDocumentUrlFiltersList: [],
        WPMCommittedUrlFiltersList: [],
        FullWpmFiltersList: []
    };
    return ret;
}
exports.getEventsForPage = getEventsForPage;
function extendEventConfig(target, source) {
    for (var eventName in source) {
        if (!source.hasOwnProperty(eventName))
            continue;
        var conditions = source[eventName];
        if (conditions.length !== 1) {
            throw new Error("Multiple ConditionObjects not supported");
        }
        if (!target.hasOwnProperty(eventName)) {
            // ReSharper 2017.3 bug workaround
            // tslint:disable-next-line no-unnecessary-type-assertion
            target[eventName] = Utils.deepClone(conditions);
        }
        else {
            if (target[eventName].length !== 1) {
                throw new Error("Multiple ConditionObjects not supported");
            }
            var targetConditions = target[eventName][0].Conditions;
            var sourceConditions = conditions[0].Conditions;
            extendConditions(targetConditions, sourceConditions);
        }
    }
}
function comparePropertyMatch(a, b) {
    return a.MatchType === b.MatchType && a.Value === b.Value;
}
function extendConditions(target, source) {
    for (var propertyName in source) {
        if (!source.hasOwnProperty(propertyName))
            continue;
        if (!target.hasOwnProperty(propertyName)) {
            // ReSharper 2017.3 bug workaround
            // tslint:disable-next-line no-unnecessary-type-assertion
            target[propertyName] = Utils.deepClone(source[propertyName]);
        }
        else {
            var targetMatchers = target[propertyName];
            var sourceMatcher = source[propertyName];
            var _loop_1 = function (matcher) {
                if (targetMatchers.some(function (m) { return comparePropertyMatch(m, matcher); })) {
                    return "continue";
                }
                targetMatchers.push(matcher);
            };
            for (var _i = 0, sourceMatcher_1 = sourceMatcher; _i < sourceMatcher_1.length; _i++) {
                var matcher = sourceMatcher_1[_i];
                _loop_1(matcher);
            }
        }
    }
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Utils = __webpack_require__(0);
var Consts = __webpack_require__(4);
var ConfigurationFilters_1 = __webpack_require__(13);
var EventFilters_1 = __webpack_require__(20);
/*
 * Report everything for this event.
 */
var EVERYTHING_EVENT_SUFFIX = new RegExp("(.*)" + Consts.REPORT_EVERYTHING + "$");
/*
 * The properties which must be send to the agent with any event
 */
var MANDATORY_PROPERTIES = ["tabId"];
var EventConfiguration = /** @class */ (function () {
    // tslint:disable-next-line readonly-array
    function EventConfiguration(eventToLevels) {
        this.webRequestEverything = false;
        this.eventFilters = new EventFilters_1.EventFilters();
        this.everythingPrefixEvents = [];
        this.webRequestEverything = false;
        this.webRequestFilters = new ConfigurationFilters_1.ConfigurationFilters();
        for (var eventName in eventToLevels) {
            if (!eventToLevels.hasOwnProperty(eventName))
                continue;
            if (this.tryAddEverything(eventName)) {
                continue;
            }
            var levels = eventToLevels[eventName];
            // Currently we support only one level
            for (var i = 0; i < Math.min(levels.length, 1); i++) {
                var conditions = levels[i].Conditions;
                for (var propertyName in conditions) {
                    if (!conditions.hasOwnProperty(propertyName))
                        continue;
                    var matchers = conditions[propertyName];
                    for (var _i = 0, matchers_1 = matchers; _i < matchers_1.length; _i++) {
                        var matcher = matchers_1[_i];
                        var value = matcher.Value;
                        var isExact = matcher.MatchType === "exact";
                        this.addFilter(eventName, propertyName, value, isExact);
                    }
                }
            }
        }
        this.verifyMandatoryProperties();
    }
    EventConfiguration.prototype.tryAddEverything = function (eventName) {
        // Test for everything case
        var everythingMatch = eventName.match(EVERYTHING_EVENT_SUFFIX);
        if (everythingMatch != null) {
            var eventPrefix = everythingMatch[1];
            // Add if hasn't been added before
            if (this.everythingPrefixEvents.indexOf(eventPrefix) === -1) {
                this.everythingPrefixEvents.push(eventPrefix);
            }
            // Special WebRequest everything case
            this.webRequestEverything =
                this.webRequestEverything ||
                    Utils.startsWith(Consts.WEBREQUEST_EVENT_NAMESPACE, eventPrefix) ||
                    eventPrefix.length === 0 ||
                    Consts.WEBREQUEST_EVENT_RE.test(eventPrefix);
            return true;
        }
        else {
            return false;
        }
    };
    EventConfiguration.prototype.addFilter = function (eventName, propertyName, value, isExact) {
        var configPropertyName = EventConfiguration.normalizeProperty(propertyName);
        // Special webRequest properties.
        if (Consts.WEBREQUEST_EVENT_RE.test(eventName)) {
            this.webRequestFilters.addFilter(configPropertyName, value, isExact);
        }
        this.eventFilters.addFilter(eventName, configPropertyName, value, isExact);
    };
    /**
     * Convert header property to be lower case.
     * Leave other properties as-is.
     */
    EventConfiguration.normalizeProperty = function (propertyName) {
        var groups = propertyName.match(EventConfiguration.HEADER_PROPERTY);
        if (groups != null) {
            return groups[1] + groups[2].toLowerCase();
        }
        else {
            return propertyName;
        }
    };
    // Make sure that all the mandatory property names are in the configuration
    EventConfiguration.prototype.verifyMandatoryProperties = function () {
        for (var _i = 0, MANDATORY_PROPERTIES_1 = MANDATORY_PROPERTIES; _i < MANDATORY_PROPERTIES_1.length; _i++) {
            var propertyName = MANDATORY_PROPERTIES_1[_i];
            for (var _a = 0, _b = this.eventFilters.getEventNames(); _a < _b.length; _a++) {
                var event_1 = _b[_a];
                this.addFilter(event_1, propertyName, ".*", false);
            }
        }
    };
    EventConfiguration.HEADER_PROPERTY = /^(requestHeader|responseHeader)(.*)/;
    return EventConfiguration;
}());
exports.EventConfiguration = EventConfiguration;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ConfigurationFilters_1 = __webpack_require__(13);
var EventFilters = /** @class */ (function () {
    function EventFilters() {
        this.eventFilters = {};
    }
    // tslint:disable-next-line readonly-array
    EventFilters.prototype.getEventNames = function () {
        return Object.getOwnPropertyNames(this.eventFilters);
    };
    EventFilters.prototype.getEventFilters = function (eventName) {
        return this.eventFilters[eventName];
    };
    EventFilters.prototype.addFilter = function (eventName, propertyName, pattern, isExact) {
        if (this.eventFilters[eventName] == null) {
            this.eventFilters[eventName] = new ConfigurationFilters_1.ConfigurationFilters();
        }
        this.eventFilters[eventName].addFilter(propertyName, pattern, isExact);
    };
    EventFilters.prototype.hasFilter = function (eventName) {
        return eventName in this.eventFilters;
    };
    EventFilters.prototype.isMatch = function (eventName, propertyName, input) {
        var filters = this.eventFilters[eventName];
        return filters != null && filters.isMatch(propertyName, input);
    };
    return EventFilters;
}());
exports.EventFilters = EventFilters;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;(function () {
  'use strict';

  /**
   * export SimpleLRU for CommonJS, AMD
   */
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return SimpleLRU;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

  SimpleLRU.version = '0.0.3';

  /**
   * Simple mixin utility
   * @api private
   */
  function extend(obj1, obj2) {
    for (var key in obj2) obj1[key] = obj2[key];
  }

  var nativeCreate = Object.create;

  /**
   * Object data store
   * this is a `Object.create` fallback in order to support IE8
   * @api private
   */
  var Data = (function () {
    var Data, proto;

    if (typeof nativeCreate === 'function') {
      Data = function () {
        this.data = nativeCreate(null);
      };

      proto = {
        get: function (key) {
          return this.data[key];
        },
        has: function (key) {
          return !! this.data[key];
        }
      };

    } else {
      Data = function () {
        this.data = {};
      };

      proto = {
        get: function (key) {
          if (this.has(key)) return this.data[key];
        },
        has: function (key) {
          return Object.prototype.hasOwnProperty.call(this.data, key);
        }
      };
    }

    extend(proto, {
      set: function (key, val) {
        this.data[key] = val;
      },
      del: function (key) {
        var val = this.get(key);
        if (typeof val !== 'undefined') {
          delete this.data[key];
          return val;
        }
      }
    });

    extend(Data.prototype, proto);

    return Data;
  })();

  /**
   * Cache entry instance
   *
   * @param {String}
   * @param {any}
   * @param {Number}
   * @api private
   */
  function Entry(key, val, index) {
    this.key = key;
    this.val = val;
    this.index = index;
  }

  /**
   * SimpleLRU constructor
   * It holds following private properties. See `#reset()`
   *
   *   _byKey    {Data}    map by key
   *   _byOrder  {Object}  map by recently used order
   *   _head     {Number}  index of next entry
   *   _tail     {Number}  index of least recently used cache item
   *   _len      {Number}  total number of cache items
   *
   * `_tail` is an index of the least recently used cache item.
   * `_head` is an index of the most recently used cache item *plus* one.
   *
   * @param {Number} max length of cache item
   */
  function SimpleLRU(max) {
    if (typeof max !== 'number') throw new TypeError('max is requried');
    this.max(max);
    this.reset();
  }

  extend(SimpleLRU.prototype, {

    /**
     * Set cache by key
     * @param {String} unique string key
     * @param {String|Object|Number} any value
     */
    set: function (key, val) {
      var entry = this._byKey.get(key);

      // reuse entry if the key exists
      if (entry) {
        this._touch(entry);
        entry.val = val;
        return;
      }

      entry = new Entry(key, val, this._head++);
      this._byKey.set(key, entry);
      this._byOrder[entry.index] = entry;
      this._len++;
      this._trim();
    },

    /**
     * delete cache by key
     *
     * @param {String}
     * @return {String|Object|Number} cached value
     */
    del: function (key) {
      var entry = this._byKey.del(key);
      if (!entry) return;

      delete this._byOrder[entry.index];
      this._len--;

      if (this._len === 0) {
        this._head = this._tail = 0;
      } else {
        // update most index if it was most lecently used entry
        if (entry.index === this._head - 1) this._pop();
        // update least index if it was least lecently used entry
        if (entry.index === this._tail) this._shift();
      }

      return entry.val;
    },

    /**
     * get cache by key
     *
     * @param {String}
     * @return {any} cache if it exists
     */
    get: function (key) {
      var entry = this._byKey.get(key);
      if (entry) {
        this._touch(entry);
        return entry.val;
      }
    },

    /**
     * get a cache by key without touching index
     * @return {any}
     */
    peek: function (key) {
      var entry = this._byKey.get(key);
      if (entry) return entry.val;
    },

    /**
     * see if key is exists or not
     * @return {Boolean}
     */
    has: function (key) {
      return this._byKey.has(key);
    },

    /**
     * total number of cache
     * @return {Number}
     */
    length: function () {
      return this._len;
    },

    /**
     * clear all stored cache
     */
    reset: function () {
      this._byKey = new Data();
      this._byOrder = nativeCreate ? nativeCreate(null) : {};
      this._head = 0;
      this._tail = 0;
      this._len = 0;
    },

    /**
     * Getter|Setter function of "max" option
     * @param {Number} if setter
     */
    max: function (max) {
      if (typeof max !== 'number') return this._max;
      if (max < 1) throw new TypeError('max should be a positive number');
      var shrink = (this._max || 0) > max;
      this._max = max;
      if (shrink) this._trim();
    },

    /**
     * return array of keys in least recently used order
     * @return {Array}
     */
    keys: function () {
      var count = 0
        , tail = this._tail
        , head = this._head
        , keys = new Array(this._len);

      for (var i = tail; i < head; i++) {
        var entry = this._byOrder[i];
        if (entry) keys[count++] = entry.key;
      }

      return keys;
    },

    /**
     * update least recently used index of an entry to "_head"
     *
     * @param {Entry}
     * @api private
     */
    _touch: function (entry) {
      // update most number to key
      if (entry.index !== this._head - 1) {
        var isTail = entry.index === this._tail;
        delete this._byOrder[entry.index];
        entry.index = this._head++;
        this._byOrder[entry.index] = entry;
        if (isTail) this._shift();
      }
    },

    /**
     * trim entries
     * @api private
     */
    _trim: function () {
      var max = this._max;
      while (max < this._len) {
        var tailEntry = this._byOrder[this._tail];
        this.del(tailEntry.key);
      }
    },

    /**
     * update tail index
     * @return {Entry|undefined}
     * @api private
     */
    _shift: function () {
      var tail = this._tail
        , head = this._head;
      for (var i = tail; i < head; i++) {
        var entry = this._byOrder[i];
        if (entry) {
          this._tail = i;
          return entry;
        }
      }
    },

    /**
     * update head index
     * @return {Entry|undefined}
     * @api private
     */
    _pop: function () {
      var tail = this._tail
        , head = this._head;
      for (var i = head - 1; i >= tail; i--) {
        var headEntry = this._byOrder[i];
        if (headEntry) {
          this._head = i + 1;
          return headEntry;
        }
      }
    }
  });

})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
// import { BackgroundPageInformation } from "../common/PageInformation";
var MessagingModel_1 = __webpack_require__(2);
var timeProvider_1 = __webpack_require__(3);
exports.DOWNLOADS_EVENT_NAMESPACE = "ui:chrome:Downloads";
var DownloadItem = /** @class */ (function () {
    function DownloadItem(item) {
        Object.assign(this, item);
        this.totalTimeMillis = 0;
        this.interactionTimeMillis = 0;
        this.transferTimeMillis = 0;
        this.lastResumeTime = new Date(item.startTime).getTime();
        this.bytesReceived = 0;
    }
    DownloadItem.getDownloadInterruptReason = function (reason) {
        switch (reason) {
            case "FILE_FAILED":
            case "FILE_ACCESS_DENIED":
            case "FILE_NO_SPACE":
            case "FILE_NAME_TOO_LONG":
            case "FILE_TOO_LARGE":
            case "FILE_VIRUS_INFECTED":
            case "FILE_TRANSIENT_ERROR":
            case "FILE_BLOCKED":
            case "FILE_SECURITY_CHECK_FAILED":
            case "FILE_TOO_SHORT":
            case "FILE_HASH_MISMATCH":
            case "FILE_SAME_AS_SOURCE":
            case "NETWORK_FAILED":
            case "NETWORK_TIMEOUT":
            case "NETWORK_DISCONNECTED":
            case "NETWORK_SERVER_DOWN":
            case "NETWORK_INVALID_REQUEST":
            case "SERVER_FAILED":
            case "SERVER_NO_RANGE":
            case "SERVER_BAD_CONTENT":
            case "SERVER_UNAUTHORIZED":
            case "SERVER_CERT_PROBLEM":
            case "SERVER_FORBIDDEN":
            case "SERVER_UNREACHABLE":
            case "SERVER_CONTENT_LENGTH_MISMATCH":
            case "SERVER_CROSS_ORIGIN_REDIRECT":
            case "USER_CANCELED":
            case "USER_SHUTDOWN":
            case "CRASH":
                return reason;
            default:
                return "CRASH";
        }
    };
    return DownloadItem;
}());
// The sent message does *not* include tab/frame info. So it extends BaseNativeMessage,
// not PageNativeMessage.
var OutgoingDownloadMessage = /** @class */ (function (_super) {
    __extends(OutgoingDownloadMessage, _super);
    function OutgoingDownloadMessage(eventType, timeStamp) {
        var _this = _super.call(this, MessagingModel_1.MessageType.EVENT, timeStamp) || this;
        _this.messageData = {
            EventType: eventType,
            // tslint:disable-next-line no-any
            Data: [({})]
        };
        return _this;
    }
    return OutgoingDownloadMessage;
}(MessagingModel_1.OutgoingBaseNativeMessage));
exports.OutgoingDownloadMessage = OutgoingDownloadMessage;
var DownloadsMonitoring = /** @class */ (function () {
    function DownloadsMonitoring() {
        var _this = this;
        this.onDownloadCreated = function (item) {
            if (_this.manager == null || !_this.manager.active || _this.communication == null) {
                return;
            }
            if (item.state !== "in_progress") {
                // When opening the 'downloads' page for the first time in a session,
                // already-downloaded items fire onCreated with state 'complete', or 'interrupted' etc.
                return;
            }
            // Add the item's id to the activeDownloadIDs array, only if it does not exist
            var index = _this.activeDownloadIDs.indexOf(item.id);
            if (index === -1) {
                _this.activeDownloadIDs.push(item.id);
            }
            // Start the polling only once
            if (_this.activeDownloadIDs.length === 1) {
                _this.startPolling();
            }
            _this.downloads[item.id] = new DownloadItem(item);
            _this.downloads[item.id].lastResumeTime = new Date(item.startTime).getTime();
            // Save the original final name, before the override
            _this.downloads[item.id].filename = item.url.split("/").pop();
        };
        this.onDownloadChanged = function (delta) {
            if (_this.manager == null || !_this.manager.active || _this.communication == null) {
                return;
            }
            // Verify the change is relevant
            if (delta.fileSize === undefined &&
                delta.totalBytes === undefined &&
                delta.filename === undefined &&
                delta.paused === undefined &&
                delta.endTime === undefined &&
                delta.error === undefined) {
                return;
            }
            var item = _this.downloads[delta.id];
            if (item === undefined) {
                log_1.getLogger().error("DownloadChanged without matching DownloadCreated: ", delta);
                return;
            }
            if (delta.fileSize !== undefined && delta.fileSize.current !== undefined) {
                item.fileSize = delta.fileSize.current;
            }
            if (delta.totalBytes !== undefined && delta.totalBytes.current !== undefined) {
                item.totalBytes = delta.totalBytes.current;
            }
            if (delta.filename !== undefined && delta.filename.current !== undefined) {
                // Filename is set - interaction has ended
                if (item.filename === "") { // In case filename was missing
                    item.filename = delta.filename.current;
                }
                // Track here when it's time to rethink this code: https://bugs.chromium.org/p/chromium/issues/detail?id=982232#c0
                item.interactionTimeMillis = timeProvider_1.timeProvider.now() - new Date(item.startTime).getTime();
            }
            // Handle pause/resume
            if (delta.paused !== undefined && delta.paused.current !== undefined) {
                if (delta.paused.current === false) {
                    // Just resumed
                    log_1.getLogger().debug("Download resumed: ", item);
                    item.lastResumeTime = timeProvider_1.timeProvider.now();
                }
                else {
                    log_1.getLogger().debug("Download paused: ", item);
                    item.transferTimeMillis += timeProvider_1.timeProvider.now() - item.lastResumeTime;
                }
            }
            // Handle completion
            if (delta.endTime !== undefined) {
                item.totalTimeMillis = timeProvider_1.timeProvider.now() - new Date(item.startTime).getTime();
                _this.handleCompletion(item);
            }
            // Handle cancellation/failure
            if (delta.error !== undefined ||
                (delta.state !== undefined && delta.state.current === "interrupted")) {
                _this.removeItemFromPolling(item.id);
                item.totalTimeMillis = timeProvider_1.timeProvider.now() - new Date(item.startTime).getTime();
                item.transferTimeMillis += timeProvider_1.timeProvider.now() - item.lastResumeTime;
                if (item.interactionTimeMillis === 0) {
                    // User just cancelled at the file dialog
                    item.interactionTimeMillis = item.totalTimeMillis;
                }
                if (delta.error !== undefined && delta.error.current !== undefined) {
                    item.error = DownloadItem.getDownloadInterruptReason(delta.error.current);
                }
                log_1.getLogger().info("Download failed message", item);
                var message = _this.createDataMessage("Failed", item);
                _this.communication.postNativeMessage(message);
                _this.removeItemFromDownloads(delta.id);
            }
        };
        this.downloads = {};
        this.activeDownloadIDs = [];
    }
    DownloadsMonitoring.prototype.initDownloadsMonitoring = function (manager, communication) {
        this.manager = manager;
        this.communication = communication;
        chrome.downloads.onChanged.addListener(this.onDownloadChanged);
        chrome.downloads.onCreated.addListener(this.onDownloadCreated);
    };
    DownloadsMonitoring.prototype.uninitDownloadsMonitoring = function () {
        chrome.downloads.onChanged.removeListener(this.onDownloadChanged);
        chrome.downloads.onCreated.removeListener(this.onDownloadCreated);
    };
    DownloadsMonitoring.prototype.makeEventName = function (event) {
        return exports.DOWNLOADS_EVENT_NAMESPACE + "." + event;
    };
    DownloadsMonitoring.prototype.createDataMessage = function (event, item) {
        var message = new OutgoingDownloadMessage(this.makeEventName(event), timeProvider_1.timeProvider.now());
        var messageData = message.messageData.Data[0];
        messageData.downloadUrl = item.url;
        messageData.referrerPageUrl = item.referrer;
        messageData.totalBytes = item.totalBytes;
        messageData.filename = item.filename;
        messageData.mime = item.mime;
        messageData.startTime = new Date(item.startTime).getTime();
        if (item.error !== undefined) {
            messageData.error = item.error;
        }
        messageData.totalTimeMillis = item.totalTimeMillis;
        messageData.transferTimeMillis = item.transferTimeMillis;
        messageData.interactionTimeMillis = item.interactionTimeMillis;
        messageData.waitTimeMillis = item.totalTimeMillis - item.interactionTimeMillis;
        messageData.bytesReceived = item.bytesReceived;
        return message;
    };
    DownloadsMonitoring.prototype.pollDownloads = function () {
        var _this = this;
        this.activeDownloadIDs.forEach(function (id) { return chrome.downloads.search({ id: id }, function (item) {
            // Make changes only if download is in progress (bytesReceived for failed / cancelled downloads are 0)
            if (item[0].bytesReceived > 0) {
                var downloadingItem = _this.downloads[id];
                downloadingItem.bytesReceived = item[0].bytesReceived;
                //  If item was completely downloaded - handle completion
                if (item[0].bytesReceived === downloadingItem.totalBytes) {
                    var now = timeProvider_1.timeProvider.now();
                    downloadingItem.transferTimeMillis += now - downloadingItem.lastResumeTime;
                    downloadingItem.lastResumeTime = now;
                    _this.removeItemFromPolling(item[0].id);
                }
            }
        }); });
    };
    DownloadsMonitoring.prototype.handleCompletion = function (item) {
        log_1.getLogger().info("Download complete message", item);
        if (this.communication == null) {
            return;
        }
        // Can happen when the file is too small and item.bytesReceived were not updated yet
        if (item.bytesReceived === 0) {
            item.bytesReceived = item.totalBytes;
            var now = timeProvider_1.timeProvider.now();
            item.transferTimeMillis += now - item.lastResumeTime;
            item.totalTimeMillis = now - new Date(item.startTime).getTime(); // update total time - to be more accurate
        }
        this.removeItemFromPolling(item.id);
        var message = this.createDataMessage("Completed", item);
        this.communication.postNativeMessage(message);
    };
    DownloadsMonitoring.prototype.removeItemFromDownloads = function (id) {
        var itemDownloaded = this.downloads[id];
        if (itemDownloaded !== undefined) {
            delete this.downloads[id];
        }
    };
    DownloadsMonitoring.prototype.startPolling = function () {
        this.pollingTimer = setInterval(this.pollDownloads.bind(this), 100);
        log_1.getLogger().info("Started downloads polling, interval ID: ", this.pollingTimer);
    };
    DownloadsMonitoring.prototype.removeItemFromPolling = function (downloadId) {
        var index = this.activeDownloadIDs.indexOf(downloadId);
        if (index !== -1) {
            this.activeDownloadIDs.splice(index, 1);
        }
        if (this.activeDownloadIDs.length === 0) {
            this.stopPolling();
        }
    };
    DownloadsMonitoring.prototype.stopPolling = function () {
        if (this.pollingTimer !== undefined) {
            clearInterval(this.pollingTimer);
            log_1.getLogger().info("Stopped downloads polling, interval ID: ", this.pollingTimer);
            this.pollingTimer = undefined;
        }
    };
    return DownloadsMonitoring;
}());
exports.DownloadsMonitoring = DownloadsMonitoring;


/***/ }),
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Order of the native message.
 */
var nativeMessageOrder = 0;
function getNativeMessageOrder() {
    // Limit order by max uint32
    if (nativeMessageOrder > 2 * 1024 * 1024 * 1024) {
        nativeMessageOrder = 0;
    }
    return nativeMessageOrder++;
}
exports.getNativeMessageOrder = getNativeMessageOrder;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable no-any */
var IncomingAction;
(function (IncomingAction) {
    IncomingAction["Configuration"] = "configuration";
    IncomingAction["Deactivate"] = "deactivate";
    IncomingAction["WacMessage"] = "wac";
})(IncomingAction = exports.IncomingAction || (exports.IncomingAction = {}));
/* tslint:disable no-any */
exports.INCOMING_VERSION = 1;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var MessagingModel_1 = __webpack_require__(2);
var Consts = __webpack_require__(4);
var Utils = __webpack_require__(0);
var MessageOrder_1 = __webpack_require__(30);
var WebRequestsState_1 = __webpack_require__(61);
var WebRequestEvent_1 = __webpack_require__(33);
var webRequest = chrome.webRequest;
function isMonitoredState(frameMonitoredState) {
    return frameMonitoredState.monitorWebRequest || frameMonitoredState.monitorWPM;
}
exports.WEB_REQUEST_EVENT_NAMESPACE = "http:chrome:WebRequest";
function makeEventName(event) {
    return exports.WEB_REQUEST_EVENT_NAMESPACE + "." + event;
}
var WebRequest = /** @class */ (function () {
    function WebRequest(tabsStates) {
        var _this = this;
        this.webRequestsStates = new WebRequestsState_1.WebRequestsStates();
        // #endregion
        // #region Handlers
        this.onBeforeRequest = function (details) {
            if (!_this.isMonitored(details, false)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onBeforeRequest", details);
            // Get frame state
            var frameState = _this.tabsStates.getFrame(details);
            // In case we have the same tab id and frame id and the requestId is different,
            // and the type is "main_frame" or "sub_frame", we have a new navigation.
            if (frameState != null && frameState.requestId !== details.requestId) {
                // Frame state exists, only frame type means navigation.
                if (_this.isFrameType(details.type)) {
                    // Remove states
                    _this.tabsStates.removeFrame(details.tabId, details.frameId);
                    _this.webRequestsStates.remove(frameState.requestId);
                    frameState = _this.addFrame(details);
                    // Remove instant tabs
                    setTimeout(function () { return _this.tabsStates.validateTab(details.tabId); }, 60 * 1000);
                }
            }
            // Web request is initialized only for start navigation event.
            var requestState = _this.webRequestsStates.get(details.requestId);
            if (requestState == null) {
                requestState = _this.webRequestsStates.add(details.requestId, details.timeStamp);
            }
            // This check never positive since there is assignment before.
            if (frameState == null || requestState == null) {
                return undefined;
            }
            // Update frame's current url if it is frame request.
            if (_this.isFrameType(details.type)) {
                frameState.currentUrl = details.url;
            }
            else {
                // Update only if wasn't defined before
                if (typeof frameState.currentUrl === "undefined") {
                    frameState.currentUrl = details.url;
                }
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Mark down the time
            requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.BeforeRequest, details.timeStamp);
            // Create message
            var message = _this.createDataMessage("BeforeRequest", details, frameState);
            var eventData = message.messageData.Data[0];
            // Parse url parameters into formData
            var urlParams = Utils.getUrlParams(details.url);
            _this.populateFormData(urlParams, eventData);
            // Add requestBody
            if (details.requestBody != null) {
                if (details.requestBody.error != null) {
                    eventData.requestBodyType = "Error";
                    eventData.requestBodyError = details.requestBody.error;
                }
                else if (details.requestBody.formData != null) {
                    eventData.requestBodyType = "FormData";
                    requestState.totalOutgoingBytes += _this.populateFormData(details.requestBody.formData, eventData);
                }
                else if (details.requestBody.raw != null) {
                    eventData.requestBodyType = "Raw";
                    eventData.requestBodyRaw = [];
                    for (var _i = 0, _a = details.requestBody.raw; _i < _a.length; _i++) {
                        var uploadData = _a[_i];
                        if (uploadData.bytes != null) {
                            requestState.totalOutgoingBytes += uploadData.bytes.byteLength;
                            eventData.requestBodyRaw.push("Bytes");
                        }
                        else {
                            if (uploadData.file != null) {
                                requestState.totalOutgoingBytes += uploadData.file.length;
                                eventData.requestBodyRaw.push(uploadData.file);
                            }
                        }
                    }
                }
            }
            // Set beforeRequestEvent only in the first request.
            if (!requestState.setBeforeRequestEvent) {
                requestState.beforeRequestEvent = Utils.deepClone(message);
                requestState.startMesageOrder = MessageOrder_1.getNativeMessageOrder();
                requestState.setBeforeRequestEvent = true;
            }
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                // Always post if AppInternals header present
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        this.onBeforeSendHeaders = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onBeforeSendHeaders", details);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            // Mark down the time
            var requestState = _this.webRequestsStates.get(details.requestId);
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.BeforeSendHeaders, details.timeStamp);
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Create message
            var message = _this.createDataMessage("BeforeSendHeaders", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.requestHeaders != null) {
                WebRequest.populateHeaders(details.requestHeaders, "requestHeaders", eventData);
            }
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        this.onSendHeaders = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onSendHeaders", details);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            var requestState = _this.webRequestsStates.get(details.requestId);
            // Mark down the time
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.SendHeaders, details.timeStamp);
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Create message
            var message = _this.createDataMessage("SendHeaders", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.requestHeaders != null) {
                WebRequest.populateHeaders(details.requestHeaders, "requestHeaders", eventData);
            }
            // Send the message
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            // Check we have requestState
            if (requestState != null) {
                // Send WebRequest.Start event
                if (!requestState.postedStart) {
                    // Validate request state
                    if (requestState.beforeRequestEvent == null ||
                        requestState.startMesageOrder == null) {
                        log_1.getLogger().error("Request state didn't initialize beforeRequestEvent or startMessageOrder");
                    }
                    else if (monitoredState.monitorWebRequest) {
                        _this.postStartMessage(details.requestHeaders, requestState.beforeRequestEvent, requestState.startMesageOrder);
                    }
                    requestState.postedStart = true;
                    delete requestState.beforeRequestEvent;
                }
                // Add outgoing bytes if we have them
                if (details.requestHeaders != null) {
                    requestState.totalOutgoingBytes += WebRequest.getContentLength(details, details.requestHeaders);
                }
                // Remember the time so we can subtract it once the server gets back to us.
                requestState.lastOnSendHeadersTs = details.timeStamp;
            }
            return undefined;
        };
        this.onHeadersReceived = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onHeadersReceived", details);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            var requestState = _this.webRequestsStates.get(details.requestId);
            // Mark down the time
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.HeadersReceived, details.timeStamp);
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            var message = _this.createDataMessage("HeadersReceived", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.responseHeaders != null) {
                WebRequest.populateHeaders(details.responseHeaders, "responseHeaders", eventData);
            }
            var statusCode = Utils.getStatusCode(details);
            if (statusCode != null) {
                frameState.statusCode = statusCode;
            }
            if (frameState.statusCode != null) {
                eventData.statusCode = frameState.statusCode;
            }
            eventData.statusLine = details.statusLine;
            // Check we have requestState
            if (requestState != null) {
                if (details.responseHeaders != null) {
                    // Update incoming bytes
                    requestState.totalIncomingBytes += WebRequest.getContentLength(details, details.responseHeaders);
                    // Check AppInternals header
                    if (WebRequest.WEBREQUEST_APPINTERNALS_RESPONSE_HEADER in eventData) {
                        // prefix, header.name.toLowerCase()
                        requestState.appInternalsMonitoring = true;
                    }
                }
                // Add (now - last On send headers) to get this request's server time
                requestState.totalServerTime += details.timeStamp - requestState.lastOnSendHeadersTs;
                requestState.lastOnSendHeadersTs = 0;
            }
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        this.onAuthRequired = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onAuthRequired", details);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            // Mark down the time
            var requestState = _this.webRequestsStates.get(details.requestId);
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.AuthRequired, details.timeStamp);
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Create message
            var message = _this.createDataMessage("AuthRequired", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.responseHeaders != null) {
                WebRequest.populateHeaders(details.responseHeaders, "responseHeaders", eventData);
            }
            eventData.statusLine = details.statusLine;
            eventData.isProxy = details.isProxy;
            if (details.realm != null) {
                eventData.realm = details.realm;
            }
            eventData.scheme = details.scheme;
            eventData.challengerHost = details.challenger.host;
            eventData.challengerPort = details.challenger.port;
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        this.onResponseStarted = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onResponseStarted", details);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            if (_this.isFrameType(details.type)) {
                frameState.committedUrl = details.url;
                // Calculate configuration and put it into cache for faster page load.
                // Data URLs are ignored.
                if (_this.configuration != null) {
                    var mainFrameState = _this.tabsStates.getTab(details.tabId);
                    // Special handling for chrome shortcuts
                    var mainCommittedUrl = mainFrameState != null ? mainFrameState.committedUrl : "";
                    var tabReady = mainCommittedUrl != null && mainCommittedUrl !== "";
                    if (mainFrameState != null && !tabReady) {
                        // When running chrome with url on the command line mainFrameState might still have empty documentCommittedUrl,
                        // or even empty documentUrl. We must fall back to currentUrl, stripped of path (to support SPAs)
                        log_1.getLogger().warn("Tab", details.tabId, " committedUrl not ready, falling back to frame", details.frameId);
                        if (details.url !== undefined) {
                            var url = new URL(details.url);
                            mainCommittedUrl = url.protocol + "//" + url.hostname;
                            log_1.getLogger().warn("Using url:", mainCommittedUrl);
                            mainFrameState.committedUrl = mainCommittedUrl;
                        }
                    }
                    if (mainFrameState != null && mainFrameState.committedUrl != null) {
                        _this.configuration.getEventsForPage({
                            documentUrl: mainFrameState.startUrl,
                            documentCommittedUrl: mainFrameState.committedUrl
                        });
                    }
                }
            }
            // Mark down the time
            var requestState = _this.webRequestsStates.get(details.requestId);
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.ResponseStarted, details.timeStamp);
            }
            var statusCode = Utils.getStatusCode(details);
            if (statusCode != null) {
                frameState.statusCode = statusCode;
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Create message
            var message = _this.createDataMessage("ResponseStarted", details, frameState);
            var eventData = message.messageData.Data[0];
            if (frameState.statusCode != null) {
                eventData.statusCode = frameState.statusCode;
            }
            if (details.responseHeaders != null) {
                WebRequest.populateHeaders(details.responseHeaders, "responseHeaders", eventData);
            }
            if (details.ip != null) {
                eventData.ip = details.ip;
            }
            eventData.statusLine = details.statusLine;
            eventData.statusCode = details.statusCode;
            eventData.fromCache = details.fromCache;
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        this.onBeforeRedirect = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onBeforeRedirect", details);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            // Mark down the time
            var requestState = _this.webRequestsStates.get(details.requestId);
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.BeforeRedirect, details.timeStamp);
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Create message
            var message = _this.createDataMessage("BeforeRedirect", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.responseHeaders != null) {
                WebRequest.populateHeaders(details.responseHeaders, "responseHeaders", eventData);
            }
            if (details.ip != null) {
                eventData.ip = details.ip;
            }
            eventData.statusLine = details.statusLine;
            eventData.statusCode = details.statusCode;
            eventData.fromCache = details.fromCache;
            eventData.redirectUrl = details.redirectUrl;
            // Data URI is a special case. There is no further requests.
            if (Utils.isDataUrl(details.redirectUrl)) {
                // Remove web request
                _this.webRequestsStates.remove(details.requestId);
                // Update committed url
                frameState.committedUrl = details.url;
                // Add more meta data for further analysis by the agent
                WebRequest.populateNetwork(requestState, details.timeStamp, eventData);
            }
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        this.onCompleted = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onCompleted", details);
            // Find the request
            var requestState = _this.webRequestsStates.get(details.requestId);
            // Remove web request
            _this.webRequestsStates.remove(details.requestId);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Add additional data
            var message = _this.createDataMessage("Completed", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.responseHeaders != null) {
                WebRequest.populateHeaders(details.responseHeaders, "responseHeaders", eventData);
            }
            if (details.ip != null) {
                eventData.ip = details.ip;
            }
            eventData.statusLine = details.statusLine;
            eventData.statusCode = details.statusCode;
            eventData.fromCache = details.fromCache;
            var forcePost = false;
            // Mark down the time
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.Completed, details.timeStamp);
                // Always post if AppInternals header present.
                forcePost = requestState.appInternalsMonitoring;
            }
            // Add more meta data for further analysis by the agent
            WebRequest.populateNetwork(requestState, details.timeStamp, eventData);
            if (_this.communication != null) {
                _this.communication.postNativeMessage(message, { forcePost: forcePost });
            }
            return undefined;
        };
        this.onErrorOccurred = function (details) {
            if (!_this.isMonitored(details)) {
                return undefined;
            }
            log_1.getLogger().debug("WebRequest.onErrorOccurred", details);
            // Find the request
            var requestState = _this.webRequestsStates.get(details.requestId);
            // Remove web request
            _this.webRequestsStates.remove(details.requestId);
            var frameState = _this.tabsStates.getFrame(details);
            // Skip unmonitored frames
            if (frameState == null) {
                return undefined;
            }
            // Filter event
            var monitoredState = _this.getMonitoredState(frameState, details);
            if (!isMonitoredState(monitoredState)) {
                return undefined;
            }
            // Mark down the time
            if (requestState != null) {
                requestState.storeEventTime(WebRequestEvent_1.WebRequestEvent.ErrorOccurred, details.timeStamp);
            }
            // Create message
            var message = _this.createDataMessage("ErrorOccurred", details, frameState);
            var eventData = message.messageData.Data[0];
            if (details.ip != null) {
                eventData.ip = details.ip;
            }
            eventData.error = details.error;
            eventData.fromCache = details.fromCache;
            // Add more meta data for further analysis by the agent
            WebRequest.populateNetwork(requestState, details.timeStamp, eventData);
            if (_this.communication != null && monitoredState.monitorWebRequest) {
                _this.communication.postNativeMessage(message);
            }
            return undefined;
        };
        /**
         * Message handler to pass configuration to content script.
         * The reason for handling message in WebRequest is to provide page information properties
         * with status code and frame ids.
         */
        this.onMessage = function (message, sender, sendResponse) {
            switch (message.messageType) {
                case MessagingModel_1.MessageType.CONTENT_SCRIPT_LOAD:
                    return _this.onContentScriptLoad(message, sender, sendResponse);
                case MessagingModel_1.MessageType.GET_STATUS_CODE:
                    _this.onGetStatusCode(sender, sendResponse);
                    break;
                default:
                    break;
            }
            return undefined;
        };
        this.tabsStates = tabsStates;
    }
    // #region Utility functions
    /**
     * Create base webRequest message.
     */
    WebRequest.prototype.createDataMessage = function (event, details, frameState) {
        var message = new MessagingModel_1.OutgoingEventMessage(makeEventName(event), details.timeStamp);
        var eventData = message.messageData.Data[0];
        eventData.requestId = details.requestId;
        eventData.url = details.url;
        if (typeof details.method !== "undefined") {
            eventData.method = details.method;
        }
        eventData.type = details.type;
        eventData.frameId = details.frameId;
        eventData.parentFrameId = details.parentFrameId;
        eventData.tabId = details.tabId;
        // Add urls
        eventData.frameUrl = frameState.startUrl;
        eventData.frameCurrentUrl = frameState.currentUrl;
        if (frameState.committedUrl != null) {
            eventData.frameCommittedUrl = frameState.committedUrl;
        }
        if (details.frameId === 0) {
            eventData.documentUrl = frameState.startUrl;
            eventData.documentCurrentUrl = frameState.currentUrl;
            if (frameState.committedUrl != null) {
                eventData.documentCommittedUrl = frameState.committedUrl;
            }
        }
        else {
            var mainFrameState = this.tabsStates.getTab(details.tabId);
            if (mainFrameState != null) {
                eventData.documentUrl = mainFrameState.startUrl;
                eventData.documentCurrentUrl = mainFrameState.currentUrl;
                if (mainFrameState.committedUrl != null) {
                    eventData.documentCommittedUrl = mainFrameState.committedUrl;
                }
            }
        }
        return message;
    };
    /*
     * Frame is either main_frame or sub_frame type.
     */
    WebRequest.prototype.isFrameType = function (type) {
        return type === "main_frame" || type === "sub_frame";
    };
    /**
     * @return true if the tab is monitored or false otherwise.
     */
    WebRequest.prototype.isMonitored = function (details, validateTabState) {
        if (validateTabState === void 0) { validateTabState = true; }
        if (this.manager == null)
            return false;
        return this.manager.active &&
            // tabId set to -1 if the request isn't related to a tab.
            details.tabId !== -1 &&
            (!validateTabState || this.tabsStates.getTab(details.tabId) != null);
    };
    /**
     * Check filters according to configuration
     * If the main frame doesn't exist, the given frame is not monitored since we don't know
     * the URL of the page.
     */
    WebRequest.prototype.getMonitoredState = function (frameState, details) {
        var mainFrameState = details.frameId === 0 ?
            frameState :
            this.tabsStates.getTab(details.tabId);
        // No main frame state, not monitoring.
        if (mainFrameState == null || this.configuration == null) {
            return { monitorWebRequest: false, monitorWPM: false };
        }
        var configuration = this.configuration;
        var documentNavigationUrl = mainFrameState.startUrl;
        var monitorWebRequest = this.isWebRequestMonitored(configuration, mainFrameState, details);
        var monitorWPM = this.configuration.isMatchForWpmUrls(documentNavigationUrl, mainFrameState.committedUrl) ||
            this.configuration.isMatchForHttpWebPageLoadUrl(documentNavigationUrl);
        return { monitorWebRequest: monitorWebRequest, monitorWPM: monitorWPM };
    };
    /**
     * Check whether webRequest should be reported for this tab.
     */
    WebRequest.prototype.isWebRequestMonitored = function (configuration, mainFrameState, details) {
        var documentNavigationUrl = mainFrameState.startUrl;
        // Check documentUrl and type
        if (configuration.isMatchWebRequestEvent("documentUrl", documentNavigationUrl) &&
            configuration.isMatchWebRequestEvent("type", details.type)) {
            return true;
        }
        // If there are no documentCommittedUrl filters, don't report webRequest.
        if (!configuration.hasWebRequestFilter("documentCommittedUrl")) {
            return false;
        }
        // Main frame is always reported when documentCommittedUrl filter is present.
        if (details.type === "main_frame") {
            return true;
        }
        // documentCommitted url should be set in onResponseStarted callback of main frame.
        // If it is not set, something bad happened, don't report.
        var documentCommittedUrl = mainFrameState.committedUrl;
        if (documentCommittedUrl == null) {
            return false;
        }
        // Check documentCommittedUrl and type
        return configuration.isMatchWebRequestEvent("documentCommittedUrl", documentCommittedUrl) &&
            configuration.isMatchWebRequestEvent("type", details.type);
    };
    // tslint:disable-next-line readonly-array
    WebRequest.makeKey = function () {
        var s = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            s[_i] = arguments[_i];
        }
        return s.join(Consts.KEY_DELIMITER);
    };
    WebRequest.getContentLength = function (details, headers) {
        var contentLength = 0;
        var headersLength = 0;
        for (var _i = 0, headers_1 = headers; _i < headers_1.length; _i++) {
            var header = headers_1[_i];
            if (header.name.toLowerCase() === "content-length") {
                if (typeof header.value !== "undefined") {
                    contentLength = parseInt(header.value, 10);
                }
            }
            else {
                headersLength += header.name.length;
                if (typeof header.value !== "undefined") {
                    headersLength += header.value.length;
                }
            }
        }
        // Sometimes no Content-Length is received, we calculate an approximation ourselves
        if (contentLength === 0 && typeof details.url !== "undefined") {
            contentLength += details.url.length;
        }
        return contentLength + headersLength;
    };
    // #endregion
    // #region Populate utility private
    /**
     * Returns normalized header proprety key.
     */
    WebRequest.makeHeaderProperty = function (prefix, header) {
        return WebRequest.makeKey(prefix, header.toLowerCase());
    };
    /**
     * Add headers to the object.
     * The headers are added with the given prefix.
     *
     * Header name is case insensitive, therefore it is converted to lowercase.
     */
    WebRequest.populateHeaders = function (headers, prefix, eventData) {
        if (headers == null) {
            return;
        }
        for (var _i = 0, headers_2 = headers; _i < headers_2.length; _i++) {
            var header = headers_2[_i];
            var key = WebRequest.makeKey(prefix, header.name.toLowerCase());
            if (header.value != null) {
                eventData[key] = header.value;
            }
            else {
                eventData[key] = "|BinaryValue|";
            }
        }
    };
    /**
     * Add network values.
     */
    WebRequest.populateNetwork = function (requestState, timeStamp, eventData) {
        if (requestState == null) {
            return;
        }
        eventData.aternityIncomingBytes = requestState.totalIncomingBytes;
        eventData.aternityOutgoingBytes = requestState.totalOutgoingBytes;
        eventData.aternityNetworkStartTime = Math.floor(requestState.requestStartTime);
        eventData.aternityNetworkEndTime = Math.floor(timeStamp);
        eventData.aternityTotalServerTime = Math.floor(requestState.totalServerTime);
        eventData.aternityEventTimes = JSON.stringify(requestState.eventTimes);
    };
    WebRequest.isFieldBlacklisted = function (fieldName) {
        return WebRequest.passwordRegEx.test(fieldName);
    };
    /**
     * Add formData as array of strings
     * @return ~total number of chars (NOT EXACT!)
     */
    WebRequest.prototype.populateFormData = function (
    // tslint:disable-next-line readonly-array
    formData, eventData) {
        var ret = 0;
        for (var name_1 in formData) {
            if (!formData.hasOwnProperty(name_1))
                continue;
            ret += name_1.length + formData[name_1].toString().length;
            if (WebRequest.isFieldBlacklisted(name_1)) {
                log_1.getLogger().debug("Just filtered " + name_1 + ".");
                continue;
            }
            var key = WebRequest.makeKey("formData", name_1);
            // Workaround Firefox parsing incorrect formData which is not in key=value format.
            // When the request body is not in the correct format, it creates a key with value of undefined.
            // Make an empty value instead.
            if (!(formData[name_1].length === 1 && formData[name_1][0] === undefined)) {
                Utils.concatOrInit(eventData, key, formData[name_1]);
            }
            else {
                eventData[key] = [];
            }
        }
        return ret;
    };
    /**
     * Adds a new frame to tabs states and a new requestId to webRequests states.
     */
    WebRequest.prototype.addFrame = function (details) {
        return this.tabsStates.addFrame(details.tabId, details.frameId, details.url, details.type, details.requestId);
    };
    WebRequest.prototype.postStartMessage = function (
    // tslint:disable-next-line readonly-array
    requestHeaders, originalMessage, order) {
        // Make a new message with combined data and time stamp from BeforeRequest
        var startMessage = new MessagingModel_1.OutgoingEventMessage(makeEventName("Start"), originalMessage.timeStamp);
        startMessage.order = order;
        startMessage.messageData.Data = originalMessage.messageData.Data;
        // Add requestHeaders
        var eventData = startMessage.messageData.Data[0];
        if (requestHeaders != null) {
            WebRequest.populateHeaders(requestHeaders, "requestHeaders", eventData);
        }
        if (this.communication != null) {
            this.communication.postNativeMessage(startMessage);
        }
    };
    WebRequest.prototype.onContentScriptLoad = function (message, sender, sendResponse) {
        var _this = this;
        if (this.configuration == null) {
            log_1.getLogger().log("No configuration, no reply");
            return false;
        }
        if (sender.tab == null || sender.tab.id == null) {
            return false;
        }
        // Determine if this is the content script was loaded by the main frame of the page, or by some
        // sub frame.
        var frameId = sender.frameId != null ? sender.frameId : -1;
        var isMainFrame = (frameId === 0);
        var tabId = sender.tab.id;
        var configuration = this.configuration;
        var mainFrameState = this.tabsStates.getTab(tabId);
        // Special handling for Chrome shortcuts
        var committedUrl = mainFrameState != null ? mainFrameState.committedUrl : "";
        var tabReady = committedUrl != null && committedUrl !== "";
        if (mainFrameState != null && !tabReady) {
            // When running chrome with url on the command line mainFrameState might still have empty documentCommittedUrl,
            // or even empty documentUrl. We must fall back to currentUrl, stripped of path (to support SPAs)
            log_1.getLogger().warn("Tab" + tabId + " committedUrl not ready, falling back to currentUrl host");
            if (sender.tab.url !== undefined) {
                var url = new URL(sender.tab.url);
                committedUrl = url.protocol + "//" + url.hostname;
                log_1.getLogger().log("Using url: " + committedUrl);
                mainFrameState.committedUrl = committedUrl;
            }
        }
        // Send the response asynchronously, so that we don't block content.
        setTimeout(function () { _this.onContentScriptLoadImpl(tabId, frameId, isMainFrame, configuration, sendResponse); }, 0);
        // Keep connection with content script opened.
        return true;
    };
    WebRequest.prototype.onContentScriptLoadImpl = function (tabId, frameId, isMainFrame, configuration, sendResponse) {
        try {
            var mainFrameState = this.tabsStates.getTab(tabId);
            // Frame not present means that extension ran after it has been loaded.
            var currentFrameState = frameId !== -1
                ? this.tabsStates.getFrame({ tabId: tabId, frameId: frameId })
                : null;
            var wpmParameters = {
                wpm: false,
                httpWebPageLoad: false
            };
            if (mainFrameState != null) {
                if (isMainFrame) {
                    wpmParameters.wpm =
                        configuration.isMatchForWpmUrls(mainFrameState.startUrl, mainFrameState.committedUrl);
                }
                wpmParameters.httpWebPageLoad = configuration.isMatchForHttpWebPageLoadUrl(mainFrameState.startUrl);
            }
            var documentUrl = mainFrameState != null ? mainFrameState.startUrl : "";
            var documentCommittedUrl = (mainFrameState != null && mainFrameState.committedUrl != null) ? mainFrameState.committedUrl : "";
            var documentTitle = undefined;
            if (this.tabsMonitoring != null) {
                var tabState = this.tabsMonitoring.getTabState(tabId);
                if (tabState != null) {
                    documentTitle = tabState.documentTitle;
                }
            }
            var response = {
                configurationData: configuration.getEventsForPage({
                    documentUrl: documentUrl,
                    documentCommittedUrl: documentCommittedUrl
                }),
                pageInformation: {
                    documentUrl: documentUrl,
                    documentCommittedUrl: documentCommittedUrl,
                    frameUrl: currentFrameState != null ? currentFrameState.startUrl : "",
                    frameCommittedUrl: currentFrameState != null
                        ? currentFrameState.committedUrl != null
                            ? currentFrameState.committedUrl : "" : "",
                    tabId: tabId,
                    frameId: frameId,
                },
                statusCode: currentFrameState != null ? currentFrameState.statusCode : 0,
                wpmParameters: wpmParameters,
                documentTitle: documentTitle,
            };
            sendResponse(response);
            log_1.getLogger().info("Sent configuration to content", response);
        }
        catch (e) {
            log_1.getLogger().warn("Couldn't send configuration to tab: " + tabId + ", frame: " + frameId + ", error: ", e);
        }
    };
    WebRequest.prototype.onGetStatusCode = function (sender, sendResponse) {
        var tabId = sender.tab != null && sender.tab.id != null
            ? sender.tab.id
            : -1;
        // ReSharper disable once AssignedValueIsNeverUsed
        var statusCode = -1;
        var currentFrame = sender.frameId != null
            ? this.tabsStates.getFrame({ tabId: tabId, frameId: sender.frameId })
            : null;
        if (currentFrame == null) {
            log_1.getLogger().error("Did not receive frameId from sender. Probably not supported in this Chrome version.");
            statusCode = -1;
        }
        else if (currentFrame.statusCode == null) {
            log_1.getLogger().error("Did not receive statusCode.");
            statusCode = -1;
        }
        else {
            statusCode = currentFrame.statusCode;
        }
        sendResponse({ statusCode: statusCode });
    };
    // #endregion
    WebRequest.prototype.initWebRequest = function (manager, communication, tabsMonitoring, configuration) {
        this.manager = manager;
        this.communication = communication;
        this.tabsMonitoring = tabsMonitoring;
        this.configuration = configuration;
        var filter = { urls: ["<all_urls>"] };
        webRequest.onBeforeRequest.addListener(this.onBeforeRequest, filter, ["requestBody"]);
        webRequest.onBeforeSendHeaders.addListener(this.onBeforeSendHeaders, filter, ["requestHeaders"]);
        webRequest.onSendHeaders.addListener(this.onSendHeaders, filter, ["requestHeaders"]);
        webRequest.onHeadersReceived.addListener(this.onHeadersReceived, filter, ["responseHeaders"]);
        webRequest.onAuthRequired.addListener(this.onAuthRequired, filter, ["responseHeaders"]);
        webRequest.onResponseStarted.addListener(this.onResponseStarted, filter, ["responseHeaders"]);
        webRequest.onBeforeRedirect.addListener(this.onBeforeRedirect, filter, ["responseHeaders"]);
        webRequest.onCompleted.addListener(this.onCompleted, filter, ["responseHeaders"]);
        webRequest.onErrorOccurred.addListener(this.onErrorOccurred, filter);
        chrome.runtime.onMessage.addListener(this.onMessage);
        this.tabsStates.validateAllTabs();
    };
    WebRequest.prototype.uninitWebRequest = function () {
        webRequest.onBeforeRequest.removeListener(this.onBeforeRequest);
        webRequest.onBeforeSendHeaders.removeListener(this.onBeforeSendHeaders);
        webRequest.onSendHeaders.removeListener(this.onSendHeaders);
        webRequest.onHeadersReceived.removeListener(this.onHeadersReceived);
        webRequest.onAuthRequired.removeListener(this.onAuthRequired);
        webRequest.onResponseStarted.removeListener(this.onResponseStarted);
        webRequest.onBeforeRedirect.removeListener(this.onBeforeRedirect);
        webRequest.onCompleted.removeListener(this.onCompleted);
        webRequest.onErrorOccurred.removeListener(this.onErrorOccurred);
        chrome.runtime.onMessage.removeListener(this.onMessage);
        this.manager = undefined;
        this.communication = undefined;
        this.configuration = undefined;
        this.tabsMonitoring = undefined;
    };
    /**
     * Header indicating AppInternals monitoring.
     */
    WebRequest.APPINTERNALS_TRACE_HEADER = "X-OPNET-Transaction-Trace";
    /**
     * Header indicating AppInternals monitoring in UX property format.
     */
    WebRequest.WEBREQUEST_APPINTERNALS_RESPONSE_HEADER = WebRequest.makeHeaderProperty("responseHeaders", WebRequest.APPINTERNALS_TRACE_HEADER);
    /**
     * We don't want to send out passwords (if we can help it)
     * Most websites use the same names for password fields, so we try and find those values
     */
    WebRequest.passwordRegEx = new RegExp("(.*pwd$)|(pass)|(.*pw$)|(heslo)|(contraseña)|(contrasena)|(adgangskode)|" +
        "(пароль)|(senha)|(ordine)|(paswoord)|(密码)|(密碼)|(पासवर्ड)|(סיס)", "i");
    return WebRequest;
}());
exports.WebRequest = WebRequest;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// ReSharper disable InconsistentNaming
/**
 * WebRequest events.
 * This must be synchronized with the Agent.
 */
var WebRequestEvent;
(function (WebRequestEvent) {
    WebRequestEvent[WebRequestEvent["BeforeRequest"] = 0] = "BeforeRequest";
    WebRequestEvent[WebRequestEvent["BeforeSendHeaders"] = 1] = "BeforeSendHeaders";
    WebRequestEvent[WebRequestEvent["SendHeaders"] = 2] = "SendHeaders";
    WebRequestEvent[WebRequestEvent["HeadersReceived"] = 3] = "HeadersReceived";
    WebRequestEvent[WebRequestEvent["AuthRequired"] = 4] = "AuthRequired";
    WebRequestEvent[WebRequestEvent["ResponseStarted"] = 5] = "ResponseStarted";
    WebRequestEvent[WebRequestEvent["BeforeRedirect"] = 6] = "BeforeRedirect";
    WebRequestEvent[WebRequestEvent["Completed"] = 7] = "Completed";
    WebRequestEvent[WebRequestEvent["ErrorOccurred"] = 8] = "ErrorOccurred";
})(WebRequestEvent = exports.WebRequestEvent || (exports.WebRequestEvent = {}));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var Utils = __webpack_require__(0);
var timeProvider_1 = __webpack_require__(3);
var MessagingModel_1 = __webpack_require__(2);
exports.IDLE_EVENT_NAMESPACE = "ui:chrome:Idle";
function makeEventName(event) {
    return exports.IDLE_EVENT_NAMESPACE + "." + event;
}
/**
 * Create base tab message.
 */
function createDataMessage(event) {
    var message = new MessagingModel_1.OutgoingEventMessage(makeEventName(event), timeProvider_1.timeProvider.now());
    return message;
}
var IdleMonitoring = /** @class */ (function () {
    function IdleMonitoring() {
        var _this = this;
        this.onStateChanged = function (newState) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().debug("Idle onStateChanged", newState);
            var message = createDataMessage(Utils.capitalize(newState));
            if (_this.communication != null) {
                _this.communication.postNativeMessage(message);
            }
        };
        this.idleMonitoringEnabled = false;
    }
    IdleMonitoring.prototype.initIdleMonitoring = function (manager, communication) {
        if (this.idleMonitoringEnabled) {
            log_1.getLogger().error("You can't init idle monitoring twice in a row (without uninit)");
            return;
        }
        this.manager = manager;
        this.communication = communication;
        this.idleMonitoringEnabled = true;
        if (chrome.idle.onStateChanged != null) {
            chrome.idle.onStateChanged.addListener(this.onStateChanged);
        }
    };
    IdleMonitoring.prototype.uninitIdleMonitoring = function () {
        this.idleMonitoringEnabled = false;
        if (chrome.idle.onStateChanged != null) {
            chrome.idle.onStateChanged.removeListener(this.onStateChanged);
        }
    };
    return IdleMonitoring;
}());
exports.IdleMonitoring = IdleMonitoring;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var timeProvider_1 = __webpack_require__(3);
var MessagingModel_1 = __webpack_require__(2);
// #region Utility
exports.WINDOW_EVENT_NAMESPACE = "ui:chrome:Window";
function makeEventName(event) {
    return exports.WINDOW_EVENT_NAMESPACE + "." + event;
}
/**
 * Create base tab message.
 */
function createDataMessage(event, timestamp, tab) {
    if (timestamp === void 0) { timestamp = timeProvider_1.timeProvider.now(); }
    var message = new MessagingModel_1.OutgoingEventMessage(makeEventName(event), timestamp);
    var messageData = message.messageData.Data[0];
    if (tab != null) {
        messageData.windowId = tab.windowId;
        messageData.tabId = tab.id;
        messageData.url = tab.url;
    }
    return message;
}
// #endregion
var WindowsMonitoring = /** @class */ (function () {
    function WindowsMonitoring() {
        var _this = this;
        this.onFocusChanged = function (windowId) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            var communication = _this.communication;
            if (communication == null) {
                return;
            }
            if (windowId !== chrome.windows.WINDOW_ID_NONE) {
                var now_1 = timeProvider_1.timeProvider.now();
                chrome.tabs.query({ active: true, windowId: windowId }, function (result) {
                    var tab = (result != null && result.length >= 0 ? result[0] : undefined);
                    log_1.getLogger().debug("Window onFocusChanged", tab);
                    var message = createDataMessage("FocusChanged", now_1, tab);
                    communication.postNativeMessage(message);
                });
            }
            else {
                log_1.getLogger().debug("Window LostFocus");
                var message = createDataMessage("LostFocus");
                communication.postNativeMessage(message);
            }
        };
        this.windowMonitoringEnabled = false;
    }
    WindowsMonitoring.prototype.initWindowsMonitoring = function (manager, communication) {
        if (this.windowMonitoringEnabled) {
            log_1.getLogger().error("You can't init windows monitoring twice in a row (without uninit)");
            return;
        }
        this.manager = manager;
        this.communication = communication;
        this.windowMonitoringEnabled = true;
        chrome.windows.onFocusChanged.addListener(this.onFocusChanged);
    };
    WindowsMonitoring.prototype.uninitWindowsMonitoring = function () {
        this.windowMonitoringEnabled = false;
        chrome.windows.onFocusChanged.removeListener(this.onFocusChanged);
    };
    return WindowsMonitoring;
}());
exports.WindowsMonitoring = WindowsMonitoring;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var utils_1 = __webpack_require__(0);
/**
 * Execute script with error handling in a specified tab.
 */
function executeFunctionInTab(tab, f, method) {
    if (typeof tab.id === "undefined")
        return;
    if (tab.url == null)
        return;
    if (!utils_1.startsWith(tab.url, "http"))
        return;
    chrome.scripting.executeScript({
        target: { tabId: tab.id, allFrames: true }, func: f, args: []
    }).then(function (value) {
        if (chrome.runtime.lastError != null) {
            // ReSharper disable once TsResolvedFromInaccessibleModule
            log_1.getLogger().error("Could not execute " + method + " in tab", tab.id, chrome.runtime.lastError.message);
        }
    }).catch(function (reason) {
        // ReSharper disable once TsResolvedFromInaccessibleModule
        log_1.getLogger().error("Could not execute " + method + " in tab", tab.id, reason);
    });
    // chrome.tabs.executeScript(tab.id,
    // 	{
    // 		code: makeFunctionCall(f),
    // 		allFrames: true
    // 	},
    // 	() => {
    // 		if (chrome.runtime.lastError != null) {
    // 			// ReSharper disable once TsResolvedFromInaccessibleModule
    // 			getLogger().error(`Could not execute ${method} in tab`, tab.id, chrome.runtime.lastError.message);
    // 		}
    // 	}
    // );
}
exports.executeFunctionInTab = executeFunctionInTab;
/**
 * Send message with error handling to a specified tab.
 */
function sendMessageToTab(tab, frameId, message, success, failure) {
    if (typeof tab.id === "undefined")
        return;
    if (tab.url == null)
        return;
    if (!utils_1.startsWith(tab.url, "http"))
        return;
    chrome.tabs.sendMessage(tab.id, message, { frameId: frameId }, function (response) {
        if (chrome.runtime.lastError == null) {
            if (success != null)
                success(response);
        }
        else {
            if (success === undefined &&
                chrome.runtime.lastError.message === "The message port closed before a response was received.") {
                // This is expected and could be avoided by sendMessage without a response callback.
                // We still call sendMessage this way to log any other errors.
                return;
            }
            if (failure != null)
                failure(chrome.runtime.lastError);
        }
    });
}
exports.sendMessageToTab = sendMessageToTab;
/**
 * Send message with error handling to a specified tab.
 */
function sendMessageToTabWithLog(tab, message) {
    sendMessageToTab(tab, undefined, message, undefined, function (lastError) {
        log_1.getLogger().error("Could not send message to tab", tab.id, "error:", lastError.message, "message to be sent:", message);
    });
}
exports.sendMessageToTabWithLog = sendMessageToTabWithLog;


/***/ }),
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(57);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Make logging globally visible
var log_1 = __webpack_require__(1);
exports.enableLogs = log_1.enableLogs;
exports.disableLogs = log_1.disableLogs;
var AgentCommunication_1 = __webpack_require__(58);
var BackgroundManager_1 = __webpack_require__(60);
var WebRequest_1 = __webpack_require__(32);
var WebNavigation_1 = __webpack_require__(64);
var TabsMonitoring_1 = __webpack_require__(66);
var WindowsMonitoring_1 = __webpack_require__(35);
var IdleMonitoring_1 = __webpack_require__(34);
var HtmlEventsMonitoring_1 = __webpack_require__(67);
var WacCommunication_1 = __webpack_require__(68);
var ConfigurationManager_1 = __webpack_require__(70);
var WacEventReporter_1 = __webpack_require__(73);
var DownloadsMonitoring_1 = __webpack_require__(22);
var configurationManager = new ConfigurationManager_1.ConfigurationManager();
var wacCommunication = new WacCommunication_1.WacCommunication();
var wacEventReporter = new WacEventReporter_1.WacEventReporter(wacCommunication);
var communication = new AgentCommunication_1.AgentCommunication(wacCommunication, configurationManager, wacCommunication, wacEventReporter);
var webNavigation = new WebNavigation_1.WebNavigation();
var webRequest = new WebRequest_1.WebRequest(webNavigation.webNavigationTabsStates);
var tabsMonitoring = new TabsMonitoring_1.TabsMonitoring();
var windowsMonitoring = new WindowsMonitoring_1.WindowsMonitoring();
var idleMonitoring = new IdleMonitoring_1.IdleMonitoring();
var htmlEventsMonitoring = new HtmlEventsMonitoring_1.HtmlEventsMonitoring();
var downloadsMonitoring = new DownloadsMonitoring_1.DownloadsMonitoring();
exports.manager = new BackgroundManager_1.BackgroundManager(communication, configurationManager, tabsMonitoring, webRequest, webNavigation, windowsMonitoring, idleMonitoring, htmlEventsMonitoring, wacCommunication, downloadsMonitoring);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Utils = __webpack_require__(0);
var Pako = __webpack_require__(59);
var Consts = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var utils_1 = __webpack_require__(0);
var FrameType_1 = __webpack_require__(11);
var MessageOrder_1 = __webpack_require__(30);
var NativeMessaging = __webpack_require__(31);
var NativeMessaging_1 = __webpack_require__(31);
var MessagingModel_1 = __webpack_require__(2);
var DownloadsMonitoring_1 = __webpack_require__(22);
var browserInfo_1 = __webpack_require__(8);
var AgentCommunication = /** @class */ (function () {
    function AgentCommunication(wacNativeCommunication, configurationManager, wacCommunication, wacEventReporter) {
        var _this = this;
        this.wacNativeCommunication = wacNativeCommunication;
        this.configurationManager = configurationManager;
        this.wacCommunication = wacCommunication;
        this.wacEventReporter = wacEventReporter;
        // tslint:disable-next-line no-any
        this.onNativeMessage = function (message) {
            log_1.getLogger().log("message", message);
            if (_this.manager == null) {
                return;
            }
            // Validate parameters
            if (message == null) {
                log_1.getLogger().error("Invalid request, no parameters");
                return;
            }
            var incomingMessage = {};
            if (typeof message !== "object") {
                log_1.getLogger().error("Invalid request, not object type");
                return;
            }
            incomingMessage = message;
            if (incomingMessage.version !== NativeMessaging.INCOMING_VERSION) {
                log_1.getLogger().error("Incoming message version is not supported", incomingMessage);
                return;
            }
            switch (incomingMessage.type) {
                case NativeMessaging_1.IncomingAction.Configuration:
                    /* tslint:disable no-unsafe-any */
                    var encoded = JSON.parse(incomingMessage.data).Configuration;
                    var decoded = atob(encoded);
                    // Unzip data
                    // ReSharper bug: The cast is must to get string return type.
                    // tslint:disable-next-line no-object-literal-type-assertion
                    var unzippedJson = Pako.inflate(Utils.binstring2Buf(decoded), { to: "string" });
                    _this.configurationManager.setAgentConfiguration(unzippedJson);
                    break;
                case NativeMessaging_1.IncomingAction.Deactivate:
                    _this.manager.deactivate();
                    break;
                case NativeMessaging_1.IncomingAction.WacMessage:
                    if (message.message == null) {
                        log_1.getLogger().log("Incoming WAC message has null data", incomingMessage);
                        // return;
                    }
                    else {
                        if (typeof message.message === "string") {
                            message.message = JSON.parse(message.message);
                        }
                    }
                    _this.wacNativeCommunication.incomingMessage(message);
                    break;
                default:
                    log_1.getLogger().error("Unsupported message", message);
            }
        };
        /** Forward message from content to native */
        // tslint:disable-next-line no-any
        this.onRuntimeMessage = function (message, sender, sendResponse) {
            if (message.messageType == null || MessagingModel_1.CONTENT_MESSAGES.indexOf(message.messageType) !== -1)
                return;
            // Enrich it with tabId and frameId
            if (sender != null) {
                if (sender.tab != null) {
                    message.tabId = sender.tab.id;
                }
                if (typeof (sender.frameId) !== "undefined") {
                    message.frameId = sender.frameId;
                }
            }
            if (_this.validateMessageStructure(message)) {
                _this.postNativeMessage(message);
            }
            else {
                log_1.getLogger().error("Message structure is not according to protocol.", message);
                return;
            }
        };
    }
    // tslint:disable-next-line no-any
    AgentCommunication.prototype.validateMessageStructure = function (message) {
        var _this = this;
        if (typeof message.messageType !== "string") {
            return false;
        }
        if (typeof message.timeStamp !== "number") {
            return false;
        }
        // messageData either absent or array
        // See Data.OutgoingEventMessage and Data.OutgoingWpmPageLoadEventMessage for instance.
        var messageData = message.messageData;
        if (messageData === undefined) {
            return true;
        }
        else {
            var data = message.messageData.Data;
            if (!Array.isArray(data)) {
                return false;
            }
            // tslint:disable-next-line no-any
            return !data.some(function (d) { return !_this.validateMessageDataStructure(d); });
        }
    };
    /* tslint:disable-next-line no-any no-unsafe-any */
    AgentCommunication.prototype.validateMessageDataStructure = function (messageData) {
        for (var propertyName in messageData) {
            if (!messageData.hasOwnProperty(propertyName))
                continue;
            var value = messageData[propertyName];
            if (utils_1.isSerializablePrimitive(value)) {
                continue;
            }
            else if (Array.isArray(value)) {
                // tslint:disable-next-line no-any
                if (value.some(function (element) { return !utils_1.isSerializablePrimitive(element); })) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    };
    AgentCommunication.prototype.onDisconnect = function (unsubscribeRuntimeMessage) {
        log_1.getLogger().info("NMH disconnected");
        if (unsubscribeRuntimeMessage) {
            chrome.runtime.onMessage.removeListener(this.onRuntimeMessage);
        }
        if (this.nativeMessagingPort != null) {
            this.nativeMessagingPort.onMessage.removeListener(this.onNativeMessage);
            if (this.disconnectCallback != null) {
                this.nativeMessagingPort.onDisconnect.removeListener(this.disconnectCallback);
            }
        }
        this.disconnectCallback = undefined;
        this.nativeMessagingPort = undefined;
        // Reset configuration
        this.configurationManager.resetConfiguration();
        // Ask the manager to try to connect again...
        if (this.manager != null) {
            this.manager.scheduleConnectAttempt();
        }
    };
    AgentCommunication.prototype.start = function (onlineConfiguration) {
        var _this = this;
        if (onlineConfiguration === void 0) { onlineConfiguration = true; }
        try {
            var port = undefined;
            if (onlineConfiguration) {
                console.trace("Starting and connecting NMH");
                port = chrome.runtime.connectNative(AgentCommunication.HOST_NAME);
            }
            chrome.runtime.onMessage.removeListener(this.onRuntimeMessage);
            chrome.runtime.onMessage.addListener(this.onRuntimeMessage);
            if (this.disconnectCallback != null) {
                if (this.nativeMessagingPort != null) {
                    this.nativeMessagingPort.onDisconnect.removeListener(this.disconnectCallback);
                }
            }
            if (onlineConfiguration && port != null) {
                port.onMessage.addListener(this.onNativeMessage);
                this.disconnectCallback = function () { return _this.onDisconnect(onlineConfiguration); };
                if (this.disconnectCallback != null) {
                    port.onDisconnect.addListener(this.disconnectCallback);
                }
                log_1.getLogger().info("Connect");
                var message = "Connected extension with id " + chrome.runtime.id;
                port.postMessage(new MessagingModel_1.OutgoingLogMessage(Consts.LogLevel.INFO, message));
            }
            return port;
        }
        catch (e) {
            log_1.getLogger().error("Cannot connect to native messaging. Pages are not monitored. ", e);
            return undefined;
        }
    };
    AgentCommunication.prototype.stop = function () {
        if (this.nativeMessagingPort != null) {
            chrome.runtime.onMessage.removeListener(this.onRuntimeMessage);
            this.nativeMessagingPort.onMessage.removeListener(this.onNativeMessage);
            if (this.disconnectCallback != null) {
                this.nativeMessagingPort.onDisconnect.removeListener(this.disconnectCallback);
            }
            this.disconnectCallback = undefined;
            this.nativeMessagingPort = undefined;
        }
    };
    // todo: Idea, Move to class Reporter
    /**
     * Post message to the native messaging host.
     * WARNING: This private changes the object.
     */
    AgentCommunication.prototype.postNativeMessage = function (message, options) {
        if (options === void 0) { options = { forcePost: false }; }
        if (this.manager == null) {
            return;
        }
        var messageProcessor = this.manager.getMessageProcessor();
        if (messageProcessor == null) {
            return;
        }
        // Do not send messages if not activated. Log is exception.
        if (!this.manager.active && message.messageType !== MessagingModel_1.MessageType.LOG) {
            return;
        }
        // Add data for event message
        if (message.messageType === MessagingModel_1.MessageType.EVENT) {
            var messageData = message.messageData;
            if (messageData == null) {
                return;
            }
            // Negative value messages are always sent
            if (messageData.EventType === MessagingModel_1.NV_CHROME_WORKTIME_VIOLATION) {
                options.forcePost = true;
            }
            // Downloads events are only reported if they are configured
            if (Utils.startsWith(messageData.EventType, DownloadsMonitoring_1.DOWNLOADS_EVENT_NAMESPACE)) {
                options.forcePost = true;
            }
            // Filter out unmonitored events
            if (!options.forcePost && !messageProcessor.isEventMonitored(messageData)) {
                return;
            }
            // Handle optional AppInternals information
            var pageMessage = message;
            var tabId = pageMessage.tabId != null ? pageMessage.tabId : messageData.Data[0]["tabId"];
            var frameId = pageMessage.frameId != null ? pageMessage.frameId : messageData.Data[0]["frameId"];
            if (tabId != null && frameId != null) {
                this.addPageInformationProperties(tabId, frameId, messageData);
            }
            // WAC mode
            if (this.wacEventReporter.wacMode()) {
                this.wacEventReporter.reportToWac(pageMessage);
                return;
            }
            // Adjust the timestamp of the WPM page error message, since it can be timestamped earlier than the corresponding committed event
            if (messageData.EventType === MessagingModel_1.WPM_PAGE_ERROR_UX) {
                var now = Date.now().valueOf();
                if (message.timeStamp < now) {
                    message.timeStamp = now;
                }
            }
            messageProcessor.processMessageData(messageData, options);
            this.addAdditionalData(messageData);
            log_1.getLogger().log("Sending event to native", message.timeStamp, messageData);
        }
        else if (message.messageType === MessagingModel_1.MessageType.WPM_PAGELOAD_EVENT ||
            message.messageType === MessagingModel_1.MessageType.WPM_ERROR_EVENT) {
            log_1.getLogger().log("Sending wpm to native", message);
        }
        else if (message.messageType === MessagingModel_1.MessageType.LOG) {
            log_1.getLogger().log("Logging", message.message);
        }
        else if (message.messageType === MessagingModel_1.MessageType.WAC_TO_IE) {
            log_1.getLogger().log("Sending WACtoIE to native", message);
        }
        else {
            log_1.getLogger().warn("Unknown message type", message.messageType);
        }
        if (this.nativeMessagingPort != null) {
            // Set order only if wasn't set manually
            if (typeof message.order === "undefined") {
                message.order = MessageOrder_1.getNativeMessageOrder();
            }
            this.nativeMessagingPort.postMessage(message);
        }
    };
    AgentCommunication.prototype.initCommunication = function (manager, webNavigation, onlineConfiguration) {
        if (onlineConfiguration === void 0) { onlineConfiguration = true; }
        this.manager = manager;
        this.webNavigation = webNavigation;
        if (this.nativeMessagingPort !== undefined) {
            console.trace("Existing NMH found, disconnecting from previous NMH.");
            this.nativeMessagingPort.disconnect();
            this.nativeMessagingPort = undefined;
        }
        this.nativeMessagingPort = this.start(onlineConfiguration);
        this.configurationManager.initConfigurationManager(this.manager);
        if (this.wacCommunication.isBrowserChromiumBased(browserInfo_1.browserInfo.name)) { // see DE23408
            this.wacCommunication.activate(this, this.manager.getTabsMonitoring(), this.configurationManager);
        }
        else {
            log_1.getLogger().log("wacCommunication was not activated. Browser name in use: ", browserInfo_1.browserInfo.name);
        }
        if (this.nativeMessagingPort == null && onlineConfiguration) {
            console.trace("Failed connecting to native messaging port");
            return false;
        }
        else {
            log_1.getLogger().info("Succeeded connecting to native messaging port");
            console.trace("Succeeded connecting to native messaging port");
            return true;
        }
    };
    AgentCommunication.prototype.uninitCommunication = function () {
        this.stop();
        this.wacCommunication.deactivate();
    };
    /**
     * Add additional data to the message like extension version and any other information.
     * This should never be trimmed since it is essential.
     */
    AgentCommunication.prototype.addAdditionalData = function (messageData) {
        var eventData = messageData.Data[0];
        eventData.extensionVersion = Consts.EXTENSION_VERSION.getValue();
    };
    AgentCommunication.prototype.addPageInformationProperties = function (tabId, frameId, messageData) {
        if (this.manager == null || this.webNavigation == null) {
            return;
        }
        var tabState = this.manager.getTabsMonitoring().getTabState(tabId);
        var frameState = frameId === 0 ? null : this.webNavigation.getFrame(tabId, frameId);
        var mainFrameState = this.webNavigation.getFrame(tabId, 0);
        var data = messageData.Data[0];
        // Ids
        utils_1.setIfNotExist(data, "tabId", tabId);
        utils_1.setIfNotExist(data, "frameId", frameId);
        utils_1.setIfNotExist(data, "type", FrameType_1.getFrameType(frameId));
        // Properties from main frame state
        if (mainFrameState != null) {
            utils_1.setIfNotExist(data, "documentUrl", mainFrameState.startUrl);
            if (mainFrameState.committedUrl != null) {
                utils_1.setIfNotExist(data, "documentCommittedUrl", mainFrameState.committedUrl);
            }
            if (frameId === 0) {
                // Frame properties
                utils_1.setIfNotExist(data, "frameUrl", mainFrameState.startUrl);
                if (mainFrameState.committedUrl != null) {
                    utils_1.setIfNotExist(data, "frameCommittedUrl", mainFrameState.committedUrl);
                }
            }
        }
        // Properties from tab
        if (tabState != null) {
            utils_1.setIfNotExist(data, "documentTitle", tabState.title);
            utils_1.setIfNotExist(data, "documentCurrentUrl", tabState.currentUrl);
            if (frameId === 0) {
                // Context dependent properties
                utils_1.setIfNotExist(data, "title", tabState.title);
                // Frame properties
                utils_1.setIfNotExist(data, "frameTitle", tabState.title);
                utils_1.setIfNotExist(data, "frameCurrentUrl", tabState.currentUrl);
            }
        }
        // Properties from frame state, only applicable to frames
        if (frameState != null) {
            utils_1.setIfNotExist(data, "frameUrl", frameState.startUrl);
            if (frameState.committedUrl != null) {
                utils_1.setIfNotExist(data, "frameCommittedUrl", frameState.committedUrl);
            }
            utils_1.setIfNotExist(data, "frameCurrentUrl", frameState.currentUrl);
        }
        // Set documentCurrentUrl if wasn't set
        if (mainFrameState != null) {
            utils_1.setIfNotExist(data, "documentCurrentUrl", mainFrameState.currentUrl);
        }
    };
    AgentCommunication.HOST_NAME = "com.aternity.fpi";
    return AgentCommunication;
}());
exports.AgentCommunication = AgentCommunication;


/***/ }),
/* 59 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deflate", function() { return Deflate_1$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Inflate", function() { return Inflate_1$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constants", function() { return constants_1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflate", function() { return deflate_1$2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateRaw", function() { return deflateRaw_1$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gzip", function() { return gzip_1$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflate", function() { return inflate_1$2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateRaw", function() { return inflateRaw_1$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ungzip", function() { return ungzip_1; });

/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

var _tr_init_1  = _tr_init;
var _tr_stored_block_1 = _tr_stored_block;
var _tr_flush_block_1  = _tr_flush_block;
var _tr_tally_1 = _tr_tally;
var _tr_align_1 = _tr_align;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init: _tr_init$1, _tr_stored_block: _tr_stored_block$1, _tr_flush_block: _tr_flush_block$1, _tr_tally: _tr_tally$1, _tr_align: _tr_align$1 } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED: Z_FIXED$1, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN: Z_UNKNOWN$1,
  Z_DEFLATED
} = constants;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS$1      = 256;
/* number of literal bytes 0..255 */
const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES$1       = 30;
/* number of distance codes */
const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */
const MAX_BITS$1  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const MIN_LOOKAHEAD = (MAX_MATCH$1 + MIN_MATCH$1 + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero$1 = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block$1(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH$1;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$1) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH$1) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH$1) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH$1 - 1)) ? s.strstart : MIN_MATCH$1 - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$1) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH$1) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero$1(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE$1 * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES$1 + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES$1 + 1);  /* heap used to build the Huffman trees */
  zero$1(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES$1 + 1); //uch depth[2*L_CODES+1];
  zero$1(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$1;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  _tr_init$1(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED$1) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


const deflate = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align$1(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block$1(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero$1(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero$1(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2 = deflate;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  let i, out;
  const len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$1,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_DEFLATED: Z_DEFLATED$1
} = constants;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$1,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$1
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$1) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$1;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$1) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1 = Deflate;
var deflate_2$1 = deflate$1;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var constants$1 = constants;

var deflate_1$1 = {
	Deflate: Deflate_1,
	deflate: deflate_2$1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 30;       /* got a data error -- remain here until reset */
const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$2, Z_BLOCK: Z_BLOCK$1, Z_TREES,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_NEED_DICT, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFLATED: Z_DEFLATED$2
} = constants;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD$1 = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS$1;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$1);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$1);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$2;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$2) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS$1,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS$1, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE$1) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$2;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD$1;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED$2) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$1;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD$1;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE$1;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED$2) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$1;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD$1;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE$1;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE$1;
        /* falls through */
      case TYPE$1:
        if (flush === Z_BLOCK$1 || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD$1;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD$1;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE$1;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD$1;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD$1;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD$1;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD$1;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD$1) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD$1;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD$1;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD$1;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE$1) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE$1;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$1;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD$1;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD$1;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$2;
        break inf_leave;
      case BAD$1:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD$1 &&
                      (state.mode < CHECK || flush !== Z_FINISH$2))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE$1 ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$2) && ret === Z_OK$2) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$2;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$2;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$2;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2 = inflate;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/

var inflate_1 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_FINISH: Z_FINISH$3,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_MEM_ERROR: Z_MEM_ERROR$1
} = constants;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK$3) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$3) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$3 : Z_NO_FLUSH$2;

  // Convert data if needed
  if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT$1 && dictionary) {
      status = inflate_1.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK$3) {
        status = inflate_1.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$2) {
        // Replace code with more verbose
        status = Z_NEED_DICT$1;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END$3 &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1.inflateReset(strm);
      status = inflate_1.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR$2:
      case Z_DATA_ERROR$2:
      case Z_NEED_DICT$1:
      case Z_MEM_ERROR$1:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$3) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK$3 && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END$3) {
      status = inflate_1.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$3) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1 = Inflate;
var inflate_2$1 = inflate$1;
var inflateRaw_1 = inflateRaw;
var ungzip = inflate$1;
var constants$2 = constants;

var inflate_1$1 = {
	Inflate: Inflate_1,
	inflate: inflate_2$1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip,
	constants: constants$2
};

const { Deflate: Deflate$1, deflate: deflate$2, deflateRaw: deflateRaw$1, gzip: gzip$1 } = deflate_1$1;

const { Inflate: Inflate$1, inflate: inflate$2, inflateRaw: inflateRaw$1, ungzip: ungzip$1 } = inflate_1$1;



var Deflate_1$1 = Deflate$1;
var deflate_1$2 = deflate$2;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var Inflate_1$1 = Inflate$1;
var inflate_1$2 = inflate$2;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip_1 = ungzip$1;
var constants_1 = constants;

var pako = {
	Deflate: Deflate_1$1,
	deflate: deflate_1$2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	Inflate: Inflate_1$1,
	inflate: inflate_1$2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip_1,
	constants: constants_1
};

/* harmony default export */ __webpack_exports__["default"] = (pako);



/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var log_2 = __webpack_require__(1);
var EventNames = __webpack_require__(10);
var WebRequest_1 = __webpack_require__(32);
var IdleMonitoring = __webpack_require__(34);
var WindowsMonitoring = __webpack_require__(35);
var DownloadsMonitoring = __webpack_require__(22);
var timeProvider_1 = __webpack_require__(3);
var ConfigurationData_1 = __webpack_require__(9);
var WebNavigationReporter_1 = __webpack_require__(62);
var Configuration_1 = __webpack_require__(12);
var MessageProcessor_1 = __webpack_require__(63);
/**
 * Manages all subscriptions
 */
var BackgroundManager = /** @class */ (function () {
    function BackgroundManager(communication, configurationManager, tabsMonitoring, webRequest, webNavigation, windowsMonitoring, idleMonitoring, htmlEventsMonitoring, wacCommunication, downloadsMonitoring) {
        this.communication = communication;
        this.configurationManager = configurationManager;
        this.tabsMonitoring = tabsMonitoring;
        this.webRequest = webRequest;
        this.webNavigation = webNavigation;
        this.windowsMonitoring = windowsMonitoring;
        this.idleMonitoring = idleMonitoring;
        this.htmlEventsMonitoring = htmlEventsMonitoring;
        this.wacCommunication = wacCommunication;
        this.downloadsMonitoring = downloadsMonitoring;
        this.active = false;
        this.isConnectionTimeoutActive = false;
        this.timeoutId = null;
        this.webNavigationReporter = new WebNavigationReporter_1.WebNavigationReporter(communication);
        log_2.enableLogs();
        this.connectToPort();
    }
    BackgroundManager.prototype.getTabsMonitoring = function () {
        return this.tabsMonitoring;
    };
    BackgroundManager.prototype.getMessageProcessor = function () {
        return this.messageProcessor;
    };
    BackgroundManager.prototype.scheduleConnectAttempt = function () {
        var _this = this;
        if (this.isConnectionTimeoutActive) {
            log_1.getLogger().error("There is already a connection attempt.");
        }
        else {
            this.isConnectionTimeoutActive = true;
            var retryConnectMs = 60 * 1000;
            var dateObjWithOffset = new Date(timeProvider_1.timeProvider.now() + retryConnectMs);
            log_1.getLogger().info("Scheduling another connection attempt on " + dateObjWithOffset + ".");
            if (this.timeoutId === null) {
                this.timeoutId = setTimeout(function () {
                    _this.isConnectionTimeoutActive = false;
                    _this.connectToPort();
                    _this.timeoutId = null;
                }, retryConnectMs);
            }
        }
    };
    BackgroundManager.prototype.connectToPort = function () {
        if (this.isConnectionTimeoutActive) {
            log_1.getLogger().error("it isn't allowed to try to connect");
        }
        else {
            log_1.getLogger().info("Trying to connect....");
            if (!this.communication.initCommunication(this, this.webNavigation)) {
                log_1.getLogger().warn("Failed");
                this.scheduleConnectAttempt();
            }
            else {
                log_1.getLogger().info("Success");
            }
        }
    };
    BackgroundManager.prototype.activate = function (configuration) {
        if (this.active) {
            return;
        }
        log_1.getLogger().log("Activating");
        this.active = true;
        this.messageProcessor = new MessageProcessor_1.MessageProcessor(configuration);
        this.webNavigation.subscribe(this.webNavigationReporter.onWebNavigation);
        this.webNavigation.subscribe(this.wacCommunication.onWebNavigation);
        // HTML events monitoring
        var hasHtmlEventsMonitoring = configuration.isMonitoring(EventNames.HTML_DESIGNER_EVENT_NAMESPACE) ||
            configuration.isMonitoring(EventNames.HTML_ONAPP_EVENT_NAMESPACE) ||
            configuration.isMonitoring(EventNames.DOM_EVENT_NAMESPACE);
        var hasWebRequestMonitoring = hasHtmlEventsMonitoring ||
            configuration.hasWpmFilter() ||
            configuration.isMonitoring(WebRequest_1.WEB_REQUEST_EVENT_NAMESPACE);
        this.tabsMonitoring.initTabsMonitoring(this, this.communication, this.webRequest, this.webNavigation);
        if (hasWebRequestMonitoring) {
            this.webRequest.initWebRequest(this, this.communication, this.tabsMonitoring, this.configurationManager.getConfiguration());
        }
        if (configuration.isMonitoring(WindowsMonitoring.WINDOW_EVENT_NAMESPACE)) {
            this.windowsMonitoring.initWindowsMonitoring(this, this.communication);
        }
        if (configuration.isMonitoring(IdleMonitoring.IDLE_EVENT_NAMESPACE)) {
            this.idleMonitoring.initIdleMonitoring(this, this.communication);
        }
        if (configuration.isMonitoring(DownloadsMonitoring.DOWNLOADS_EVENT_NAMESPACE)) {
            if (typeof chrome.downloads === "object") {
                this.downloadsMonitoring.initDownloadsMonitoring(this, this.communication);
            }
        }
        if (hasHtmlEventsMonitoring) {
            this.htmlEventsMonitoring.initEventsMonitoring(this.tabsMonitoring);
        }
    };
    BackgroundManager.prototype.deactivate = function () {
        if (!this.active) {
            return;
        }
        log_1.getLogger().log("Deactivating");
        this.webNavigation.unsubscribe(this.webNavigationReporter.onWebNavigation);
        this.active = false;
        // Deactivate all
        this.tabsMonitoring.uninitTabsMonitoring();
        this.webRequest.uninitWebRequest();
        this.windowsMonitoring.uninitWindowsMonitoring();
        this.idleMonitoring.uninitIdleMonitoring();
        this.htmlEventsMonitoring.uninitEventsMonitoring();
        this.downloadsMonitoring.uninitDownloadsMonitoring();
    };
    BackgroundManager.prototype.reportEverything = function () {
        this.changeConfiguration(ConfigurationData_1.REPORT_EVERYTHING_CONFIGURATION);
    };
    BackgroundManager.prototype.reportAllWpm = function () {
        this.changeConfiguration(ConfigurationData_1.REPORT_WPM_CONFIGURATION);
    };
    BackgroundManager.prototype.reportNothing = function () {
        this.deactivate();
    };
    BackgroundManager.prototype.changeConfiguration = function (configData) {
        this.deactivate();
        this.isConnectionTimeoutActive = false;
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        var configuration = new Configuration_1.Configuration(configData);
        this.activate(configuration);
        this.communication.initCommunication(this, this.webNavigation, false);
    };
    return BackgroundManager;
}());
exports.BackgroundManager = BackgroundManager;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var WebRequestEvent_1 = __webpack_require__(33);
var WebRequestState = /** @class */ (function () {
    function WebRequestState(requestStartTime) {
        /**
         * True when beforeRequestEvent member is set.
         */
        this.setBeforeRequestEvent = false;
        /**
         * True when Start event has been posted.
         */
        this.postedStart = false;
        this.totalIncomingBytes = 0;
        this.totalOutgoingBytes = 0;
        /**
         * Used to get the "server time" that is the time between sending headers and receiving the server response.
         */
        this.totalServerTime = 0;
        /**
         * Used to remember the last timestamp that we went through OnSendHeaders.
         */
        this.lastOnSendHeadersTs = 0;
        /**
         * Stored event times.
         */
        this.eventTimes = {};
        /**
         * Indicates request came with AppInternals header.
         */
        this.appInternalsMonitoring = false;
        this.requestStartTime = requestStartTime;
    }
    /**
     * Stores event time for the given event
     *
     * @param requestEvent Request event name.
     * @param eventTime Time of this event.
     */
    WebRequestState.prototype.storeEventTime = function (requestEvent, eventTime) {
        var duration = 10 * (eventTime - this.requestStartTime);
        duration = Math.floor(duration) / 10;
        var requestEventStr = WebRequestEvent_1.WebRequestEvent[requestEvent];
        if (!(requestEventStr in this.eventTimes)) {
            this.eventTimes[requestEventStr] = [];
        }
        this.eventTimes[requestEventStr].push(duration);
    };
    return WebRequestState;
}());
exports.WebRequestState = WebRequestState;
var WebRequestsStates = /** @class */ (function () {
    function WebRequestsStates() {
        this.requests = {};
    }
    WebRequestsStates.prototype.add = function (requestId, timeStamp) {
        log_1.getLogger().debug("Adding request", requestId);
        return this.requests[requestId] = new WebRequestState(timeStamp);
    };
    WebRequestsStates.prototype.get = function (requestId) {
        return this.requests[requestId];
    };
    WebRequestsStates.prototype.remove = function (requestId) {
        log_1.getLogger().debug("Removing request", requestId);
        delete this.requests[requestId];
    };
    WebRequestsStates.prototype.clear = function () {
        this.requests = {};
    };
    return WebRequestsStates;
}());
exports.WebRequestsStates = WebRequestsStates;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var FrameType_1 = __webpack_require__(11);
var MessagingModel_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
exports.WEB_NAVIGATION_EVENT_NAMESPACE = "html:chrome:WebNavigation";
function makeEventName(event) {
    return exports.WEB_NAVIGATION_EVENT_NAMESPACE + "." + event;
}
/**
 * Reports WebNavigation events to Agent.
 */
var WebNavigationReporter = /** @class */ (function () {
    function WebNavigationReporter(communication) {
        var _this = this;
        this.communication = communication;
        this.onWebNavigation = function (event, details, frameState, tabState) {
            var message = new MessagingModel_1.OutgoingEventMessage(makeEventName(event), details.timeStamp);
            var eventData = message.messageData.Data[0];
            var detailsRecord = details;
            // Copy all properties
            for (var prop in details) {
                if (details.hasOwnProperty(prop)) {
                    var propValue = detailsRecord[prop];
                    if (utils_1.isSerializablePrimitive(propValue)) {
                        eventData[prop] = propValue;
                    }
                    else {
                        // Array has special treatment
                        if (Array.isArray(propValue)) {
                            // tslint:disable-next-line no-unsafe-any
                            for (var _i = 0, propValue_1 = propValue; _i < propValue_1.length; _i++) {
                                var item = propValue_1[_i];
                                eventData[prop + "." + item] = "true";
                            }
                        }
                    }
                }
            }
            // Add urls
            if (frameState != null) {
                eventData.frameUrl = frameState.startUrl;
                eventData.frameCurrentUrl = frameState.currentUrl;
                if (frameState.committedUrl != null) {
                    eventData.frameCommittedUrl = frameState.committedUrl;
                }
                eventData.type = FrameType_1.getFrameType(frameState.frameId);
            }
            if (tabState != null) {
                eventData.documentUrl = tabState.startUrl;
                eventData.documentCurrentUrl = tabState.currentUrl;
                if (tabState.committedUrl != null) {
                    eventData.documentCommittedUrl = tabState.committedUrl;
                }
            }
            // Get type using details if was not set.
            if (event !== "CreateNavigationTarget" && eventData.type == null) {
                // ReSharper disable once SuspiciousTypeofCheck
                // tslint:disable-next-line no-any no-unnecessary-type-assertion
                var frameId = detailsRecord["frameId"];
                if (typeof frameId === "number") {
                    eventData.type = FrameType_1.getFrameType(frameId);
                }
                else {
                    log_1.getLogger().warn("Neither frameState nor details has frame identifier");
                }
            }
            _this.communication.postNativeMessage(message);
        };
    }
    return WebNavigationReporter;
}());
exports.WebNavigationReporter = WebNavigationReporter;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Consts = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var Utils = __webpack_require__(0);
var lazy_1 = __webpack_require__(5);
var MessageProcessor = /** @class */ (function () {
    function MessageProcessor(configuration) {
        this.configuration = configuration;
    }
    /*
     * @return true if event is in the event filters list and it has all required properties
     * for this event.
     */
    MessageProcessor.prototype.isEventMonitored = function (message) {
        var _this = this;
        // Validate message and event
        if (message.Data == null ||
            message.Data[0] == null ||
            !this.configuration.hasEventFilter(message.EventType)) {
            return false;
        }
        // WebRequest required properties
        if (Consts.WEBREQUEST_EVENT_RE.test(message.EventType)) {
            var data_1 = message.Data[0];
            if (!Consts.WEBREQUEST_REQUIRED_PROPERTIES.some(function (properties) { return properties.every(function (p) { return _this.isMatchEvent(message.EventType, p, data_1[p]); }); })) {
                return false;
            }
        }
        return true;
    };
    /**
     * Call isMatchEvent with check for null or undefined.
     */
    MessageProcessor.prototype.isMatchEvent = function (eventName, propertyName, input) {
        if (input == null)
            return false;
        return this.configuration.isMatchEvent(eventName, propertyName, 
        // tslint:disable-next-line no-unsafe-any
        input.toString());
    };
    /**
     * @return Whether property is not truncated.
     */
    MessageProcessor.prototype.isNonTruncated = function (name) {
        // All aternity properties are not truncated.
        return Utils.startsWith(name, "aternity");
    };
    /**
     * Convert and filter array values.
     * The string returned doesn't have the precise size of maxPropertyLength due to JSON format.
     */
    MessageProcessor.prototype.processMessageDataArray = function (eventType, name, array, options) {
        var _this = this;
        var valueStr = new lazy_1.Lazy(function () {
            var newArray = [];
            var remainingChars = _this.isNonTruncated(name)
                ? Infinity
                : _this.configuration.maxPropertyLength;
            // Go over all the elements
            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                var element = array_1[_i];
                if (!Utils.isSerializablePrimitive(element)) {
                    log_1.getLogger().error("Unsupported type in array", element);
                    continue;
                }
                // ReSharper disable once TsResolvedFromInaccessibleModule
                var objAtElement = element.toString();
                var objAtElementLength = objAtElement.length;
                newArray.push(objAtElement.substr(0, remainingChars));
                // Add 3 more characters, it is the average length for each element: ",".
                remainingChars -= objAtElementLength + 3;
                // If no chars remaining, break
                if (remainingChars <= 0) {
                    break;
                }
            }
            return JSON.stringify(newArray);
        });
        // Test property
        return options.forcePost || this.configuration.isMatchEvent(eventType, name, valueStr) ?
            valueStr.getValue() :
            undefined;
    };
    MessageProcessor.prototype.processMessageDataValue = function (eventType, name, value, options) {
        var _this = this;
        if (!Utils.isSerializablePrimitive(value)) {
            return undefined;
        }
        // Convert
        var valueStr = new lazy_1.Lazy(function () {
            var result = value.toString();
            // Do not truncate aternity properties.
            if (!_this.isNonTruncated(name)) {
                result = result.substr(0, _this.configuration.maxPropertyLength);
            }
            return result;
        });
        // Test property
        return options.forcePost || this.configuration.isMatchEvent(eventType, name, valueStr) ?
            valueStr.getValue() :
            undefined;
    };
    /**
     * Converts a property to string representation.
     * @return Converted property or undefined if it doesn't match filters.
     */
    MessageProcessor.prototype.processMessageDataProperty = function (eventType, name, value, options) {
        if (Array.isArray(value)) {
            return this.processMessageDataArray(eventType, name, value, options);
        }
        else {
            return this.processMessageDataValue(eventType, name, value, options);
        }
    };
    MessageProcessor.prototype.processMessageDataObject = function (eventType, data, options) {
        var _this = this;
        if (options === void 0) { options = MessageProcessor.DEFAULT_POST_NATIVE_MESSAGE_OPTIONS; }
        Utils.rewriteObject(data, function (n, v) { return _this.processMessageDataProperty(eventType, n, v, options); }, false);
    };
    /**
     * Converts every property to string representation and removes unmatched ones.
     * If the property matches, then it is trimmed to Configuration.maxPropertyLength.
     */
    MessageProcessor.prototype.processMessageData = function (messageData, options) {
        if (options === void 0) { options = MessageProcessor.DEFAULT_POST_NATIVE_MESSAGE_OPTIONS; }
        for (var _i = 0, _a = messageData.Data; _i < _a.length; _i++) {
            var data = _a[_i];
            this.processMessageDataObject(messageData.EventType, data, options);
        }
    };
    MessageProcessor.DEFAULT_POST_NATIVE_MESSAGE_OPTIONS = {
        forcePost: false
    };
    return MessageProcessor;
}());
exports.MessageProcessor = MessageProcessor;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var TabsState_1 = __webpack_require__(65);
var FrameType_1 = __webpack_require__(11);
var webNavigation = chrome.webNavigation;
var WEBNAVIGATION_URL_FILTER = {
    url: [{ schemes: ["http", "https"] }]
};
var WebNavigation = /** @class */ (function () {
    function WebNavigation() {
        var _this = this;
        this.webNavigationTabsStates = new TabsState_1.TabsStates();
        this.reportCallbacks = new Set();
        // #endregion
        // #region Handlers
        this.onCreatedNavigationTarget = function (details) {
            log_1.getLogger().debug("WebNavigation.onCreatedNavigationTarget", details);
            _this.reportCallbacks.forEach(function (reportCallback) { return reportCallback("CreateNavigationTarget", details); });
        };
        this.onBeforeNavigate = function (details) {
            log_1.getLogger().debug("WebNavigation.onBeforeNavigate", details);
            // Get frame state
            var frameState = _this.webNavigationTabsStates.getFrame(details);
            // No frame state -> Create a new one
            if (frameState == null) {
                frameState = _this.addFrame(details);
                // Remove instant tabs
                setTimeout(function () { return _this.webNavigationTabsStates.validateTab(details.tabId); }, 60 * 1000);
            }
            else {
                // Remove and add a new one
                _this.webNavigationTabsStates.removeFrame(details.tabId, details.frameId);
                frameState = _this.addFrame(details);
            }
            // Initial values when starting navigation - these will be updated along the way
            frameState.currentUrl = details.url;
            _this.reportEvent("BeforeNavigate", details);
        };
        this.onCommitted = function (details) {
            log_1.getLogger().debug("onCommitted", details);
            var frameState = _this.webNavigationTabsStates.getFrame(details);
            if (frameState != null) {
                // Update current url
                frameState.currentUrl = details.url;
                // The URL to which the given frame will navigate.
                frameState.committedUrl = details.url;
            }
            else {
                log_1.getLogger().error("Frame state is null for tab: ", details.tabId, "frame: ", details.frameId);
            }
            _this.reportEvent("Committed", details);
        };
        // ReSharper disable once InconsistentNaming
        this.onDOMContentLoaded = function (details) {
            _this.reportEvent("DOMContentLoaded", details);
        };
        this.onCompleted = function (details) {
            _this.reportEvent("Completed", details);
        };
        this.onErrorOccurred = function (details) {
            _this.reportEvent("ErrorOccurred", details);
        };
        this.onLocationChanged = function (details) {
            log_1.getLogger().debug("WebNavigation.onLocationChanged", details);
            var currentFrame = _this.webNavigationTabsStates.getFrame(details);
            if (currentFrame == null) {
                log_1.getLogger().error("Frame does not exist in tab states");
                return;
            }
            currentFrame.currentUrl = details.url;
        };
        this.onRemoved = function (tabId) {
            _this.webNavigationTabsStates.removeTab(tabId);
        };
        // Monitor removed tabs for instance navigations.
        chrome.tabs.onRemoved.addListener(this.onRemoved);
        webNavigation.onCreatedNavigationTarget.addListener(this.onCreatedNavigationTarget, WEBNAVIGATION_URL_FILTER);
        webNavigation.onBeforeNavigate.addListener(this.onBeforeNavigate, WEBNAVIGATION_URL_FILTER);
        webNavigation.onCommitted.addListener(this.onCommitted, WEBNAVIGATION_URL_FILTER);
        webNavigation.onDOMContentLoaded.addListener(this.onDOMContentLoaded, WEBNAVIGATION_URL_FILTER);
        webNavigation.onCompleted.addListener(this.onCompleted, WEBNAVIGATION_URL_FILTER);
        webNavigation.onErrorOccurred.addListener(this.onErrorOccurred, WEBNAVIGATION_URL_FILTER);
        webNavigation.onHistoryStateUpdated.addListener(this.onLocationChanged, WEBNAVIGATION_URL_FILTER);
        webNavigation.onReferenceFragmentUpdated.addListener(this.onLocationChanged, WEBNAVIGATION_URL_FILTER);
        this.webNavigationTabsStates.validateAllTabs();
    }
    /**
     * Subscribe to events.
     * Only one subscription is supported.
     * If was subscribed before, new subscription doesn't replace old.
     *
     * @param callback Callback to receive all WebNavigation events.
     */
    WebNavigation.prototype.subscribe = function (callback) {
        if (!this.reportCallbacks.has(callback)) {
            this.reportCallbacks.add(callback);
        }
    };
    /**
     * Remove last subscription if any.
     */
    WebNavigation.prototype.unsubscribe = function (callback) {
        if (this.reportCallbacks.has(callback)) {
            this.reportCallbacks.delete(callback);
        }
    };
    WebNavigation.prototype.getFrame = function (tabId, frameId) {
        return this.webNavigationTabsStates.getFrame({ tabId: tabId, frameId: frameId });
    };
    // #region Utility functions
    WebNavigation.prototype.addFrame = function (details) {
        return this.webNavigationTabsStates.addFrame(details.tabId, details.frameId, details.url, FrameType_1.getFrameType(details.frameId), "");
    };
    WebNavigation.prototype.reportEvent = function (event, details) {
        log_1.getLogger().debug("WebNavigation.on" + event, details);
        var frameState = this.webNavigationTabsStates.getFrame(details);
        var tabState = this.webNavigationTabsStates.getTab(details.tabId);
        this.reportCallbacks.forEach(function (reportCallback) { return reportCallback(event, details, frameState, tabState); });
    };
    return WebNavigation;
}());
exports.WebNavigation = WebNavigation;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var utils_1 = __webpack_require__(0);
// import { chrome } from "../common/globalChrome";
function makeHash(tabId, frameId) {
    return tabId.toString() + "," + frameId.toString();
}
function tabIdFromHash(hash) {
    var commaIdx = hash.indexOf(",");
    var tabIdStr = hash.substring(0, commaIdx);
    return Number(tabIdStr);
}
function getFrameUrl() {
    return window.location.href;
}
/**
 * Main frame or sub frame state.
 */
var FrameState = /** @class */ (function () {
    function FrameState(frameId, tabId, url, type, requestId) {
        this.frameId = frameId;
        this.tabId = tabId;
        this.startUrl = url;
        this.currentUrl = url;
        this.type = type;
        this.requestId = requestId;
    }
    return FrameState;
}());
exports.FrameState = FrameState;
var TabsStates = /** @class */ (function () {
    function TabsStates() {
        this.frames = {};
    }
    TabsStates.prototype.addFrame = function (tabId, frameId, url, type, requestId) {
        var hash = makeHash(tabId, frameId);
        this.frames[hash] = new FrameState(frameId, tabId, url, type, requestId);
        var frame = this.frames[hash];
        return frame;
    };
    TabsStates.prototype.getTab = function (tabId) {
        return this.getFrame({ tabId: tabId, frameId: 0 });
    };
    TabsStates.prototype.getFrame = function (_a) {
        var _this = this;
        var tabId = _a.tabId, frameId = _a.frameId, _b = _a.url, url = _b === void 0 ? "" : _b;
        var frame = this.frames[makeHash(tabId, frameId)];
        if (frame == null) {
            // This can be a valid state: the extension is loaded in parallel with the pages,
            // and sometimes (in particular when url is given on the command line) it
            // finishes loading after some frames and this.frames[] is incomplete.
            // We add the missing frame lazily, here.
            if (url != null && url !== "") { // use the input details
                frame = this.addFrame(tabId, frameId, url, "unknown", "");
            }
            else {
                chrome.scripting.executeScript({
                    target: { tabId: tabId, allFrames: false, frameIds: [frameId] },
                    func: getFrameUrl
                }, function (results) {
                    if (chrome.runtime.lastError !== undefined) {
                        // There are valid scenarios where getFrame is called for a closed tab.
                        // for example when an ajax is cancelled during tab closing:
                        // WebRequest.onErrorOccured -> isMonitored -> tabStates.getTab -> getFrame
                        // We try to log only errors from unexpected scenarios.
                        if (chrome.runtime.lastError.message === "The frame was removed." ||
                            // tslint:disable-next-line:no-non-null-assertion
                            utils_1.startsWith(chrome.runtime.lastError.message, "No frame with id") ||
                            // tslint:disable-next-line:no-non-null-assertion
                            utils_1.startsWith(chrome.runtime.lastError.message, "No tab with id")) {
                            return; // frame null will be returned
                        }
                        else {
                            log_1.getLogger().error("chrome.tabs.executeScript failed in tabId", tabId, chrome.runtime.lastError.message);
                        }
                    }
                    else if (results != null) {
                        _this.addFrame(tabId, frameId, results[0].result, "unknown", "");
                    }
                    else {
                        log_1.getLogger().error("chrome.scripting.executeScript returned empty");
                    }
                });
            }
        }
        return frame;
    };
    TabsStates.prototype.getAllTabIds = function () {
        var tabIDs = [];
        chrome.tabs.query({}, function (resTabs) {
            if (chrome.runtime.lastError != null) {
                log_1.getLogger().error("chrome.runtime.lastError: " + chrome.runtime.lastError.message);
                return;
            }
            // tslint:disable-next-line:no-non-null-assertion
            tabIDs = resTabs.filter(function (tab) { return tab.id !== null; }).map(function (tab) { return tab.id; });
        });
        return tabIDs;
    };
    TabsStates.prototype.removeDeadFrames = function () {
        var _this = this;
        var liveTabIds = this.getAllTabIds();
        // Iterate on all frames and remove those in dead tabId's
        Object.keys(this.frames).forEach(function (hash) {
            var frame = _this.frames[hash];
            if (liveTabIds.indexOf(frame.tabId) === -1) {
                delete _this.frames[hash];
            }
        });
    };
    TabsStates.prototype.getFramesByWindowUrl = function (windowUrl) {
        var frames = [];
        for (var key in this.frames) {
            var frameState = this.frames[key];
            if (frameState.committedUrl === windowUrl) {
                frames.push(frameState);
            }
        }
        return frames;
    };
    TabsStates.prototype.removeTab = function (tabId) {
        var _this = this;
        // Iterate on all frames and remove those with the given tabId
        Object.keys(this.frames).forEach(function (hash) {
            var frame = _this.frames[hash];
            if (frame.tabId === tabId) {
                delete _this.frames[hash];
            }
        });
    };
    TabsStates.prototype.removeFrame = function (tabId, frameId) {
        if (frameId === 0) {
            // Remove the entire tab
            this.removeTab(tabId);
            return;
        }
        var removeHash = makeHash(tabId, frameId);
        // Remove the frame
        delete this.frames[removeHash];
    };
    TabsStates.prototype.hasTab = function (tabId) {
        return this.hasFrame(tabId, 0);
    };
    TabsStates.prototype.hasFrame = function (tabId, frameId) {
        return makeHash(tabId, frameId) in this.frames;
    };
    /**
     * Clear the state.
     */
    TabsStates.prototype.clear = function () {
        this.frames = {};
    };
    TabsStates.prototype.validateTab = function (tabId) {
        var _this = this;
        chrome.tabs.get(tabId, function (tab) {
            // If tab doesn't exist we have an error.
            // It means that this tab is not real and used for instant search.
            if (chrome.runtime.lastError != null) {
                _this.removeTab(tabId);
            }
        });
    };
    TabsStates.prototype.validateAllTabs = function () {
        for (var hash in this.frames) {
            var tabId = tabIdFromHash(hash);
            this.validateTab(tabId);
        }
    };
    return TabsStates;
}());
exports.TabsStates = TabsStates;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var tabs_1 = __webpack_require__(36);
var timeProvider_1 = __webpack_require__(3);
var Utils = __webpack_require__(0);
var MessagingModel_1 = __webpack_require__(2);
var TabsMonitoring = /** @class */ (function () {
    function TabsMonitoring() {
        var _this = this;
        this.globalTabsStates = {};
        // #endregion
        // #region Handlers
        this.onCreated = function (tab) {
            var timestamp = timeProvider_1.timeProvider.now();
            _this.onCreatedImpl(tab, timestamp);
        };
        this.onUpdated = function (tabId, changeInfo, tab) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().log("Tab onUpdated", tabId, changeInfo, tab);
            if (tab.id == null) {
                log_1.getLogger().error("No tab.id for " + tab);
                return;
            }
            // Update title in content script
            if (typeof tab.title === "string") {
                _this.updateDocumentTitleInFrames(tab);
            }
            // Fetch the Tab State object asynchronously, create it if needed.
            _this.getOrCreateTabStateAsync(tabId)
                .then(function (tabState) {
                if (tabState == null) {
                    return;
                }
                if (typeof changeInfo.title !== "undefined") {
                    log_1.getLogger().log("Tab onUpdated previous title: " + tabState.title + ", new title: " + changeInfo.title);
                    tabState.title = changeInfo.title;
                    // Set initial documentTitle as title.
                    // It will be updated later in the updateDocumentTitleInFrames
                    tabState.documentTitle = changeInfo.title;
                }
                if (changeInfo.url != null) {
                    tabState.currentUrl = changeInfo.url;
                }
                if (changeInfo.status != null) {
                    // If we got here following a refresh there's an excellent chance the content script
                    // hadn't finished processing the config yet and TitleManager isn't available.
                    // It suffices to delay the message passing a bit. If some day it doesn't - add some
                    // 'CONTENT_READY' message, and do this only afterwards.
                    if (changeInfo.status === "complete") {
                        setTimeout(function () { return _this.updateDocumentTitleInFrames(tab); }, 0);
                    }
                }
                var message = _this.createDataMessage("Updated", tabId);
                if (_this.communication != null) {
                    _this.communication.postNativeMessage(message);
                }
            })
                .catch(function (err) {
                log_1.getLogger().error("Error while getting Tab State object on Tab Update.", tabId, err);
            });
        };
        this.onRemoved = function (tabId, removeInfo) {
            _this.onRemovedImpl(tabId, removeInfo, timeProvider_1.timeProvider.now());
        };
        this.onReplaced = function (addedTabId, removedTabId) {
            var timestamp = timeProvider_1.timeProvider.now();
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().log("Tab onReplaced", addedTabId, removedTabId);
            // Replaced is like remove and then create so we need to insert the new data and report
            // And these must be reported in this order (remove -> create -> replace) because the
            // meaning of replace is that there was a remove and then a create
            chrome.tabs.get(addedTabId, function (addedTab) {
                // This is the body of the callback that will be called when the Tab accordant to the
                // addedTabId is retrieved.
                var addedTabObjectFetched = chrome.runtime.lastError == null;
                // Fetch the removed Tab State object asynchronously, create it if needed.
                _this.getOrCreateTabStateAsync(removedTabId)
                    .then(function (tabState) {
                    // This is the body of the resolve of the Promise that retrieves the Tab State
                    // object accordant to the removed Tab ID.
                    var replacedMessage;
                    if (addedTabObjectFetched && tabState != null) {
                        replacedMessage = _this.createDataMessage("Replaced", removedTabId, timestamp);
                        var messageData = replacedMessage.messageData.Data[0];
                        messageData.newTabId = addedTabId;
                    }
                    // Must first report removed, then created and only after both - replaced.
                    // Removed must be reported anyway - regardless of whether the new tabId exists or not.
                    _this.onRemovedImpl(removedTabId, {
                        windowId: addedTab.windowId,
                        isWindowClosing: false // Because the window isn't closing when it's replace.
                    }, timestamp);
                    if (addedTabObjectFetched) {
                        _this.onCreatedImpl(addedTab, timestamp);
                    }
                    // ReSharper disable once ConditionIsAlwaysConst
                    if (replacedMessage != null) {
                        if (_this.communication != null) {
                            _this.communication.postNativeMessage(replacedMessage);
                        }
                    }
                })
                    .catch(function (err) {
                    log_1.getLogger().error("Error while getting removed Tab State object on Tab Replace.", removedTabId, err);
                });
            });
        };
        this.onActivated = function (activeInfo) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().log("Tab onActivated", activeInfo);
            // Fetch the Tab State object asynchronously, create it if needed.
            _this.getOrCreateTabStateAsync(activeInfo.tabId)
                .then(function (tabState) {
                if (tabState != null) {
                    var message = _this.createDataMessage("Activated", activeInfo.tabId);
                    if (_this.communication != null) {
                        _this.communication.postNativeMessage(message);
                    }
                    // fixing WAC bug with focus
                    chrome.tabs.get(activeInfo.tabId, function (tab) {
                        tabs_1.executeFunctionInTab(tab, function () { window.focus(); }, "focus");
                    });
                }
            })
                .catch(function (err) {
                log_1.getLogger().error("Error while getting Tab State object on Tab Activation.", activeInfo.tabId, err);
            });
        };
        this.onMoved = function (tabId, moveInfo) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().log("Tab onMoved", moveInfo);
            // Fetch the Tab State object asynchronously, create it if needed.
            _this.getOrCreateTabStateAsync(tabId)
                .then(function (tabState) {
                if (tabState != null) {
                    var message = _this.createDataMessage("Moved", tabId);
                    if (_this.communication != null) {
                        _this.communication.postNativeMessage(message);
                    }
                }
            })
                .catch(function (err) {
                log_1.getLogger().error("Error while getting Tab State object on Tab Move.", tabId, err);
            });
        };
        this.onAttached = function (tabId, attachInfo) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().log("Tab onAttached", attachInfo);
            // Fetch the Tab State object asynchronously, create it if needed.
            _this.getOrCreateTabStateAsync(tabId)
                .then(function (tabState) {
                if (tabState != null) {
                    var message = _this.createDataMessage("Attached", tabId);
                    if (_this.communication != null) {
                        _this.communication.postNativeMessage(message);
                    }
                }
            })
                .catch(function (err) {
                log_1.getLogger().error("Error while getting Tab State object on Tab Attach.", tabId, err);
            });
        };
        this.onDetached = function (tabId, detachInfo) {
            if (_this.manager == null || !_this.manager.active) {
                return;
            }
            log_1.getLogger().log("Tab onDetached", detachInfo);
            // Fetch the Tab State object asynchronously, create it if needed.
            _this.getOrCreateTabStateAsync(tabId)
                .then(function (tabState) {
                if (tabState != null) {
                    var message = _this.createDataMessage("Detached", tabId);
                    if (_this.communication != null) {
                        _this.communication.postNativeMessage(message);
                    }
                }
            })
                .catch(function (err) {
                log_1.getLogger().error("Error while getting Tab State object on Tab Detach.", tabId, err);
            });
        };
        this.findNameChanged = function (tab) {
            if (tab.id == null) {
                return;
            }
            var tabState = _this.globalTabsStates[tab.id];
            if (tabState != null && tabState.title !== tab.title) {
                if (typeof tab.title !== "undefined") {
                    tabState.title = tab.title;
                }
                log_1.getLogger().log("Interval found a titleChange", tabState);
                var message = _this.createDataMessage("TitleChange", tab.id);
                if (_this.communication != null) {
                    _this.communication.postNativeMessage(message);
                }
            }
        };
        this.tabMonitoringEnabled = false;
    }
    // #region Utility
    TabsMonitoring.prototype.makeEventName = function (event) {
        return TabsMonitoring.TAB_EVENT_NAMESPACE + "." + event;
    };
    /**
     * Create base tab message.
     */
    TabsMonitoring.prototype.createDataMessage = function (event, tabId, timestamp) {
        if (timestamp === void 0) { timestamp = timeProvider_1.timeProvider.now(); }
        var message = new MessagingModel_1.OutgoingEventMessage(this.makeEventName(event), timestamp);
        var tabState = this.globalTabsStates[tabId];
        var messageData = message.messageData.Data[0];
        messageData.tabId = tabId;
        messageData.title = tabState.title;
        if (tabState.status != null) {
            messageData.status = tabState.status;
        }
        if (tabState.currentUrl != null) {
            messageData.currentUrl = tabState.currentUrl;
        }
        return message;
    };
    TabsMonitoring.prototype.addTab = function (tab) {
        var tabId = tab.id;
        if (tabId == null) {
            return;
        }
        var title = tab.title != null ? tab.title : "";
        this.globalTabsStates[tabId] = {
            currentUrl: tab.url,
            tabId: tabId,
            windowId: tab.windowId,
            title: title,
            documentTitle: title
        };
        if (tab.status != null) {
            this.globalTabsStates[tabId].status = tab.status;
        }
    };
    TabsMonitoring.prototype.addTabIfDoesntExists = function (tabId, tab) {
        if (this.globalTabsStates[tabId] == null) {
            log_1.getLogger().log("Adding tab: ", tab);
            this.addTab(tab);
        }
    };
    // #endregion
    // #region Exported privates
    /**
     * @param tabId Tab identifier
     * @return Tab state.
     */
    TabsMonitoring.prototype.getTabState = function (tabId) {
        var tabState = this.globalTabsStates[tabId];
        if (tabState != null) {
            return __assign({}, tabState);
        }
        else {
            return null;
        }
    };
    /**
     * Get a Tab State object accordant to some Tab ID.
     * @param tabId The ID of the Tab whose Tab State object is to be fetched or created.
     * @param browserTab Optional Browser Tab object, used in the creation of the requested Tab State object.
     * @return Promise to deliver a Tab State object or a null, if such object does not exist and should not be created.
     */
    TabsMonitoring.prototype.getOrCreateTabStateAsync = function (tabId, browserTab) {
        var _this = this;
        if (browserTab === void 0) { browserTab = null; }
        var tabDataPromise = new Promise(function (resolve, reject) {
            // This is the body of the output Promise.
            var tabState = _this.globalTabsStates[tabId];
            if (tabState != null) {
                // Tab State object with the requested ID already exists.
                // Resolve the Promise with the existing Tab State.
                resolve(tabState);
            }
            else {
                // Tab State object with the requested ID does not exist.
                // As there is no Tab State object accordant to the requested Tab ID, resolve the output Promise with null.
                resolve(null);
            }
        });
        return tabDataPromise;
    };
    /**
     * Get a browser Tab object accordant to some Tab ID.
     * @param tabId The ID of the Tab whose browser Tab object is to be fetched or created.
     * @return Promise to deliver a browser Tab object.
     */
    TabsMonitoring.prototype.getTab = function (tabId) {
        var browserTabPromise = new Promise(function (resolve, reject) {
            // This is the body of the Promise.
            try {
                chrome.tabs.get(tabId, function (browserTab) {
                    // This is the body of the callback supplied to 'chrome.tabs.get'.
                    if (chrome.runtime.lastError == null) {
                        // The browser Tab object accordant to the requested Tab ID had been found.
                        // Resolve the Promise with that Tab object.
                        resolve(browserTab);
                    }
                    else {
                        // There is no browser Tab with the requested Tab ID.
                        // Reject the Promise.
                        log_1.getLogger().error("No Browser Tab object for Tab ID.", tabId, chrome.runtime.lastError);
                        reject(chrome.runtime.lastError);
                    }
                });
            }
            catch (err) {
                // Exception occured in the call to 'chrome.tabs.get'.
                // Reject the Promise.
                log_1.getLogger().error("Exception while getting Browser Tab object.", tabId, err);
                reject(err);
            }
        });
        return browserTabPromise;
    };
    TabsMonitoring.prototype.onCreatedImpl = function (tab, timestamp) {
        if (this.manager == null || !this.manager.active) {
            return;
        }
        log_1.getLogger().log("Tab onCreated", tab.id, tab);
        if (tab.id == null) {
            log_1.getLogger().error("No tab.id for " + tab);
            return;
        }
        delete this.globalTabsStates[tab.id];
        this.addTab(tab);
        var message = this.createDataMessage("Created", tab.id, timestamp);
        if (this.communication != null) {
            this.communication.postNativeMessage(message);
        }
    };
    TabsMonitoring.prototype.onRemovedImpl = function (tabId, removeInfo, timestamp) {
        var _this = this;
        if (this.manager == null || !this.manager.active) {
            return;
        }
        log_1.getLogger().log("Tab onRemoved", tabId, removeInfo);
        // Fetch the Tab State object asynchronously, create it if needed.
        this.getOrCreateTabStateAsync(tabId)
            .then(function (tabState) {
            if (tabState != null) {
                var message = _this.createDataMessage("Removed", tabId, timestamp);
                var messageData = message.messageData.Data[0];
                messageData.isWindowClosing = removeInfo.isWindowClosing;
                if (_this.communication != null) {
                    _this.communication.postNativeMessage(message);
                }
                delete _this.globalTabsStates[tabId];
            }
        })
            .catch(function (err) {
            log_1.getLogger().error("Error while getting Tab State object on Tab Remove.", tabId, err);
        });
    };
    // #endregion
    /**
     * Ask document.title property from top frame and publish it to other frames in the tab.
     * This way we are bypassing the cross-site domain issue.
     */
    TabsMonitoring.prototype.updateDocumentTitleInFrames = function (tab) {
        if (tab.id == null || tab.title == null || tab.url == null) {
            return;
        }
        if (!Utils.startsWith(tab.url, "http")) {
            return;
        }
        var documentTitle;
        // Ask documentTitle from top frame (frameId = 0) and then publish it to all frames in tab.
        var documentTitleRequest = {
            messageType: MessagingModel_1.ChromeContentMessageType.DOCUMENT_TITLE_REQUEST
        };
        log_1.getLogger().log("Requesting document title from tab id: " + tab.id + ", url: " + tab.url);
        tabs_1.sendMessageToTab(tab, 0, // Request only top frame
        documentTitleRequest, function (response) {
            var documentTitleResponse = response;
            if (typeof response === "undefined") {
                log_1.getLogger().warn("Bad response", response);
                return;
            }
            log_1.getLogger().log("Requesting document title from tab id: " + tab.id + ", url: " + tab.url);
            // ReSharper disable once SuspiciousTypeofCheck
            if (documentTitleResponse === null ||
                documentTitleResponse.messageType !== MessagingModel_1.ChromeContentMessageType.DOCUMENT_TITLE_RESPONSE ||
                typeof documentTitleResponse.documentTitle !== "string") {
                log_1.getLogger().warn("Bad documentTitleResponse", response);
                if (tab.title !== undefined) {
                    documentTitle = tab.title;
                }
            }
            else { // documentTitleResponse is valid
                documentTitle = documentTitleResponse.documentTitle;
            }
            if (documentTitle === undefined) {
                return;
            }
            // Send title update to all frames
            var documentTitleUpdate = {
                messageType: MessagingModel_1.ChromeContentMessageType.DOCUMENT_TITLE_UPDATE,
                documentTitle: documentTitle
            };
            tabs_1.sendMessageToTab(tab, undefined, documentTitleUpdate);
        }, function (lastError) {
            log_1.getLogger().warn("Couldn't request document.title from tab id: " + tab.id + ", url: " + tab.url, lastError);
        });
    };
    TabsMonitoring.prototype.forAllTabs = function (func) {
        chrome.tabs.query({}, function (tabs) { return tabs.forEach(func); });
    };
    TabsMonitoring.prototype.initTabsMonitoring = function (manager, communication) {
        var _this = this;
        this.manager = manager;
        this.communication = communication;
        if (this.tabMonitoringEnabled) {
            log_1.getLogger().error("You can't init tab monitoring twice in a row (without uninit)");
            return;
        }
        this.tabMonitoringEnabled = true;
        chrome.tabs.onCreated.addListener(this.onCreated);
        chrome.tabs.onUpdated.addListener(this.onUpdated);
        chrome.tabs.onRemoved.addListener(this.onRemoved);
        if (chrome.tabs.onReplaced != null) {
            chrome.tabs.onReplaced.addListener(this.onReplaced);
        }
        chrome.tabs.onActivated.addListener(this.onActivated);
        if (chrome.tabs.onMoved != null) {
            chrome.tabs.onMoved.addListener(this.onMoved);
        }
        chrome.tabs.onAttached.addListener(this.onAttached);
        chrome.tabs.onDetached.addListener(this.onDetached);
        this.updateTabInterval = setInterval(function () { return _this.forAllTabs(_this.findNameChanged); }, 1000);
        // Query existing tabs
        this.forAllTabs(function (tab) {
            if (tab.id == null)
                return;
            _this.addTabIfDoesntExists(tab.id, tab);
            var message = _this.createDataMessage("Discovered", tab.id);
            if (_this.communication != null) {
                _this.communication.postNativeMessage(message);
            }
        });
    };
    TabsMonitoring.prototype.uninitTabsMonitoring = function () {
        this.tabMonitoringEnabled = false;
        this.globalTabsStates = {};
        if (this.updateTabInterval !== undefined) {
            clearInterval(this.updateTabInterval);
            this.updateTabInterval = undefined;
        }
        chrome.tabs.onCreated.removeListener(this.onCreated);
        chrome.tabs.onUpdated.removeListener(this.onUpdated);
        chrome.tabs.onRemoved.removeListener(this.onRemoved);
        if (chrome.tabs.onReplaced != null) {
            chrome.tabs.onReplaced.removeListener(this.onReplaced);
        }
        chrome.tabs.onActivated.removeListener(this.onActivated);
        if (chrome.tabs.onMoved != null) {
            chrome.tabs.onMoved.removeListener(this.onMoved);
        }
        chrome.tabs.onAttached.removeListener(this.onAttached);
        chrome.tabs.onDetached.removeListener(this.onDetached);
        this.manager = undefined;
        this.communication = undefined;
    };
    TabsMonitoring.TAB_EVENT_NAMESPACE = "ui:chrome:Tab";
    return TabsMonitoring;
}());
exports.TabsMonitoring = TabsMonitoring;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tabs_1 = __webpack_require__(36);
var MessagingModel_1 = __webpack_require__(2);
function sendAllTabsMessage(tabsMonitoring, message) {
    tabsMonitoring.forAllTabs(function (tab) { return tabs_1.sendMessageToTabWithLog(tab, message); });
}
/**
 * Monitor HTML events in content script.
 */
var HtmlEventsMonitoring = /** @class */ (function () {
    function HtmlEventsMonitoring() {
    }
    HtmlEventsMonitoring.prototype.initEventsMonitoring = function (tabsMonitoring) {
        this.tabsMonitoring = tabsMonitoring;
        sendAllTabsMessage(tabsMonitoring, MessagingModel_1.ContentMessageType.RECONFIGURE);
    };
    HtmlEventsMonitoring.prototype.uninitEventsMonitoring = function () {
        if (this.tabsMonitoring != null) {
            sendAllTabsMessage(this.tabsMonitoring, MessagingModel_1.ContentMessageType.UNINITIALIZE);
        }
    };
    return HtmlEventsMonitoring;
}());
exports.HtmlEventsMonitoring = HtmlEventsMonitoring;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var WacAPI_1 = __webpack_require__(69);
var browserInfo_1 = __webpack_require__(8);
var MessagingModel_1 = __webpack_require__(2);
/**
 * Default response with all features.
 */
var GREETING_RESPONSE = {
    messageType: "GreetingResponse",
    features: ["HTMLEvents", "Visibility"]
};
var FAREWELL_RESPONSE = {
    messageType: "FarewellResponse",
};
var NOT_ACTIVE_RESPONSE = {
    messageType: "NotActiveResponse"
};
var WAC_EXTENSION_IDS = [
    "poffncjphkchclemkfpadkjfgkbfkafp",
    "cdnnpklbhipmnknojapkdiocjgmplpcc",
    "nckjcpchnnejhldedgelopkoemdhdbbf"
];
var SUPPORTS_CHROME_MANAGEMENT = chrome.management != null;
/**
 * Communication between Agent extension and WAC
 */
var WacCommunication = /** @class */ (function () {
    function WacCommunication() {
        var _this = this;
        this.active = false;
        this.onInjectedMessage = function (_a, messageSender) {
            var messageType = _a.messageType, message = _a.message;
            if (messageType !== "MessageFromInjected" || message == null) {
                return;
            }
            if (messageSender.tab == null || messageSender.tab.id == null || messageSender.frameId == null) {
                return;
            }
            var sender = {
                browser: browserInfo_1.browserInfo.name,
                tabId: messageSender.tab.id,
                frameId: messageSender.frameId
            };
            _this.sendMessageToWac({ messageType: messageType, message: message, sender: sender });
        };
        this.onTabRemoved = function (tabId) {
            _this.sendMessageToWac({ messageType: "TabRemoved", removed: { browser: browserInfo_1.browserInfo.name, tabId: tabId } });
        };
        this.onMessageExternal = function (message, sender) { return __awaiter(_this, void 0, void 0, function () {
            var _a, browser, tabId;
            return __generator(this, function (_b) {
                log_1.getLogger().log("Got message", message, sender);
                // Reply with error when manager is not active
                if (!this.active) {
                    log_1.getLogger().log("Extension is not ready");
                    return [2 /*return*/];
                }
                if (sender.id == null) {
                    return [2 /*return*/];
                }
                if (!WacAPI_1.isExtensionMessage(message))
                    return [2 /*return*/];
                switch (message.messageType) {
                    case "GreetingRequest":
                        if (!WacAPI_1.validateGreetingRequest(message))
                            return [2 /*return*/];
                        this.handleGreeting(sender.id, message);
                        break;
                    case "FarewellRequest":
                        if (!WacAPI_1.validateFarewellRequest(message))
                            return [2 /*return*/];
                        this.handleFarewell(sender.id);
                        break;
                    case "MessageToInjected":
                        log_1.getLogger().log("Sending exec script response");
                        if (message.recipient.browser === "InternetExplorer" /* IE */) {
                            this.sendToIE(message);
                        }
                        break;
                    case "InjectNotificationsFrame":
                        _a = message.recipient, browser = _a.browser, tabId = _a.tabId;
                        if (!(this.isBrowserChromiumBased(browser) && tabId != null)) {
                            this.sendToIE({
                                messageType: "InjectNotificationsFrame",
                                recipient: message.recipient
                            });
                        }
                        break;
                    case "ConfigurationUpdate":
                        log_1.getLogger().log("ConfigurationUpdate received");
                        if (!WacAPI_1.validateConfigurationUpdate(message))
                            return [2 /*return*/];
                        if (this.configurationManager != null) {
                            this.configurationManager.setWacConfiguration(message.eventConditions);
                            this.handleConfigurationUpdate(message);
                        }
                        break;
                }
                return [2 /*return*/];
            });
        }); };
        this.onDisabledListener = function (disabledExtInfo) {
            if (disabledExtInfo.id === _this.wacExtensionId) {
                _this.handleFarewell(disabledExtInfo.id);
            }
        };
        this.onWebNavigation = function (event, details, frameState, tabState) {
            if (tabState == null || frameState == null) {
                return;
            }
            if (!_this.isNavigationFinished(tabState.statusCode)) {
                return;
            }
            if (_this.wacExtensionId == null) {
                return;
            }
            if (event !== "Completed" || frameState.committedUrl == null) {
                return;
            }
            if (_this.tabsMonitoring == null) {
                return;
            }
            var tabId = tabState.tabId;
            var frameId = frameState.frameId;
            var frameCurrentUrl = frameState.currentUrl;
            var frameUrl = frameState.startUrl;
            var frameCommittedUrl = frameState.committedUrl;
            var tabMonitoringState = _this.tabsMonitoring.getTabState(tabId);
            if (tabMonitoringState == null) {
                throw new Error("No tab state in tabId " + tabId);
            }
            _this.sendMessageToWac({
                messageType: "ContentInjected",
                frameInfo: {
                    title: tabMonitoringState.title,
                    browser: browserInfo_1.browserInfo.name,
                    frameId: frameId,
                    tabId: tabId,
                    frameCurrentUrl: frameCurrentUrl,
                    frameUrl: frameUrl,
                    frameCommittedUrl: frameCommittedUrl
                }
            });
        };
    }
    WacCommunication.prototype.activate = function (nativeMessageSender, tabsMonitoring, configManager) {
        log_1.getLogger().trace("activate WacCommunication");
        if (this.active || !SUPPORTS_CHROME_MANAGEMENT) {
            return;
        }
        this.active = true;
        this.nativeMessagePoster = nativeMessageSender;
        this.tabsMonitoring = tabsMonitoring;
        this.configurationManager = configManager;
        if (chrome !== undefined && chrome.runtime !== undefined && chrome.runtime.onMessageExternal !== undefined) {
            // Unit tests run in page (not background) context, so chrome.runtime isn't available
            chrome.runtime.onMessageExternal.addListener(this.onMessageExternal);
            chrome.runtime.onMessage.addListener(this.onInjectedMessage);
        }
    };
    WacCommunication.prototype.isActive = function () {
        return this.active === true && this.wacExtensionId != null;
    };
    WacCommunication.prototype.deactivate = function () {
        log_1.getLogger().trace("deactivate WacCommunication");
        if (!this.active || !SUPPORTS_CHROME_MANAGEMENT) {
            return;
        }
        this.active = false;
        this.nativeMessagePoster = undefined;
        this.wacExtensionId = undefined;
        if (chrome !== undefined && chrome.runtime !== undefined && chrome.runtime.onMessageExternal !== undefined) {
            // Unit tests run in page (not background) context, so chrome.runtime isn't available
            chrome.runtime.onMessageExternal.removeListener(this.onMessageExternal);
            chrome.runtime.onMessage.removeListener(this.onInjectedMessage);
            chrome.management.onDisabled.removeListener(this.onDisabledListener);
        }
        log_1.getLogger().log("Sending farewell response");
        if (this.wacExtensionId != null) {
            this.sendMessageToWac(FAREWELL_RESPONSE);
        }
    };
    WacCommunication.prototype.sendMessageToWac = function (message) {
        if (this.wacExtensionId == null) {
            throw new Error("Not connected to Wac Extension");
        }
        var promise = chrome.runtime.sendMessage(this.wacExtensionId, message);
    };
    WacCommunication.prototype.isBrowserChromiumBased = function (browserName) {
        return (browserName === "Chrome" /* Chrome */ || browserName === "Edge" /* Edge */);
    };
    WacCommunication.prototype.handleGreeting = function (extId, greetingRequest) {
        this.wacExtensionId = extId;
        chrome.tabs.onRemoved.addListener(this.onTabRemoved);
        chrome.management.onDisabled.addListener(this.onDisabledListener);
        this.sendToIE(greetingRequest);
        if (this.configurationManager != null) {
            this.configurationManager.setWacActive(true);
        }
        log_1.getLogger().log("Sending greeting response", greetingRequest);
        this.sendMessageToWac(GREETING_RESPONSE);
        // todo (inject to all frames) or (send list of all tabs/frames to wac)
    };
    WacCommunication.prototype.handleFarewell = function (extId) {
        // Unsubscribe to WAC disablement
        chrome.management.onDisabled.removeListener(this.onDisabledListener);
        chrome.tabs.onRemoved.removeListener(this.onTabRemoved);
        // Forward to IE
        this.sendToIE({ messageType: "FarewellRequest" });
        // todo: Forward to frames
        log_1.getLogger().log("Sending farewell response");
        this.sendMessageToWac(FAREWELL_RESPONSE);
        this.wacExtensionId = undefined;
        if (this.configurationManager != null) {
            this.configurationManager.setWacActive(false);
        }
    };
    WacCommunication.prototype.handleConfigurationUpdate = function (message) {
        this.sendToIE(message);
        log_1.getLogger().log("Sending Configuration Update To IE");
    };
    WacCommunication.prototype.isNavigationFinished = function (httpStatusCode) {
        if (httpStatusCode === undefined)
            return false;
        if (httpStatusCode === 304) {
            // Special case, https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304 :
            // "no need to retransmit the requested resources. It is an implicit redirection to a cached resource"
            return true;
        }
        if (httpStatusCode < 200 || httpStatusCode >= 300) {
            return false;
        }
        return true;
    };
    WacCommunication.prototype.incomingMessage = function (message) {
        if (!WacAPI_1.isExtensionMessage(message)) {
            return;
        }
        this.sendMessageToWac(message);
    };
    WacCommunication.prototype.sendToIE = function (message) {
        if (this.nativeMessagePoster == null) {
            console.error(new Error("Unable to exec script in 'InternetExplorer': No nativeMessagePoster"));
        }
        else {
            this.nativeMessagePoster.postNativeMessage(new MessagingModel_1.WacOutgoingNativeMessage(message));
        }
    };
    return WacCommunication;
}());
exports.WacCommunication = WacCommunication;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PROTOCOL_VERSION = 1;
function isMessageToInjected(m) {
    var mm = m;
    return mm.messageType === "MessageToInjected";
}
exports.isMessageToInjected = isMessageToInjected;
function isMessageFromInjected(m) {
    var mm = m;
    return mm.messageType === "MessageFromInjected" && typeof mm.sender === "object";
}
exports.isMessageFromInjected = isMessageFromInjected;
function isMatchReportEvent(event) {
    var validateEventType = function (eventType) { return eventType === "Committed" ||
        eventType === "Completed" ||
        eventType === "Visible" ||
        eventType === "keydown" ||
        eventType === "click" ||
        eventType === "dblclick" ||
        eventType === "mousedown" ||
        eventType === "mouseenter" ||
        eventType === "mouseup" ||
        eventType === "change" ||
        eventType === "contextmenu"; };
    return typeof event.documentCommittedUrl === "string" &&
        (event.eventType !== "keydown" || typeof event.modifierKeys === "string") &&
        typeof event.documentTitle === "string" &&
        typeof event.tabId === "number" &&
        typeof event.frameId === "number" &&
        typeof event.timeStamp === "number" &&
        validateEventType(event.eventType);
}
function isEventMatchReport(message) {
    return message.messageType === "EventMatchReport" &&
        typeof message.event === "object" &&
        isMatchReportEvent(message.event);
}
exports.isEventMatchReport = isEventMatchReport;
function validateGreetingRequest(message) {
    return message.messageType === "GreetingRequest" &&
        typeof message.contentScript === "string" &&
        typeof message.protocolVersion === "number" &&
        message.protocolVersion === exports.PROTOCOL_VERSION;
}
exports.validateGreetingRequest = validateGreetingRequest;
function validateFarewellRequest(message) {
    return message.messageType === "FarewellRequest";
}
exports.validateFarewellRequest = validateFarewellRequest;
function isGreetingResponse(message) {
    if (message.messageType !== "GreetingResponse") {
        return false;
    }
    var features = message.features;
    if (!Array.isArray(features) ||
        features.length === 0 ||
        features.some(function (f) { return typeof f !== "string"; })) {
        throw new Error("GreetingResponse");
    }
    return true;
}
exports.isGreetingResponse = isGreetingResponse;
function validateConditionProperty(con) {
    return (con.matchType === "exact" || con.matchType === "regex") &&
        typeof con.property === "string" &&
        typeof con.value === "string";
}
function validateHtmlEventCondition(eventCondition) {
    return typeof eventCondition.name === "string" &&
        typeof eventCondition.event === "string" &&
        Array.isArray(eventCondition.conditionProperties) &&
        eventCondition.conditionProperties.every(validateConditionProperty);
}
function validateConfigurationUpdate(message) {
    return message.messageType === "ConfigurationUpdate" &&
        Array.isArray(message.eventConditions) &&
        message.eventConditions.every(validateHtmlEventCondition);
}
exports.validateConfigurationUpdate = validateConfigurationUpdate;
/**
 * @return true when message is Extension message.
 */
function isExtensionMessage(message) {
    var messageType = message.messageType;
    return typeof messageType === "string";
}
exports.isExtensionMessage = isExtensionMessage;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var PersistentConfiguration_1 = __webpack_require__(71);
var ConfigurationManagerHelper_1 = __webpack_require__(72);
var CONFIGURATION_STORAGE = "_AternityConfiguration_";
/**
 * Manages configurations from Agent and from WAC
 */
var ConfigurationManager = /** @class */ (function () {
    function ConfigurationManager() {
        this.agentConfiguration = new PersistentConfiguration_1.PersistentConfiguration(CONFIGURATION_STORAGE);
        this.wacActive = false;
    }
    ConfigurationManager.prototype.initConfigurationManager = function (manager) {
        this.manager = manager;
    };
    ConfigurationManager.prototype.setAgentConfiguration = function (jsonString) {
        log_1.getLogger().log("Received new configuration from Agent");
        this.agentConfiguration.parseAndSetConfiguration(jsonString);
        this.activateAgentConfigurationIfConfigured();
    };
    ConfigurationManager.prototype.setWacConfiguration = function (wacConfiguration) {
        log_1.getLogger().log("Received new configuration from WAC", wacConfiguration);
        if (this.wacActive && this.manager != null) {
            this.manager.deactivate();
            this.wacConfiguration = ConfigurationManagerHelper_1.transform(wacConfiguration);
            this.manager.activate(this.wacConfiguration);
        }
    };
    ConfigurationManager.prototype.setWacActive = function (active) {
        this.wacActive = active;
        this.activateAgentConfigurationIfConfigured();
    };
    ConfigurationManager.prototype.resetConfiguration = function () {
        if (this.agentConfiguration != null) {
            this.agentConfiguration.clearConfiguration();
        }
    };
    ConfigurationManager.prototype.getConfiguration = function () {
        return this.wacActive && this.wacConfiguration != null ? this.wacConfiguration : this.agentConfiguration.getConfiguration();
    };
    ConfigurationManager.prototype.activateAgentConfigurationIfConfigured = function () {
        if (!this.wacActive && this.manager != null) {
            this.manager.deactivate();
            this.manager.activate(this.agentConfiguration.getConfiguration());
        }
    };
    return ConfigurationManager;
}());
exports.ConfigurationManager = ConfigurationManager;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var Configuration_1 = __webpack_require__(12);
var Utils = __webpack_require__(0);
var ConfigurationData_1 = __webpack_require__(9);
/**
 * Stores and loads configuration from persistent storage.
 */
var PersistentConfiguration = /** @class */ (function () {
    /**
     * Load configuration from the localStorage if exists.
     * Use default configuration if no configuration was stored.
     *
     * @param storageKey {string} Key used for configuration storage in localStorage object.
     */
    function PersistentConfiguration(storageKey) {
        // Set configuration from the local storage
        this.storageKey = storageKey;
        this.configuration = new Configuration_1.Configuration(Utils.deepClone(ConfigurationData_1.EMPTY_CONFIGURATION));
        // mv3 change - Tested
        var p = this.myInit(storageKey);
    }
    // mv3
    PersistentConfiguration.prototype.myInit = function (storageKey) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, chrome.storage.local.get(null)
                            .then(function (items) {
                            _this.parseAndSetConfiguration(String(items.storageKey));
                        })
                            .catch(function (response) { return log_1.getLogger().error(response); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Parse configuration string and update configuration if successfully parsed.
     * If configuration string is invalid, set default configuration.
     */
    PersistentConfiguration.prototype.parseAndSetConfiguration = function (configurationString) {
        // Start with default
        var configurationData = Utils.deepClone(ConfigurationData_1.EMPTY_CONFIGURATION);
        if (configurationString != null && configurationString.length > 0) {
            var parsedConfiguration = void 0;
            try {
                // tslint:disable-next-line no-unsafe-any
                parsedConfiguration = JSON.parse(configurationString);
            }
            catch (e) {
                log_1.getLogger().error("Failed parsing configuration", configurationString);
                return;
            }
            Utils.populate(parsedConfiguration, configurationData);
        }
        this.setConfigurationImpl(configurationData);
    };
    PersistentConfiguration.prototype.setConfiguration = function (configurationData) {
        var newConfigurationData;
        // Validate version
        if (configurationData == null) {
            log_1.getLogger().log("No configuration found, using empty");
            newConfigurationData = Utils.deepClone(ConfigurationData_1.EMPTY_CONFIGURATION);
        }
        else if (configurationData.ConfigurationVersion !== ConfigurationData_1.CONFIGURATION_VERSION) {
            log_1.getLogger().log("Found configuration in old format, using empty");
            newConfigurationData = Utils.deepClone(ConfigurationData_1.EMPTY_CONFIGURATION);
        }
        else {
            log_1.getLogger().log("Set new configuration", configurationData);
            newConfigurationData = Utils.deepClone(configurationData);
        }
        this.setConfigurationImpl(newConfigurationData);
    };
    /**
     * Set configuration implementation.
     */
    PersistentConfiguration.prototype.setConfigurationImpl = function (configurationData) {
        var resultingConfigurationData = Utils.deepClone(configurationData);
        // Do not allow negative values.
        if (resultingConfigurationData.MaxPropertyLength != null &&
            resultingConfigurationData.MaxPropertyLength < 0) {
            resultingConfigurationData.MaxPropertyLength = 0;
        }
        this.configuration = new Configuration_1.Configuration(resultingConfigurationData);
        // Store locally
        // oroginal
        // localStorage.setItem(this.storageKey, JSON.stringify(configurationData));
        // chrome.storage.local.set([this.storageKey], JSON.stringify(configurationData));
        // const storageKey = this.storageKey;
        var config = JSON.stringify(configurationData);
        var promise = chrome.storage.local.set({ storageKey: config });
    };
    PersistentConfiguration.prototype.clearConfiguration = function () {
        this.setConfiguration(ConfigurationData_1.EMPTY_CONFIGURATION);
    };
    PersistentConfiguration.prototype.getConfiguration = function () {
        return this.configuration;
    };
    /**
     * Serialized configuration object.
     */
    PersistentConfiguration.prototype.getSerializedConfiguration = function () {
        var _this = this;
        // mv3
        var storageKeyValue = "";
        // chrome.storage.local.get([this.storageKey], ( items) => {storageKeyValue = String(items[this.storageKey]);
        // 	return storageKeyValue;
        // });
        var promise = chrome.storage.local.get([this.storageKey]);
        promise.then(function (value) { return storageKeyValue = String(value[_this.storageKey]); }).catch(function (reason) { return log_1.getLogger().error("storage key error", reason); });
        return storageKeyValue;
        // original
        // return localStorage.getItem(this.storageKey);
    };
    PersistentConfiguration.clearPersistentConfiguration = function (storageKey) {
        // mv3
        var promise = chrome.storage.local.remove(storageKey).catch(function (reason) { return log_1.getLogger().error("storage key remove error", reason); });
        // localStorage.removeItem(storageKey);
    };
    return PersistentConfiguration;
}());
exports.PersistentConfiguration = PersistentConfiguration;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ConfigurationData_1 = __webpack_require__(9);
var utils_1 = __webpack_require__(0);
var Configuration_1 = __webpack_require__(12);
function createConsolidatedEventConfig(eventConditions) {
    return eventConditions.map(function (eventCondition) {
        var conditions = {};
        var eventName = eventCondition.event;
        var committedUrl = eventCondition.conditionProperties.filter(function (value) { return value.property === "documentCommittedUrl"; })[0].value;
        for (var _i = 0, _a = eventCondition.conditionProperties; _i < _a.length; _i++) {
            var _b = _a[_i], value = _b.value, matchType = _b.matchType, property = _b.property;
            if (conditions[property] == null) {
                conditions[property] = [];
            }
            conditions[property].push({ MatchType: matchType, Value: value });
        }
        var eventsPerPropertyValue = {};
        eventsPerPropertyValue[committedUrl] = {};
        eventsPerPropertyValue[committedUrl][eventName] = [{ Conditions: conditions }];
        return eventsPerPropertyValue;
    });
}
/**
 * Makes configuration readable by agent
 * @param eventsPerProperty
 */
function transform(eventsPerProperty) {
    var eventsPerPropertyValue = {};
    var eventConfig = {};
    var consolidatedEventConfig = createConsolidatedEventConfig(eventsPerProperty);
    for (var _i = 0, consolidatedEventConfig_1 = consolidatedEventConfig; _i < consolidatedEventConfig_1.length; _i++) {
        var event_1 = consolidatedEventConfig_1[_i];
        // get documentCommittedUrl
        var documentCommittedUrl = Object.keys(event_1)[0];
        if (eventsPerPropertyValue[documentCommittedUrl] == null) {
            eventsPerPropertyValue[documentCommittedUrl] = {};
        }
        var conditionsPerEvent = event_1[documentCommittedUrl];
        for (var _a = 0, _b = Object.keys(conditionsPerEvent); _a < _b.length; _a++) {
            var eventName = _b[_a];
            if (eventConfig[eventName] == null) {
                eventConfig[eventName] = conditionsPerEvent[eventName];
            }
            if (eventsPerPropertyValue[documentCommittedUrl][eventName] == null) {
                var conditionPerEventCopy = utils_1.deepClone(conditionsPerEvent);
                eventsPerPropertyValue[documentCommittedUrl][eventName] = conditionPerEventCopy[eventName];
            }
            else {
                // tslint:disable-next-line:no-any
                for (var _c = 0, _d = Object.keys(conditionsPerEvent[eventName][0].Conditions); _c < _d.length; _c++) {
                    var conditionName = _d[_c];
                    var propertyMatch = conditionsPerEvent[eventName][0].Conditions[conditionName][0];
                    if (conditionName === "aternityCSSSelector" || conditionName === "documentCommittedUrl") {
                        if (conditionName !== "documentCommittedUrl") {
                            eventsPerPropertyValue[documentCommittedUrl][eventName][0].Conditions[conditionName].push(propertyMatch);
                        }
                        eventConfig[eventName][0].Conditions[conditionName].push(propertyMatch);
                    }
                }
            }
        }
    }
    // creating new empty configuration
    var configurationData = utils_1.deepClone(ConfigurationData_1.STARTING_CONFIGURATION);
    // update new configuration data with data received from WAC
    utils_1.populate({
        ConsolidatedEventConfig: {
            documentCommittedUrl: eventsPerPropertyValue
        }, EventConfig: eventConfig,
        WorkTimeThresholds: [
            { WorkTime: 300, TimeFrame: 1000 },
            { WorkTime: 1500, TimeFrame: 10000 },
            { WorkTime: 3000, TimeFrame: 60000 }
        ]
    }, configurationData);
    return new Configuration_1.Configuration(configurationData);
}
exports.transform = transform;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var browserInfo_1 = __webpack_require__(8);
var WacEventReporter = /** @class */ (function () {
    function WacEventReporter(wacCommunication) {
        this.wacCommunication = wacCommunication;
    }
    WacEventReporter.prototype.reportToWac = function (pageMessage) {
        var rawData = pageMessage;
        // create basic structure
        var eventType = rawData.messageData.EventType.split(".").pop();
        // make tab and frame and tab ids as numbers
        var frameId = rawData.frameId != null ? rawData.frameId :
            parseInt(rawData.messageData.Data[0].frameId, 10);
        var tabId = rawData.tabId != null ? rawData.tabId :
            parseInt(rawData.messageData.Data[0].tabId, 10);
        // build message body
        var dataToSend = {
            messageType: "EventMatchReport",
            event: {
                documentCommittedUrl: rawData.messageData.Data[0].documentCommittedUrl,
                modifierKeys: rawData.messageData.Data[0].aternityModifierKeys,
                documentTitle: rawData.messageData.Data[0].documentTitle,
                eventType: eventType,
                frameId: frameId,
                tabId: tabId,
                timeStamp: rawData.timeStamp,
                browser: browserInfo_1.browserInfo.name,
            }
        };
        if (rawData.messageData.Data[0].aternityMouseButton != null) {
            dataToSend.event.mouseButton = rawData.messageData.Data[0].aternityMouseButton;
        }
        if (rawData.messageData.Data[0].key !== undefined) {
            dataToSend.event.key = rawData.messageData.Data[0].key;
        }
        // if there a frame
        if (frameId > 0) {
            dataToSend.event.frameCommittedUrl = rawData.messageData.Data[0].frameCommittedUrl;
        }
        var aternityCSSSelector = rawData.messageData.Data[0].aternityCSSSelector;
        if (typeof aternityCSSSelector === "string") {
            dataToSend.event.cssSelector = aternityCSSSelector;
        }
        // if (isEventMatchReport(dataToSend)) {
        // 	console.log(dataToSend);
        // }
        // send message to WAC
        this.wacCommunication.sendMessageToWac(dataToSend);
    };
    WacEventReporter.prototype.wacMode = function () {
        return this.wacCommunication.isActive();
    };
    return WacEventReporter;
}());
exports.WacEventReporter = WacEventReporter;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL3V0aWxzL3V0aWxzLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy91dGlscy9sb2cudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2NvbW1vbi9NZXNzYWdpbmdNb2RlbC50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvdXRpbHMvdGltZVByb3ZpZGVyLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9jb21tb24vY29uc3RzLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy91dGlscy9sYXp5LnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy91dGlscy9SZWdFeHBNYXRjaGVyLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy91dGlscy9icm93c2VySW5mby50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvY29tbW9uL0NvbmZpZ3VyYXRpb25EYXRhLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9IdG1sTW9uaXRvcmluZy9FdmVudE5hbWVzLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9jb21tb24vRnJhbWVUeXBlLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9jb21tb24vY29uZmlndXJhdGlvbi9Db25maWd1cmF0aW9uLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9jb21tb24vY29uZmlndXJhdGlvbi9Db25maWd1cmF0aW9uRmlsdGVycy50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvY29tbW9uL2NvbmZpZ3VyYXRpb24vQ29uZmlndXJhdGlvblV0aWxzLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9jb21tb24vY29uZmlndXJhdGlvbi9FdmVudENvbmZpZ3VyYXRpb24udHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2NvbW1vbi9jb25maWd1cmF0aW9uL0V2ZW50RmlsdGVycy50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9ub2RlX21vZHVsZXMvc2ltcGxlLWxydS9zaW1wbGUtbHJ1LmpzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL0Rvd25sb2Fkc01vbml0b3JpbmcudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvTWVzc2FnZU9yZGVyLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL05hdGl2ZU1lc3NhZ2luZy50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvYmFja2dyb3VuZC9XZWJSZXF1ZXN0LnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL1dlYlJlcXVlc3RFdmVudC50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvYmFja2dyb3VuZC9JZGxlTW9uaXRvcmluZy50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvYmFja2dyb3VuZC9XaW5kb3dzTW9uaXRvcmluZy50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvYmFja2dyb3VuZC90YWJzLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL2JhY2tncm91bmQudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvQWdlbnRDb21tdW5pY2F0aW9uLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL0JhY2tncm91bmRNYW5hZ2VyLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL1dlYlJlcXVlc3RzU3RhdGUudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvV2ViTmF2aWdhdGlvblJlcG9ydGVyLnRzIiwid2VicGFjazovL0F0ZXJuaXR5RXh0ZW5zaW9uLltuYW1lXS8uL3NyYy9iYWNrZ3JvdW5kL01lc3NhZ2VQcm9jZXNzb3IudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvV2ViTmF2aWdhdGlvbi50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvYmFja2dyb3VuZC9UYWJzU3RhdGUudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvVGFic01vbml0b3JpbmcudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvSHRtbEV2ZW50c01vbml0b3JpbmcudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvV2FjQ29tbXVuaWNhdGlvbi50cyIsIndlYnBhY2s6Ly9BdGVybml0eUV4dGVuc2lvbi5bbmFtZV0vLi9zcmMvYmFja2dyb3VuZC9XYWNBUEkudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvQ29uZmlndXJhdGlvbk1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvUGVyc2lzdGVudENvbmZpZ3VyYXRpb24udHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvQ29uZmlndXJhdGlvbk1hbmFnZXJIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vQXRlcm5pdHlFeHRlbnNpb24uW25hbWVdLy4vc3JjL2JhY2tncm91bmQvV2FjRXZlbnRSZXBvcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FB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O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLGlKQUFpSjs7Ozs7QUFLeEo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0Qjs7QUFFNUIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIscUJBQXFCLGNBQWM7QUFDMUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0Isa0JBQWtCLFVBQVU7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QixZQUFZO0FBQ1osVUFBVTtBQUNWLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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QUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLDhDQUE4Qzs7QUFFbkU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVB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QztTQUNqRTtRQUVELG1CQUFtQjtRQUNuQixJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUU7WUFDaEIsVUFBVSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBMkIsQ0FBQztTQUM3RjtRQUVELElBQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUM7UUFDNUUsSUFBSSxPQUFPLG1CQUFtQixLQUFLLFFBQVEsRUFBRTtZQUM1QyxVQUFVLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQztTQUNuRDtRQUVELHdDQUF3QztRQUN4Qyw0QkFBNEI7UUFDNUIsSUFBSTtRQUNKLHNCQUFzQjtRQUN0QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVNLGtDQUFPLEdBQWQ7UUFDQyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBQ0YsdUJBQUM7QUFBRCxDQUFDO0FBMURZLDRDQUFnQiIsImZpbGUiOiJiYWNrZ3JvdW5kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDU2KTtcbiIsImV4cG9ydCB0eXBlIFByaW1pdGl2ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemFibGVQcmltaXRpdmUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBQcmltaXRpdmUge1xyXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4odmFsdWUpKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XHJcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8XHJcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbn1cclxuXHJcbmNvbnN0IEhUVFBfU1RBVFVTX0NPREVfUkVHRVggPSAvSFRUUFxcL1xcZFxcLlxcZCAoXFxkKykvO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJU3RhdHVzQ29kZURldGFpbHMge1xyXG5cdHJlYWRvbmx5IHN0YXR1c0xpbmU6IHN0cmluZztcclxuXHRyZWFkb25seSBzdGF0dXNDb2RlPzogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogRmlyc3QgdHJ5IHRvIGdldCB0aGUgc3RhdHVzIGNvZGUgZnJvbSB0aGUgZGV0YWlscyAoYXZhaWxhYmxlIHNpbmNlIENocm9tZSA0MyksXHJcbiAqIGlmIGl0IGlzbid0IHRoZXJlIHRyeSB0byBwYXJzZSBpdCBmcm9tIHRoZSBzdGF0dXMgbGluZVxyXG4gKiBBY2NvcmRpbmcgdG8gUkZDIDI2MTY6XHJcbiAqIFN0YXR1cy1MaW5lID0gSFRUUC1WZXJzaW9uIFNQIFN0YXR1cy1Db2RlIFNQIFJlYXNvbi1QaHJhc2UgQ1JMRlxyXG4gKlxyXG4gKiBAcmV0dXJuIFN0YXR1cyBjb2RlIG9yIG51bGwgaWYgdGhlIHN0YXR1c0xpbmUgaXMgaW52YWxpZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0dXNDb2RlKGRldGFpbHM6IElTdGF0dXNDb2RlRGV0YWlscyk6IG51bWJlciB8IG51bGwge1xyXG5cdGlmIChkZXRhaWxzLnN0YXR1c0NvZGUgIT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGRldGFpbHMuc3RhdHVzQ29kZTtcclxuXHR9XHJcblx0Y29uc3Qgc3RhdHVzQ29kZSA9IGRldGFpbHMuc3RhdHVzTGluZS5tYXRjaChIVFRQX1NUQVRVU19DT0RFX1JFR0VYKTtcclxuXHRyZXR1cm4gc3RhdHVzQ29kZSAhPT0gbnVsbCA/IHBhcnNlSW50KHN0YXR1c0NvZGVbMV0sIDEwKSA6IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cjogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXg7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aChzdHI6IHN0cmluZywgc3VmZml4OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRyZXR1cm4gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUoczogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U3Vic3RyaW5nKHN0cjogc3RyaW5nLCBzdGFydDogc3RyaW5nLCBlbmQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0Ly8gRmluZCBzdGFydFxyXG5cdGNvbnN0IHN0YXJ0SW5kZXggPSBzdHIuaW5kZXhPZihzdGFydCk7XHJcblx0aWYgKHN0YXJ0SW5kZXggPT09IC0xKSB7XHJcblx0XHRyZXR1cm4gXCJcIjtcclxuXHR9XHJcblxyXG5cdC8vIFNraXAgdGhlIGhhc2ggaWYgcHJlc2VudFxyXG5cdGNvbnN0IGVuZEluZGV4ID0gc3RyLmluZGV4T2YoZW5kKTtcclxuXHQvLyBTa2lwIGVtcHR5IHF1ZXJ5XHJcblx0aWYgKGVuZEluZGV4ID09PSBzdGFydEluZGV4ICsgMSkge1xyXG5cdFx0cmV0dXJuIFwiXCI7XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm4gc3Vic3RyaW5nXHJcblx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4ICE9PSAtMSA/IGVuZEluZGV4IDogc3RyLmxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmljIGludGVyZmFjZSBmb3IgS2V5LVZhbHVlIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgS2V5VmFsdWU8VD4ge1xyXG5cdFtrZXk6IHN0cmluZ106IFQ7XHJcbn1cclxuXHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5leHBvcnQgaW50ZXJmYWNlIFVybFBhcmFtcyBleHRlbmRzIEtleVZhbHVlPHN0cmluZ1tdPiB7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB1cmwgYW5kIGV4dHJhY3QgcXVlcnkgc3RyaW5nLlxyXG4gKiBUaGUgcXVlcnkgc3RyaW5nIGlzIHBhcnNlZCBpbnRvIGtleSB0byB2YWx1ZSBhcnJheS5cclxuICogTXVsdGlwbGUgdmFsdWVzIGFyZSBzdXBwb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsUGFyYW1zKHVybDogc3RyaW5nKTogVXJsUGFyYW1zIHtcclxuXHRjb25zdCByZXQ6IFVybFBhcmFtcyA9IHt9O1xyXG5cclxuXHQvLyBHZXQgcXVlcnkgc3RyaW5nXHJcblx0Y29uc3QgcXVlcnkgPSBnZXRTdWJzdHJpbmcodXJsLCBcIj9cIiwgXCIjXCIpO1xyXG5cdGlmIChxdWVyeS5sZW5ndGggPT09IDApIHtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cclxuXHQvLyBQYXJzZSB0aGUgcXVlcnkgc3RyaW5nXHJcblx0Y29uc3QgcGFyYW1zID0gcXVlcnkuc3BsaXQoXCImXCIpO1xyXG5cdC8vIE5vIHZhbHVlcywgdXNlIHRoZSBxdWVyeSBhcyBwYXJhbWV0ZXIgbmFtZS5cclxuXHRpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0cHVzaE9ySW5pdChyZXQsIHF1ZXJ5LCBcIlwiKTtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cclxuXHRmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xyXG5cdFx0Y29uc3QgbmFtZUluZGV4ID0gcGFyYW0uaW5kZXhPZihcIj1cIik7XHJcblx0XHRpZiAobmFtZUluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRwdXNoT3JJbml0KHJldCwgcGFyYW0sIFwiXCIpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBuYW1lID0gZGVjb2RlVVJJKHBhcmFtLnN1YnN0cmluZygwLCBuYW1lSW5kZXgpKTtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBkZWNvZGVVUkkocGFyYW0uc3Vic3RyaW5nKG5hbWVJbmRleCArIDEpKTtcclxuXHRcdFx0cHVzaE9ySW5pdChyZXQsIG5hbWUsIHZhbHVlKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Ly8gRG8gbm90IGFkZCBpbnZhbGlkIFVSSSBwYXJhbXNcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQdXNoZXMgdmFsdWUgdG8gYXJyYXkgcHJvcGVydHkgaWYga2V5IGV4aXN0cyBvciBjcmVhdGUgYSBuZXcgYXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHVzaE9ySW5pdDxUPihrZXlWYWx1ZU9iajogS2V5VmFsdWU8VFtdPiwga2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XHJcblx0aWYgKGtleSBpbiBrZXlWYWx1ZU9iaikge1xyXG5cdFx0a2V5VmFsdWVPYmpba2V5XS5wdXNoKHZhbHVlKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0a2V5VmFsdWVPYmpba2V5XSA9IFt2YWx1ZV07XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogQ29uY2F0ZW5hdGUgdmFsdWUgdG8gYXJyYXkgcHJvcGVydHkgaWYga2V5IGV4aXN0cyBvciBhc3NpZ24gdGhlIHZhbHVlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRPckluaXQ8VD4oXHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0a2V5VmFsdWVPYmo6IHsgW3Byb3A6IHN0cmluZ106IFRbXSB8IHVuZGVmaW5lZCB9LCBrZXk6IHN0cmluZywgdmFsdWVzOiBUW10pOiB2b2lkIHtcclxuXHJcblx0aWYgKGtleSBpbiBrZXlWYWx1ZU9iaikge1xyXG5cdFx0Y29uc3QgY3VycmVudFZhbHVlcyA9IGtleVZhbHVlT2JqW2tleV07XHJcblx0XHRpZiAoY3VycmVudFZhbHVlcyAhPSBudWxsKSB7XHJcblx0XHRcdGtleVZhbHVlT2JqW2tleV0gPSBjdXJyZW50VmFsdWVzLmNvbmNhdCh2YWx1ZXMpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRrZXlWYWx1ZU9ialtrZXldID0gdmFsdWVzO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0IHByb3BlcnRpZXMgdmFsdWVzIGZyb20gc291cmNlIGludG8gZGVzdGluYXRpb24uXHJcbiAqIE1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBmaXJzdCBsZXZlbCBwcm9wZXJ0aWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlKHNvdXJjZToge3JlYWRvbmx5IFtwcm9wOiBzdHJpbmddOiB1bmtub3dufSwgZGVzdGluYXRpb246IHtbcHJvcDogc3RyaW5nXTogdW5rbm93bn0pOiB2b2lkIHtcclxuXHRmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XHJcblx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcblx0XHRcdGRlc3RpbmF0aW9uW3Byb3BdID0gc291cmNlW3Byb3BdO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm4gQSBkZWVwIGNvcHkgb2YgdGhlIG9iamVjdC5cclxuICogU3VwcG9ydHMgZGVlcCBjb3B5IG9mIGlubmVyIGFycmF5cyBhbmQgb2JqZWN0cy5cclxuICovXHJcbi8vIHRzbGludDpkaXNhYmxlIHJlYWRvbmx5LWFycmF5IG5vLWFueSBuby11bnNhZmUtYW55XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqOiBuZXZlcik6IG5ldmVyO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lKG9iajogbnVsbCk6IG51bGw7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqOiB1bmRlZmluZWQpOiB1bmRlZmluZWQ7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqOiBudW1iZXIpOiBudW1iZXI7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqOiBzdHJpbmcpOiBzdHJpbmc7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqOiBib29sZWFuKTogYm9vbGVhbjtcclxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZTxUPihvYmo6IFJlYWRvbmx5QXJyYXk8VD4pOiBUW107XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmU8VD4ob2JqOiBSZWFkb25seTxUPik6IFQ7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmU8VD4ob2JqOiBhbnkpOiBhbnk7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmU8VD4ob2JqOiBuZXZlciB8IG51bGwgfCB1bmRlZmluZWQgfCBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuIHwgUmVhZG9ubHk8VD4gfCBSZWFkb25seUFycmF5PFQ+IHwgYW55KTpcclxuXHRuZXZlciB8IG51bGwgfCB1bmRlZmluZWQgfCBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuIHwgVCB8IFRbXSB8IGFueSB7XHJcblxyXG5cdGlmIChvYmogPT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9XHJcblxyXG5cdC8vIEFycmF5IGlzIGEgc3BlY2lhbCBjYXNlXHJcblx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG5cdFx0Y29uc3QgcmV0QXJyYXkgPSBuZXcgQXJyYXk8VD4ob2JqLmxlbmd0aCk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRyZXRBcnJheVtpXSA9IGRlZXBDbG9uZShvYmpbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldEFycmF5O1xyXG5cdH1cclxuXHJcblx0Ly8gTWFrZSBzdXJlIHRoZSByZXR1cm5lZCBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3RvdHlwZSBhcyB0aGUgb3JpZ2luYWxcclxuXHRsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgIT0gbnVsbFxyXG5cdFx0PyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKVxyXG5cdFx0OiBvYmouX19wcm90b19fO1xyXG5cclxuXHRpZiAoIXByb3RvKSB7XHJcblx0XHQvLyBUaGlzIGxpbmUgd291bGQgcHJvYmFibHkgb25seSBiZSByZWFjaGVkIGJ5IHZlcnkgb2xkIGJyb3dzZXJzXHJcblx0XHRwcm90byA9IChvYmogYXMgeyBjb25zdHJ1Y3RvcjogeyBwcm90b3R5cGU6IHVua25vd247IH0gfSkuY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgcmV0ID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XHJcblxyXG5cdGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcclxuXHRcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIGNvbnRpbnVlO1xyXG5cdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLWFueSBuby11bnNhZmUtYW55XHJcblx0XHRyZXRbcHJvcF0gPSBkZWVwQ2xvbmUob2JqW3Byb3BdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuLy8gdHNsaW50OmVuYWJsZSByZWFkb25seS1hcnJheSBuby1hbnkgbm8tdW5zYWZlLWFueVxyXG5cclxuLyoqXHJcbiAqIFJld3JpdGVzIHRoZSBvYmplY3QgdXNpbmcgZ2l2ZW4gY2FsbGJhY2suXHJcbiAqIEBwYXJhbSBvYmogT2JqZWN0IHRvIHJld3JpdGVcclxuICogQHBhcmFtIGYgVHJhbnNmb3JtYXRpb24gZnVuY3Rpb25cclxuICogQHBhcmFtIGxlYXZlVW5kZWZpbmVkIFdoZW4gc2V0IHRvICd0cnVlJyBpdCBhbGxvd3MgdG8gc2V0IHVuZGVmaW5lZCB2YWx1ZVxyXG4gKiAgaW4gY2FzZSBpdCBpcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2suXHJcbiAqIFdoZW4gc2V0IHRvICdmYWxzZScgdGhlIHByb3BlcnR5IGlzIHJlbW92ZWQgZnJvbSB0aGUgb2JqZWN0XHJcbiAqICB3aGVuIHVuZGVmaW5lZCB2YWx1ZSBpcyByZXR1cm5lZCBmcm9tIHRoZSBjYWxsYmFjay5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlT2JqZWN0KFxyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1hbnlcclxuXHRvYmo6IHsgW2lkOiBzdHJpbmddOiBhbnkgfSxcclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55XHJcblx0Y29udmVydDogKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55LFxyXG5cdGxlYXZlVW5kZWZpbmVkOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG5cclxuXHRpZiAob2JqID09IG51bGwpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqKSB7XHJcblx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIGNvbnRpbnVlO1xyXG5cdFx0Y29uc3QgdmFsdWUgPSBjb252ZXJ0KHByb3BlcnR5LCBvYmpbcHJvcGVydHldKTtcclxuXHJcblx0XHQvLyBTcGVjaWFsIGNhc2UgZm9yIHVuZGVmaW5lZFxyXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhbGVhdmVVbmRlZmluZWQpIHtcclxuXHRcdFx0ZGVsZXRlIG9ialtwcm9wZXJ0eV07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGFjY2VzcyB0byBuZXN0ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgdXNpbmcgYSBzdHJpbmcga2V5IHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBhY2Nlc3MuXHJcbiAqIEBwYXJhbSBwYXRoIFRoZSBuZXN0ZWQgcGF0aCB0byBhY2Nlc3Mgc2VwYXJhdGVkIGJ5IGRvdHMgKGUuZy4gXCJhdHRyaWJ1dGVzLmlkXCIpLiBJZiBwYXRoIGlzIFwiXCJcclxuICogdGhlbiB0aGUgb3JpZ2luYWwgb2JqZWN0IGlzIHJldHVybmVkLlxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLWFueVxyXG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmo6IHsgW3Byb3A6IHN0cmluZ106IGFueTsgfSwgcGF0aDogc3RyaW5nKTogYW55IHtcclxuXHRpZiAocGF0aCA9PT0gXCJcIikge1xyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9XHJcblxyXG5cdGxldCByZXQgPSBvYmo7XHJcblxyXG5cdGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoICYmIHR5cGVvZiByZXQgIT09IFwidW5kZWZpbmVkXCI7IGkrKykge1xyXG5cdFx0LyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1hbnkgKi9cclxuXHRcdHJldCA9IHJldFtrZXlzW2ldXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBhIHN0cmluZyB3aGljaCBjYWxscyBmdW5jdGlvbiB3aXRoIGdpdmVuIGFyZ3VtZW50cy5cclxuICovXHJcbi8vIHRzbGludDpkaXNhYmxlIG1heC1saW5lLWxlbmd0aCBuby1hbnlcclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvbkNhbGw8Uj4oZjogKCkgPT4gUik6IHN0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvbkNhbGw8UDAsIFI+KGY6IChwMDogUDApID0+IFIsIGFyZ3M6IFtQMF0pOiBzdHJpbmc7XHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlRnVuY3Rpb25DYWxsPFAwLCBQMSwgUj4oZjogKHAwOiBQMCwgcDE6IFAxKSA9PiBSLCBhcmdzOiBbUDAsIFAxXSk6IHN0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvbkNhbGw8UDAsIFAxLCBQMiwgUj4oZjogKHAwOiBQMCwgcDE6IFAxLCBwMjogUDIpID0+IFIsIGFyZ3M6IFtQMCwgUDEsIFAyXSk6IHN0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvbkNhbGw8UDAsIFAxLCBQMiwgUDMsIFI+KGY6IChwMDogUDAsIHAxOiBQMSwgcDI6IFAyLCBwMzogUDMpID0+IFIsIGFyZ3M6IFtQMCwgUDEsIFAyLCBQM10pOiBzdHJpbmc7XHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlRnVuY3Rpb25DYWxsPFAwLCBQMSwgUDIsIFAzLCBQNCwgUj4oZjogKHAwOiBQMCwgcDE6IFAxLCBwMjogUDIsIHAzOiBQMywgcDQ6IFA0KSA9PiBSLCBhcmdzOiBbUDAsIFAxLCBQMiwgUDMsIFA0XSk6IHN0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvbkNhbGw8UDAsIFAxLCBQMiwgUDMsIFA0LCBQNSwgUj4oZjogKHAwOiBQMCwgcDE6IFAxLCBwMjogUDIsIHAzOiBQMywgcDQ6IFA0LCBwNTogUDUpID0+IFIsIGFyZ3M6IFtQMCwgUDEsIFAyLCBQMywgUDQsIFA1XSk6IHN0cmluZztcclxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGdW5jdGlvbkNhbGwoZjogRnVuY3Rpb24sIGFyZ3M/OiBSZWFkb25seUFycmF5PGFueT4pOiBzdHJpbmcge1xyXG4vLyB0c2xpbnQ6ZW5hYmxlIG1heC1saW5lLWxlbmd0aCBuby1hbnlcclxuXHJcblx0Y29uc3QgYXJnc1N0cmluZzogc3RyaW5nW10gPSBbXTtcclxuXHRpZiAoYXJncyAhPSBudWxsKSB7XHJcblx0XHRmb3IgKGNvbnN0IHYgb2YgYXJncykge1xyXG5cdFx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWFueVxyXG5cdFx0XHRhcmdzU3RyaW5nLnB1c2goKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSA/IGBcIiR7dn1cImAgOiB2KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBgKCR7Zn0pKCR7YXJnc1N0cmluZ30pYDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBvbmUgb2YgYSBsaXN0IG9mIHZhbHVlcy5cclxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XHJcbiAqIEBwYXJhbSB2YWx1ZXMgVGhlIHBvc3NpYmxlIHZhbHVlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVPbmVPZjxUPih2YWx1ZTogVCwgdmFsdWVzOiBBcnJheTxUPik6IGJvb2xlYW47XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbHVlT25lT2Y8VD4odmFsdWU6IFQsIHZhbHVlczogUmVhZG9ubHlBcnJheTxUPik6IGJvb2xlYW47XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbHVlT25lT2Y8VD4odmFsdWU6IFQsIHZhbHVlczogQXJyYXk8VD4gfCBSZWFkb25seUFycmF5PFQ+KTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIHZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XHJcbn1cclxuXHJcbmNvbnN0IFNVUFBPUlRTX0ZSRUVaRSA9IE9iamVjdC5mcmVlemUgIT0gbnVsbCAmJiBPYmplY3QuaXNGcm96ZW4gIT0gbnVsbCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAhPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IGNhbGxzIE9iamVjdC5mcmVlemUgZm9yIGVhY2ggcHJvcGVydHkgYW5kIHJldHVybnMgdGhpcyBvYmplY3QuXHJcbiAqXHJcbiAqIEJhc2VkIG9uIGRlZXAtZnJlZXplIGZvcmsgd2l0aCBmaXhlcyBmb3IgUGhhbnRvbUpTXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVlcEZyZWV6ZTxUPihvYmo6IFJlYWRvbmx5QXJyYXk8VD4pOiBSZWFkb25seUFycmF5PFQ+O1xyXG5leHBvcnQgZnVuY3Rpb24gZGVlcEZyZWV6ZTxUPihvYmo6IFJlYWRvbmx5PFQ+KTogUmVhZG9ubHk8VD47XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWVwRnJlZXplPFQ+KG9iajogUmVhZG9ubHk8VD4gfCBSZWFkb25seUFycmF5PFQ+KTogUmVhZG9ubHk8VD4gfCBSZWFkb25seUFycmF5PFQ+IHtcclxuXHRpZiAoIVNVUFBPUlRTX0ZSRUVaRSkge1xyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9XHJcblxyXG5cdC8vIEFzIG9mIEphbiAyMDE4IGdtYWlsIG92ZXJ3cml0ZXMgT2JqZWN0LkZyZWV6ZSwgY2F1c2luZyBpdCB0byBhZGQgYW4gb2JqZWN0IHByb3BlcnR5LlxyXG5cdC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGdyYWIgdGhlIHByb3BlcnR5IGxpc3QgYmVmb3JlIGZyZWV6aW5nIHRoZSBvYmplY3QuXHJcblx0Y29uc3Qgb3JpZ2luYWxQcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XHJcblxyXG5cdGNvbnN0IG9iaklzRnVuY3Rpb24gPSB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XHJcblxyXG5cdE9iamVjdC5mcmVlemUob2JqKTtcclxuXHJcblx0Zm9yIChjb25zdCBwcm9wIG9mIG9yaWdpbmFsUHJvcHMpIHtcclxuXHRcdC8vIERvIG5vdCBmcmVlemUgc3BlY2lhbCBmdW5jdGlvbiBwcm9wZXJ0aWVzLlxyXG5cdFx0Ly8gUGhhbnRvbUpTIGRvZXNuJ3QgbGlrZSBpdC5cclxuXHRcdGlmIChvYmpJc0Z1bmN0aW9uICYmIChwcm9wID09PSBcImNhbGxlclwiIHx8IHByb3AgPT09IFwiY2FsbGVlXCIgfHwgcHJvcCA9PT0gXCJhcmd1bWVudHNcIikpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2tpcCBudWxsXHJcblx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55XHJcblx0XHRpZiAoKG9iaiBhcyBhbnkpW3Byb3BdID09PSBudWxsKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlY3Vyc2l2ZWx5IGZyZWV6ZSBvbmx5IG9iamVjdHMgb3IgZnVuY3Rpb25zXHJcblx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55XHJcblx0XHRpZiAodHlwZW9mIChvYmogYXMgYW55KVtwcm9wXSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKG9iaiBhcyBhbnkpW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRG8gbm90IGZyZWV6ZSBpZiBmcm96ZW5cclxuXHRcdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1hbnlcclxuXHRcdGlmIChPYmplY3QuaXNGcm96ZW4oKG9iaiBhcyBhbnkpW3Byb3BdKSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGcmVlemUgcmVjdXJzaXZlbHkuXHJcblx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55IG5vLXVuc2FmZS1hbnlcclxuXHRcdGRlZXBGcmVlemUoKG9iaiBhcyBhbnkpW3Byb3BdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8vIHRzbGludDpkaXNhYmxlIHJlYWRvbmx5LWFycmF5XHJcbmV4cG9ydCBmdW5jdGlvbiBhc1JlYWRvbmx5PFQ+KG9iajogVFtdKTogUmVhZG9ubHlBcnJheTxUPjtcclxuZXhwb3J0IGZ1bmN0aW9uIGFzUmVhZG9ubHk8VD4ob2JqOiBUKTogUmVhZG9ubHk8VD47XHJcbmV4cG9ydCBmdW5jdGlvbiBhc1JlYWRvbmx5PFQ+KG9iajogVCB8IFRbXSk6IFJlYWRvbmx5PFQ+IHwgUmVhZG9ubHlBcnJheTxUPiB7XHJcblx0cmV0dXJuIG9iajtcclxufVxyXG4vLyB0c2xpbnQ6ZW5hYmxlIHJlYWRvbmx5LWFycmF5XHJcblxyXG4vKipcclxuICogQWRkIHZhbHVlIHRvIGFycmF5IG9ubHkgaWYgaXQgZG9lc24ndCBwcmVzZW50IGluIGFycmF5LlxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRVbmlxdWU8VD4oYXJyYXk6IFRbXSwgdmFsdWU6IFQpOiB2b2lkIHtcclxuXHRmb3IgKGNvbnN0IGVsZW0gb2YgYXJyYXkpIHtcclxuXHRcdGlmIChlbGVtID09PSB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRhcnJheS5wdXNoKHZhbHVlKTtcclxufVxyXG5cclxuY29uc3QgUkVHRVhfRVNDQVBFRF9DSEFSQUNURVJTID0gLyhbXFxcXF4kLiorPygpW1xcXXt9fF0pL2c7IC8vIFRha2UgdGhlIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG5jb25zdCBSRUdFWF9VTkVTQ0FQRURfQ0hBUkFDVEVSUyA9IC9cXFxcKFtcXFxcXiQuKis/KClbXFxde318XSkvZzsgLy8gVGFrZSB0aGUgc3BlY2lhbCB0aGF0IGFyZSBwcmVjZWVkZWQgYnkgXFxcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHAodW5lc2NhcGVkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdC8vIEltcGxlbWVudGF0aW9uIGNvcGllZCBmcm9tIGxvZGFzaCBpbXBsZW1lbnRhdGlvbiBmb3IgZXNjYXBlUmVnRXhwXHJcblx0cmV0dXJuICh1bmVzY2FwZWQgIT09IFwiXCIgJiYgUkVHRVhfRVNDQVBFRF9DSEFSQUNURVJTLnRlc3QodW5lc2NhcGVkKSlcclxuXHRcdD8gdW5lc2NhcGVkLnJlcGxhY2UoUkVHRVhfRVNDQVBFRF9DSEFSQUNURVJTLCBcIlxcXFwkJlwiKVxyXG5cdFx0OiB1bmVzY2FwZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbmVzY2FwZSBzdHJpbmcgaW50byByZWdleCBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZVJlZ0V4cChlc2NhcGVkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdC8vIEltcGxlbWVudGF0aW9uIGFtbWVuZGVkIGZyb20gbG9kYXNoIGltcGxlbWVudGF0aW9uIGZvciBlc2NhcGVSZWdFeHBcclxuXHRyZXR1cm4gKGVzY2FwZWQgIT09IFwiXCIgJiYgUkVHRVhfVU5FU0NBUEVEX0NIQVJBQ1RFUlMudGVzdChlc2NhcGVkKSlcclxuXHRcdD8gZXNjYXBlZC5yZXBsYWNlKFJFR0VYX1VORVNDQVBFRF9DSEFSQUNURVJTLCBcIiQxXCIpXHJcblx0XHQ6IGVzY2FwZWQ7XHJcbn1cclxuXHJcbmNvbnN0IERBVEFfUkVHRVggPSAvXmRhdGFcXDovO1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFdoZXRoZXIgZ2l2ZW4gVVJMIGlzIGRhdGEgVVJMLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVVybCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdHJldHVybiBEQVRBX1JFR0VYLnRlc3QodXJsKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGlzSW50ZXJuZXRFeHBsb3JlciA9XHJcblx0Ly8gQ29uZGl0aW9uYWwgY29tcGlsYXRpb246IGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3NjcmlwdGluZy9qYXZhc2NyaXB0L3JlZmVyZW5jZS9hdC1jYy1vbi1zdGF0ZW1lbnQtamF2YXNjcmlwdFxyXG5cdC8qQGNjX29uIUAqL2ZhbHNlOyAvLyB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgIT0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBTZXQgcHJvcGVydHkgdmFsdWUgaWYgaXQgZG9lc24ndCBwcmVzZW50IGluIHRoZSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0SWZOb3RFeGlzdDxULCBQIGV4dGVuZHMga2V5b2YgVD4oZGF0YTogVCwgcHJvcGVydHk6IFAsIHZhbHVlOiBUW1BdKTogdm9pZCB7XHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1hbnlcclxuXHRpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XHJcblx0XHRkYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBwcm9wZXJ0eSB2YWx1ZSB1c2luZyB2YWx1ZUZhY3RvcnkgaWYgaXQgZG9lc24ndCBwcmVzZW50IGluIHRoZSBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0SWZOb3RFeGlzdEZhY3Rvcnk8VCwgUCBleHRlbmRzIGtleW9mIFQ+KGRhdGE6IFQsIHByb3BlcnR5OiBQLCB2YWx1ZUZhY3Rvcnk6ICgpID0+IFRbUF0pOiB2b2lkIHtcclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWFueVxyXG5cdGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcclxuXHRcdGRhdGFbcHJvcGVydHldID0gdmFsdWVGYWN0b3J5KCk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogU2VhcmNoIGVsZW1lbnQgaW4gYXJyYXkuXHJcbiAqIEBzZWUgQXJyYXkucHJvdG90eXBlLmZpbmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQ+KGFycjogQXJyYXlMaWtlPFQ+LCBjb25kaXRpb246IChlbGVtZW50OiBUKSA9PiBib29sZWFuKTogVCB8IHVuZGVmaW5lZCB7XHJcblx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhcnIubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcblx0XHRjb25zdCBlbGVtZW50ID0gYXJyW2ldO1xyXG5cdFx0aWYgKGNvbmRpdGlvbihlbGVtZW50KSkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGJpbmFyeSBzdHJpbmcgdG8gYSBVaW50OEFycmF5XHJcbiAqIEBwYXJhbSBzdHIgaW5wdXQgYmluYXJ5IHN0cmluZyB0byBjb252ZXJ0IHRvIGEgVWludDhBcnJheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbnN0cmluZzJCdWYoc3RyOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcclxuXHRjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcclxuXHRmb3IgKGxldCBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcclxuXHR9XHJcblx0cmV0dXJuIGJ1ZjtcclxufSIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHdoaWNoIGRvZXMgbm90aGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKTogdm9pZCB7IH1cclxuXHJcbi8vIEdsb2JhbCBjb25zb2xlIG9iamVjdCBhbmQgd2luZG93LmNvbnNvbGUgZG9uJ3QgZXhpc3QgaW4gSUUgYnkgZGVmYXVsdC5cclxuLy8gQnV0IGl0IG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gb3BlbmluZyBkZXZlbG9wZXIgdG9vbHMuXHJcbmZ1bmN0aW9uIGhhc0NvbnNvbGUoKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIGNvbnNvbGUgIT0gbnVsbDtcclxufVxyXG5cclxuLy8gQmluZCBpcyBzdXBwb3J0ZWQgb25seSBpbiBtb2Rlcm4gYnJvd3NlcnNcclxuY29uc3QgU1VQUE9SVFNfQklORCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICE9IG51bGw7XHJcblxyXG50eXBlIENvbnNvbGVMb2dGdW5jdGlvbnNMaXN0ID0gXCJkZWJ1Z1wiIHwgXCJsb2dcIiB8IFwiaW5mb1wiIHwgXCJ3YXJuXCIgfCBcImVycm9yXCIgfCBcInRyYWNlXCI7XHJcbnR5cGUgQ29uc29sZUxvZ0Z1bmN0aW9uID0gQ29uc29sZVtcImxvZ1wiXTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwIGxvZyBmdW5jdGlvbiB3aXRoIG1lc3NhZ2UgYW5kIG9wdGlvbmFsIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmIGNvbnNvbGUgb2JqZWN0IGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwQ29uc29sZUxvZ0Z1bmN0aW9uKGY6IENvbnNvbGVMb2dGdW5jdGlvbnNMaXN0KTogQ29uc29sZUxvZ0Z1bmN0aW9uIHtcclxuXHJcblx0aWYgKCFoYXNDb25zb2xlKCkpIHtcclxuXHRcdHJldHVybiBlbXB0eUZ1bmN0aW9uO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVzaGFycGVyIDIwMTcuMyBidWdcclxuXHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBJbXBsaWNpdEFueUVycm9yXHJcblxyXG5cdC8vIFZhbGlkYXRlIGZ1bmN0aW9uIGV4aXN0LlxyXG5cdC8vIElmIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QgdHJ5IHVzaW5nICdjb25zb2xlLmxvZycuXHJcblx0aWYgKGNvbnNvbGVbZl0gPT0gbnVsbCkge1xyXG5cdFx0aWYgKGYgIT09IFwibG9nXCIpIHtcclxuXHRcdFx0cmV0dXJuIHdyYXBDb25zb2xlTG9nRnVuY3Rpb24oXCJsb2dcIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZW1wdHlGdW5jdGlvbjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFVzZSBiaW5kIGlmIHBvc3NpYmxlXHJcblx0dHJ5IHtcclxuXHRcdGlmIChTVVBQT1JUU19CSU5EICYmXHJcblx0XHRcdGNvbnNvbGVbZl0gIT0gbnVsbCAmJlxyXG5cdFx0XHRjb25zb2xlW2ZdLmJpbmQgIT0gbnVsbCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGNvbnNvbGVbZl0uYmluZChjb25zb2xlKSBhcyBDb25zb2xlTG9nRnVuY3Rpb247XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvbnNvbGVbZl07XHJcblx0Ly8gUmVTaGFycGVyIHJlc3RvcmUgSW1wbGljaXRBbnlFcnJvclxyXG59XHJcblxyXG50eXBlIExvZ2dlciA9IHsgW1AgaW4gQ29uc29sZUxvZ0Z1bmN0aW9uc0xpc3RdOiBDb25zb2xlW1BdOyB9O1xyXG5cclxuY29uc3QgZW1wdHlMb2dnZXI6IExvZ2dlciA9IHtcclxuXHRkZWJ1ZzogZW1wdHlGdW5jdGlvbixcclxuXHRsb2c6IGVtcHR5RnVuY3Rpb24sXHJcblx0aW5mbzogZW1wdHlGdW5jdGlvbixcclxuXHR3YXJuOiBlbXB0eUZ1bmN0aW9uLFxyXG5cdGVycm9yOiBlbXB0eUZ1bmN0aW9uLFxyXG5cdHRyYWNlOiBlbXB0eUZ1bmN0aW9uXHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cmFwQ29uc29sZSgpOiBMb2dnZXIge1xyXG5cdHJldHVybiB7XHJcblx0XHRkZWJ1Zzogd3JhcENvbnNvbGVMb2dGdW5jdGlvbihcImRlYnVnXCIpLFxyXG5cdFx0bG9nOiB3cmFwQ29uc29sZUxvZ0Z1bmN0aW9uKFwibG9nXCIpLFxyXG5cdFx0aW5mbzogd3JhcENvbnNvbGVMb2dGdW5jdGlvbihcImluZm9cIiksXHJcblx0XHR3YXJuOiB3cmFwQ29uc29sZUxvZ0Z1bmN0aW9uKFwid2FyblwiKSxcclxuXHRcdGVycm9yOiB3cmFwQ29uc29sZUxvZ0Z1bmN0aW9uKFwiZXJyb3JcIiksXHJcblx0XHR0cmFjZTogd3JhcENvbnNvbGVMb2dGdW5jdGlvbihcInRyYWNlXCIpXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm4gTG9nZ2VyIHdoaWNoIGxvZ3MgaWYgd2luZG93LmNvbnNvbGUgcHJlc2VudCBvciBsb2dnZXIgc3R1YiB3aGljaCBkb2VzIG5vdGhpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb25zb2xlTG9nZ2VyKCk6IExvZ2dlciB7XHJcblx0cmV0dXJuIGhhc0NvbnNvbGUoKSA/IHdyYXBDb25zb2xlKCkgOiBlbXB0eUxvZ2dlcjtcclxufVxyXG5cclxuLy8gQ3VycmVudCBsb2dnZXIgaW1wbGVtZW50YXRpb25cclxubGV0IGN1cnJlbnRMb2dnZXIgPSBlbXB0eUxvZ2dlcjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dnZXIoKTogTG9nZ2VyIHtcclxuXHRyZXR1cm4gY3VycmVudExvZ2dlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSBsb2dzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ3MoKTogdm9pZCB7XHJcblx0Y3VycmVudExvZ2dlciA9IGNyZWF0ZUNvbnNvbGVMb2dnZXIoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERpc2FibGUgbG9ncy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlTG9ncygpOiB2b2lkIHtcclxuXHRjdXJyZW50TG9nZ2VyID0gZW1wdHlMb2dnZXI7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBicm93c2VySW5mbyB9IGZyb20gXCIuLi91dGlscy9icm93c2VySW5mb1wiO1xyXG5pbXBvcnQgeyBFWFRFTlNJT05fVkVSU0lPTiwgTG9nTGV2ZWwgfSBmcm9tIFwiLi9jb25zdHNcIjtcclxuaW1wb3J0IHsgdGltZVByb3ZpZGVyIH0gZnJvbSBcIi4uL3V0aWxzL3RpbWVQcm92aWRlclwiO1xyXG5pbXBvcnQgeyBkZWVwQ2xvbmUgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcclxuaW1wb3J0IHsgVVhEYXRhIH0gZnJvbSBcIi4vVVhEYXRhXCI7XHJcbmltcG9ydCB7IEV4dGVuc2lvbk1lc3NhZ2UgfSBmcm9tIFwiLi4vYmFja2dyb3VuZC9XYWNBUElcIjtcclxuXHJcblxyXG4vKipcclxuICogTWVzc2FnZSBmcm9tIGJhY2tncm91bmQgdG8gY29udGVudCBzY3JpcHQuXHJcbiAqL1xyXG5leHBvcnQgZW51bSBDb250ZW50TWVzc2FnZVR5cGUge1xyXG5cdFJFQ09ORklHVVJFID0gXCJyZWNvbmZpZ3VyZVwiLFxyXG5cdFVOSU5JVElBTElaRSA9IFwidW5pbml0aWFsaXplXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIENocm9tZSBvbmx5IG1lc3NhZ2VzIGJldHdlZW4gYmFja2dyb3VuZCBhbmQgY29udGVudCBzY3JpcHRzXHJcbiAqL1xyXG5leHBvcnQgZW51bSBDaHJvbWVDb250ZW50TWVzc2FnZVR5cGUge1xyXG5cdERPQ1VNRU5UX1RJVExFX1VQREFURSA9IFwiZG9jdW1lbnRUaXRsZVVwZGF0ZVwiLFxyXG5cdERPQ1VNRU5UX1RJVExFX1JFUVVFU1QgPSBcImRvY3VtZW50VGl0bGVSZXF1ZXN0XCIsXHJcblx0RE9DVU1FTlRfVElUTEVfUkVTUE9OU0UgPSBcImRvY3VtZW50VGl0bGVSZXNwb25zZVwiXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCYWNrZ3JvdW5kIC0+IENvbnRlbnRcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hyb21lRG9jdW1lbnRUaXRsZVJlcXVlc3Qge1xyXG5cdG1lc3NhZ2VUeXBlOiBDaHJvbWVDb250ZW50TWVzc2FnZVR5cGUuRE9DVU1FTlRfVElUTEVfUkVRVUVTVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnRlbnQgLT4gQmFja2dyb3VuZFxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDaHJvbWVEb2N1bWVudFRpdGxlUmVzcG9uc2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBDaHJvbWVDb250ZW50TWVzc2FnZVR5cGUuRE9DVU1FTlRfVElUTEVfUkVTUE9OU0U7XHJcblx0ZG9jdW1lbnRUaXRsZTogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQmFja2dyb3VuZCAtPiBDb250ZW50XHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENocm9tZURvY3VtZW50VGl0bGVVcGRhdGUge1xyXG5cdG1lc3NhZ2VUeXBlOiBDaHJvbWVDb250ZW50TWVzc2FnZVR5cGUuRE9DVU1FTlRfVElUTEVfVVBEQVRFO1xyXG5cdGRvY3VtZW50VGl0bGU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWVzc2FnZVR5cGUge1xyXG5cdEVWRU5UID0gXCJldmVudFwiLFxyXG5cdExPRyA9IFwibG9nXCIsXHJcblx0V1BNX1BBR0VMT0FEX0VWRU5UID0gXCJ3cG1wYWdlbG9hZGV2ZW50XCIsXHJcblx0V1BNX0VSUk9SX0VWRU5UID0gXCJ3cG1lcnJvcmV2ZW50XCIsXHJcblx0Q09OVEVOVF9TQ1JJUFRfTE9BRCA9IFwiY29udGVudHNjcmlwdGxvYWRcIixcclxuXHRHRVRfU1RBVFVTX0NPREUgPSBcImdldHN0YXR1c2NvZGVcIixcclxuXHRXQUNfRlJPTV9JTkpFQ1RFRCA9IFwiTWVzc2FnZUZyb21JbmplY3RlZFwiLFxyXG5cdFdBQ19UT19JRSA9IFwid2FjMmllXCJcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE1lc3NhZ2VzIGZyb20gY29udGVudCBzY3JpcHQgdG8gYmFja2dyb3VuZFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENPTlRFTlRfTUVTU0FHRVM6IFJlYWRvbmx5QXJyYXk8TWVzc2FnZVR5cGU+ID0gW1xyXG5cdE1lc3NhZ2VUeXBlLldBQ19GUk9NX0lOSkVDVEVELFxyXG5cdE1lc3NhZ2VUeXBlLkNPTlRFTlRfU0NSSVBUX0xPQUQsXHJcblx0TWVzc2FnZVR5cGUuR0VUX1NUQVRVU19DT0RFXHJcbl07XHJcblxyXG5cclxuY29uc3QgSFRUUF9DSFJPTUVfV0VCUEFHRV9QQUdFTE9BRCA9IFwiaHR0cDpjaHJvbWU6V2ViUGFnZS5QYWdlTG9hZFwiO1xyXG5jb25zdCBXUE1fUEFHRV9MT0FEX1VYID0gXCJ3cG06Y2hyb21lOlBhZ2UuTG9hZFwiO1xyXG5leHBvcnQgY29uc3QgV1BNX1BBR0VfRVJST1JfVVggPSBcIndwbTpjaHJvbWU6UGFnZS5FcnJvclwiO1xyXG5leHBvcnQgY29uc3QgTlZfQ0hST01FX1dPUktUSU1FX1ZJT0xBVElPTiA9IFwibnY6Y2hyb21lOldvcmtUaW1lLlZpb2xhdGlvblwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE91dGdvaW5nQmFzZU5hdGl2ZU1lc3NhZ2Uge1xyXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3RvcihwdWJsaWMgbWVzc2FnZVR5cGU6IE1lc3NhZ2VUeXBlLCBwdWJsaWMgdGltZVN0YW1wOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuYnJvd3Nlck5hbWUgPSBicm93c2VySW5mby5uYW1lO1xyXG5cdFx0dGhpcy5icm93c2VyVmVyc2lvbiA9IGJyb3dzZXJJbmZvLnZlcnNpb247XHJcblx0XHR0aGlzLmV4dGVuc2lvblZlcnNpb24gPSBFWFRFTlNJT05fVkVSU0lPTi5nZXRWYWx1ZSgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlYWRvbmx5IGJyb3dzZXJOYW1lOiBzdHJpbmc7XHJcblx0cHVibGljIHJlYWRvbmx5IGJyb3dzZXJWZXJzaW9uOiBzdHJpbmc7XHJcblx0cHVibGljIHJlYWRvbmx5IGV4dGVuc2lvblZlcnNpb246IHN0cmluZztcclxuXHJcblx0cHVibGljIG9yZGVyPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT3V0Z29pbmdQYWdlTmF0aXZlTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nQmFzZU5hdGl2ZU1lc3NhZ2Uge1xyXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3RvcihwdWJsaWMgbWVzc2FnZVR5cGU6IE1lc3NhZ2VUeXBlLCBwdWJsaWMgdGltZVN0YW1wOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKG1lc3NhZ2VUeXBlLCB0aW1lU3RhbXApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRhYklkPzogbnVtYmVyO1xyXG5cdHB1YmxpYyBmcmFtZUlkPzogbnVtYmVyO1xyXG5cdHB1YmxpYyBpc01haW5GcmFtZT86IGJvb2xlYW47XHJcblx0cHVibGljIHdpbmRvd1VybD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPdXRnb2luZ0V2ZW50TWVzc2FnZURhdGE8VCBleHRlbmRzIHt9PiB7XHJcblx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBJbmNvbnNpc3RlbnROYW1pbmdcclxuXHRFdmVudFR5cGU6IHN0cmluZztcclxuXHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIEluY29uc2lzdGVudE5hbWluZ1xyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdERhdGE6IFRbXTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE91dGdvaW5nRXZlbnRNZXNzYWdlPFQgZXh0ZW5kcyBVWERhdGE+IGV4dGVuZHMgT3V0Z29pbmdQYWdlTmF0aXZlTWVzc2FnZSB7XHJcblx0cHVibGljIG1lc3NhZ2VEYXRhOiBPdXRnb2luZ0V2ZW50TWVzc2FnZURhdGE8VD47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGV2ZW50VHlwZTogc3RyaW5nLCB0aW1lU3RhbXA6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoTWVzc2FnZVR5cGUuRVZFTlQsIHRpbWVTdGFtcCk7XHJcblx0XHR0aGlzLm1lc3NhZ2VEYXRhID0ge1xyXG5cdFx0XHRFdmVudFR5cGU6IGV2ZW50VHlwZSxcclxuXHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLWFueVxyXG5cdFx0XHREYXRhOiBbKHt9KSBhcyBhbnkgYXMgVF1cclxuXHRcdH07XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgV2FjT3V0Z29pbmdOYXRpdmVNZXNzYWdlPFQgZXh0ZW5kcyBFeHRlbnNpb25NZXNzYWdlPiBleHRlbmRzIE91dGdvaW5nUGFnZU5hdGl2ZU1lc3NhZ2Uge1xyXG5cdGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB3YWNNZXNzYWdlRGF0YTogVCkge1xyXG5cdFx0c3VwZXIoTWVzc2FnZVR5cGUuV0FDX1RPX0lFLCB0aW1lUHJvdmlkZXIubm93KCkpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXZWJQZXJmb3JtYW5jZVRpbWluZyB7XHJcbi8vIFJlU2hhcnBlciBkaXNhYmxlIEluY29uc2lzdGVudE5hbWluZ1xyXG5cdFJlc3BvbnNlVGltZTogbnVtYmVyO1xyXG5cdEFjdGl2aXR5UmVzcG9uc2U6IG51bWJlcjtcclxuXHRUQ1BDb25uZWN0VGltZTogbnVtYmVyO1xyXG5cdFJlZGlyZWN0VGltZTogbnVtYmVyO1xyXG5cdEROU1RpbWU6IG51bWJlcjtcclxuXHRSZXF1ZXN0VGltZTogbnVtYmVyO1xyXG5cdFByb2Nlc3NpbmdUaW1lOiBudW1iZXI7XHJcblx0TG9hZFRpbWU6IG51bWJlcjtcclxuXHRDbGllbnRUaW1lOiBudW1iZXI7XHJcblx0VG90YWxOZXR3b3JrUmVzcG9uc2VUaW1lOiBudW1iZXI7XHJcbi8vIFJlU2hhcnBlciByZXN0b3JlIEluY29uc2lzdGVudE5hbWluZ1xyXG5cclxuXHRuYXZpZ2F0aW9uU3RhcnQ6IG51bWJlcjtcclxuXHR1bmxvYWRFdmVudFN0YXJ0T2Zmc2V0OiBudW1iZXI7XHJcblx0dW5sb2FkRXZlbnRFbmRPZmZzZXQ6IG51bWJlcjtcclxuXHRyZWRpcmVjdFN0YXJ0T2Zmc2V0OiBudW1iZXI7XHJcblx0cmVkaXJlY3RFbmRPZmZzZXQ6IG51bWJlcjtcclxuXHRmZXRjaFN0YXJ0T2Zmc2V0OiBudW1iZXI7XHJcblx0ZG9tYWluTG9va3VwU3RhcnRPZmZzZXQ6IG51bWJlcjtcclxuXHRkb21haW5Mb29rdXBFbmRPZmZzZXQ6IG51bWJlcjtcclxuXHRjb25uZWN0U3RhcnRPZmZzZXQ6IG51bWJlcjtcclxuXHRjb25uZWN0RW5kT2Zmc2V0OiBudW1iZXI7XHJcblx0c2VjdXJlQ29ubmVjdGlvblN0YXJ0T2Zmc2V0OiBudW1iZXI7XHJcblx0cmVxdWVzdFN0YXJ0T2Zmc2V0OiBudW1iZXI7XHJcblx0cmVzcG9uc2VTdGFydE9mZnNldDogbnVtYmVyO1xyXG5cdHJlc3BvbnNlRW5kT2Zmc2V0OiBudW1iZXI7XHJcblx0ZG9tTG9hZGluZ09mZnNldDogbnVtYmVyO1xyXG5cdGRvbUludGVyYWN0aXZlT2Zmc2V0OiBudW1iZXI7XHJcblx0ZG9tQ29udGVudExvYWRlZEV2ZW50U3RhcnRPZmZzZXQ6IG51bWJlcjtcclxuXHRkb21Db250ZW50TG9hZGVkRXZlbnRFbmRPZmZzZXQ6IG51bWJlcjtcclxuXHRkb21Db21wbGV0ZU9mZnNldDogbnVtYmVyO1xyXG5cdGxvYWRFdmVudFN0YXJ0T2Zmc2V0OiBudW1iZXI7XHJcblx0bG9hZEV2ZW50RW5kT2Zmc2V0OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViUGFnZUNvbnRleHQge1xyXG5cdC8vICNyZWdpb24gQ29udGV4dFxyXG5cclxuXHR1cmw6IHN0cmluZztcclxuXHR0aXRsZTogc3RyaW5nO1xyXG5cclxuXHR0eXBlOiBzdHJpbmc7XHJcblx0c3RhdHVzQ29kZTogbnVtYmVyO1xyXG5cdHRhYklkOiBudW1iZXI7XHJcblx0ZnJhbWVJZDogbnVtYmVyO1xyXG5cclxuXHRkb2N1bWVudFVybDogc3RyaW5nO1xyXG5cdGRvY3VtZW50Q29tbWl0dGVkVXJsOiBzdHJpbmc7XHJcblx0ZG9jdW1lbnRUaXRsZTogc3RyaW5nO1xyXG5cclxuXHQvLyAjZW5kcmVnaW9uXHJcblxyXG5cdC8vICNyZWdpb24gT1BBUlhcclxuXHJcblx0c2VydmVyVVJMOiBzdHJpbmc7XHJcblx0dXNlcklkOiBzdHJpbmc7XHJcblx0cGFnZUlkOiBzdHJpbmc7XHJcblx0YWl4SWQ6IHN0cmluZztcclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG59XHJcblxyXG4vKipcclxuICogY2hyb21lOmh0dHA6V2ViUGFnZS5QYWdlTG9hZFxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBIdHRwV2ViUGFnZUxvYWRFdmVudERhdGEgZXh0ZW5kcyBVWERhdGEsIFdlYlBhZ2VDb250ZXh0IHtcclxuXHQvLyAjcmVnaW9uIFdQTVxyXG5cclxuXHRuYXZpZ2F0aW9uU3RhcnQ6IG51bWJlcjtcclxuXHR1bmxvYWRFdmVudFN0YXJ0VGltZTogbnVtYmVyO1xyXG5cdHVubG9hZEV2ZW50RW5kVGltZTogbnVtYmVyO1xyXG5cdHJlZGlyZWN0U3RhcnRUaW1lOiBudW1iZXI7XHJcblx0cmVkaXJlY3RFbmRUaW1lOiBudW1iZXI7XHJcblx0ZmV0Y2hTdGFydFRpbWU6IG51bWJlcjtcclxuXHRkb21haW5Mb29rdXBTdGFydFRpbWU6IG51bWJlcjtcclxuXHRkb21haW5Mb29rdXBFbmRUaW1lOiBudW1iZXI7XHJcblx0Y29ubmVjdFN0YXJ0VGltZTogbnVtYmVyO1xyXG5cdGNvbm5lY3RFbmRUaW1lOiBudW1iZXI7XHJcblx0c2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZTogbnVtYmVyO1xyXG5cdHJlcXVlc3RTdGFydFRpbWU6IG51bWJlcjtcclxuXHRyZXNwb25zZVN0YXJ0VGltZTogbnVtYmVyO1xyXG5cdHJlc3BvbnNlRW5kVGltZTogbnVtYmVyO1xyXG5cdGRvbUxvYWRpbmdUaW1lOiBudW1iZXI7XHJcblx0ZG9tSW50ZXJhY3RpdmVUaW1lOiBudW1iZXI7XHJcblx0ZG9tQ29udGVudExvYWRlZEV2ZW50U3RhcnRUaW1lOiBudW1iZXI7XHJcblx0ZG9tQ29udGVudExvYWRlZEV2ZW50RW5kVGltZTogbnVtYmVyO1xyXG5cdGRvbUNvbXBsZXRlVGltZTogbnVtYmVyO1xyXG5cdGxvYWRFdmVudFN0YXJ0VGltZTogbnVtYmVyO1xyXG5cdGxvYWRFdmVudEVuZFRpbWU6IG51bWJlcjtcclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG59XHJcblxyXG5pbnRlcmZhY2UgV3BtUGFnZUxvYWRVWEV2ZW50RGF0YSBleHRlbmRzIFVYRGF0YSwgV2ViUGVyZm9ybWFuY2VUaW1pbmcsIFdlYlBhZ2VDb250ZXh0IHtcclxufVxyXG5cclxuaW50ZXJmYWNlIFdwbVBhZ2VFcnJvclVYRXZlbnREYXRhIGV4dGVuZHMgVVhEYXRhLCBXZWJQYWdlQ29udGV4dCB7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRnb2luZ0h0dHBDaHJvbWVXZWJQYWdlTG9hZEV2ZW50TWVzc2FnZSBleHRlbmRzIE91dGdvaW5nRXZlbnRNZXNzYWdlPEh0dHBXZWJQYWdlTG9hZEV2ZW50RGF0YT4ge1xyXG5cdGNvbnN0cnVjdG9yKHRpbWVTdGFtcDogbnVtYmVyKSB7IHN1cGVyKEhUVFBfQ0hST01FX1dFQlBBR0VfUEFHRUxPQUQsIHRpbWVTdGFtcCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE91dGdvaW5nV3BtUGFnZUxvYWRVWE1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ0V2ZW50TWVzc2FnZTxXcG1QYWdlTG9hZFVYRXZlbnREYXRhPiB7XHJcblx0Y29uc3RydWN0b3IoKSB7IHN1cGVyKFdQTV9QQUdFX0xPQURfVVgsIHBlcmZvcm1hbmNlLnRpbWluZy5sb2FkRXZlbnRFbmQpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRnb2luZ1dwbVBhZ2VFcnJvclVYTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nRXZlbnRNZXNzYWdlPFdwbVBhZ2VFcnJvclVYRXZlbnREYXRhPiB7XHJcblx0Y29uc3RydWN0b3IoKSB7IHN1cGVyKFdQTV9QQUdFX0VSUk9SX1VYLCBwZXJmb3JtYW5jZS50aW1pbmcubG9hZEV2ZW50RW5kKTsgfVxyXG59XHJcblxyXG4vLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIEluY29uc2lzdGVudE5hbWluZ1xyXG5leHBvcnQgaW50ZXJmYWNlIE5WV29ya1RpbWVWaW9sYXRpb25FdmVudERhdGEgZXh0ZW5kcyBVWERhdGEge1xyXG5cdGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcblx0YmFja29mZkludGVydmFsOiBudW1iZXI7XHJcblx0bWF4V29ya1RpbWU6IG51bWJlcjtcclxuXHR0aW1lRnJhbWU6IG51bWJlcjtcclxuXHR0b3RhbFJ1bm5pbmdUaW1lOiBudW1iZXI7XHJcblx0dG90YWxTZWxlY3RvcnM6IG51bWJlcjtcclxuXHRwcm9jZXNzZWRTZWxlY3RvcnM6IG51bWJlcjtcclxuXHRsYXN0UHJvY2Vzc2VkU2VsZWN0b3I6IHN0cmluZztcclxuXHRsb25nZXN0U2VsZWN0b3I6IHN0cmluZztcclxuXHRsb25nZXN0U2VsZWN0b3JUaW1lOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vIFJlU2hhcnBlciBkaXNhYmxlIG9uY2UgSW5jb25zaXN0ZW50TmFtaW5nXHJcbmV4cG9ydCBjbGFzcyBPdXRnb2luZ05WV29ya1RpbWVWaW9sYXRpb25VWE1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ0V2ZW50TWVzc2FnZTxOVldvcmtUaW1lVmlvbGF0aW9uRXZlbnREYXRhPiB7XHJcblx0Y29uc3RydWN0b3IobnZWaW9sYXRpb25EYXRhOiBOVldvcmtUaW1lVmlvbGF0aW9uRXZlbnREYXRhKSB7XHJcblx0XHRzdXBlcihOVl9DSFJPTUVfV09SS1RJTUVfVklPTEFUSU9OLCB0aW1lUHJvdmlkZXIubm93KCkpO1xyXG5cdFx0dGhpcy5tZXNzYWdlRGF0YS5EYXRhID0gW2RlZXBDbG9uZShudlZpb2xhdGlvbkRhdGEpIGFzIE5WV29ya1RpbWVWaW9sYXRpb25FdmVudERhdGFdO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE91dGdvaW5nV3BtUGFnZUxvYWRFdmVudE1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ1BhZ2VOYXRpdmVNZXNzYWdlIHtcclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHB1YmxpYyB0aXRsZTogc3RyaW5nLFxyXG5cdFx0cHVibGljIHVybDogc3RyaW5nLFxyXG5cdFx0cHVibGljIHJlc3BvbnNlVGltZTogbnVtYmVyLFxyXG5cdFx0cHVibGljIGFjdGl2aXR5UmVzcG9uc2U6IG51bWJlcixcclxuXHRcdHB1YmxpYyB0Y3BDb25uZWN0VGltZTogbnVtYmVyLFxyXG5cdFx0cHVibGljIHJlZGlyZWN0VGltZTogbnVtYmVyLFxyXG5cdFx0cHVibGljIGRuc1RpbWU6IG51bWJlcixcclxuXHRcdHB1YmxpYyByZXF1ZXN0VGltZTogbnVtYmVyLFxyXG5cdFx0cHVibGljIHByb2Nlc3NpbmdUaW1lOiBudW1iZXIsXHJcblx0XHRwdWJsaWMgbG9hZFRpbWU6IG51bWJlcixcclxuXHRcdHB1YmxpYyB0b3RhbE5ldHdvcmtSZXNwb25zZVRpbWU6IG51bWJlcixcclxuXHRcdHB1YmxpYyB0b3RhbE5ldHdvcmtTZXJ2ZXJUaW1lOiBudW1iZXIsXHJcblx0XHRwdWJsaWMgY2xpZW50VGltZTogbnVtYmVyLFxyXG5cdFx0cHVibGljIHNlcnZlclVSTDogc3RyaW5nLFxyXG5cdFx0cHVibGljIHVzZXJJZDogc3RyaW5nLFxyXG5cdFx0cHVibGljIHBhZ2VJZDogc3RyaW5nLFxyXG5cdFx0cHVibGljIGFpeElkOiBzdHJpbmcpIHtcclxuXHRcdHN1cGVyKE1lc3NhZ2VUeXBlLldQTV9QQUdFTE9BRF9FVkVOVCwgcGVyZm9ybWFuY2UudGltaW5nLmxvYWRFdmVudEVuZCk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0Z29pbmdXcG1FcnJvckV2ZW50TWVzc2FnZSBleHRlbmRzIE91dGdvaW5nUGFnZU5hdGl2ZU1lc3NhZ2Uge1xyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0cHVibGljIHVybDogc3RyaW5nLFxyXG5cdFx0cHVibGljIHRhcmdldEZyYW1lTmFtZTogc3RyaW5nLFxyXG5cdFx0cHVibGljIHN0YXR1c0NvZGU6IG51bWJlcikge1xyXG5cdFx0c3VwZXIoTWVzc2FnZVR5cGUuV1BNX0VSUk9SX0VWRU5ULCBwZXJmb3JtYW5jZS50aW1pbmcubG9hZEV2ZW50RW5kKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRnb2luZ0xvZ01lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ1BhZ2VOYXRpdmVNZXNzYWdlIHtcclxuXHRwdWJsaWMgbGV2ZWw6IExvZ0xldmVsO1xyXG5cdHB1YmxpYyBtZXNzYWdlOiBzdHJpbmc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nKSB7XHJcblx0XHRzdXBlcihNZXNzYWdlVHlwZS5MT0csIHRpbWVQcm92aWRlci5ub3coKSk7XHJcblx0XHR0aGlzLmxldmVsID0gbGV2ZWw7XHJcblx0XHR0aGlzLm1lc3NhZ2UgPSBFWFRFTlNJT05fVkVSU0lPTi5nZXRWYWx1ZSgpICsgXCI6IFwiICsgbWVzc2FnZTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFRpbWUgcHJvdmlkZXIgaW50ZXJmYWNlIGZvciB0ZXN0aW5nIHRoZSBjbGFzc1xyXG4gKiBUaGUgaW50ZXJmYWNlIGlzIGNvbXBhdGlibGUgd2l0aCBSeC5JU2NoZWR1bGVyLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUaW1lUHJvdmlkZXIge1xyXG5cdG5vdygpOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB3aW5kb3cucGVyZm9ybWFuY2Uubm93IHByb3ZpZGVyLlxyXG4gKi9cclxuY29uc3QgcGVyZm9ybWFuY2VOb3dQcm92aWRlcjogVGltZVByb3ZpZGVyID0ge1xyXG5cdG5vdygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBjdXJyZW50IHRpbWUgdXNpbmcgdGhlIGJlc3QgYXZhaWxhYmxlIG9wdGlvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCB0aW1lUHJvdmlkZXI6IFRpbWVQcm92aWRlciA9IHtcclxuXHQvLyBTb21lIElFIG1vZGVzIGRvbid0IGhhdmUgRGF0ZS5ub3cuXHJcblx0bm93OiBEYXRlLm5vdyAhPSBudWxsXHJcblx0XHQ/ICgpOiBudW1iZXIgPT4gRGF0ZS5ub3coKVxyXG5cdFx0OiAoKTogbnVtYmVyID0+IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbn07XHJcblxyXG4vLyBWYWxpZGF0ZSB3aW5kb3cucGVyZm9ybWFuY2UgZXhpc3RzIGFuZCB3b3JraW5nIGNvcnJlY3RseSAoSUUgYnVnICEpXHJcbi8qXHJcblx0Y29uc3QgSEFTX1BFUkZPUk1BTkNFX05PVyA9XHJcblx0d2luZG93LnBlcmZvcm1hbmNlICE9IG51bGwgJiZcclxuXHR3aW5kb3cucGVyZm9ybWFuY2Uubm93ICE9IG51bGwgJiZcclxuXHR3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgIT09IEluZmluaXR5O1xyXG5cdCovXHJcblxyXG4vKipcclxuICogVGltZSBwcm92aWRlciBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zLlxyXG4gKiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IHJldHVybnMgdGhlIGN1cnJlbnQgdGltZS5cclxuICpcclxuICogcGVyZm9ybWFuY2Uubm93IGlzIHRvbyBzbG93IGluIElFLCB1c2luZyBpbmFjY3VyYXRlIHRpbWVQcm92aWRlciBub3cuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVsYXRpdmVUaW1lUHJvdmlkZXIgPSB0aW1lUHJvdmlkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gaW1wb3J0IHsgY2hyb21lIH0gZnJvbSBcIi4vZ2xvYmFsQ2hyb21lXCI7XHJcbmltcG9ydCB7IExhenkgfSBmcm9tIFwiLi4vdXRpbHMvbGF6eVwiO1xyXG5cclxuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xyXG5cdFRSQUNFID0gNixcclxuXHRERUJVRyA9IDUsXHJcblx0SU5GTyA9IDQsXHJcblx0V0FSTiA9IDMsXHJcblx0RVJST1IgPSAyLFxyXG5cdEZBVEFMID0gMVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgRVhURU5TSU9OX1ZFUlNJT04gPSBuZXcgTGF6eSgoKSA9PiBjaHJvbWUucnVudGltZS5nZXRNYW5pZmVzdCgpLnZlcnNpb24pO1xyXG5cclxuLyoqXHJcbiAqIEtleSBuYW1lIGRlbGltaXRlciBmb3IgbmVzdGVkIHN0cnVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBLRVlfREVMSU1JVEVSID0gXCIuXCI7XHJcblxyXG4vKipcclxuICogUmVwb3J0IGV2ZXJ5dGhpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUkVQT1JUX0VWRVJZVEhJTkcgPSBcIkV2ZXJ5dGhpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBXZWJSZXF1ZXN0IGV2ZW50IHJlZ2V4LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFdFQlJFUVVFU1RfRVZFTlRfUkUgPSAvXmh0dHBcXDpjaHJvbWVcXDpXZWJSZXF1ZXN0LztcclxuZXhwb3J0IGNvbnN0IFdFQlJFUVVFU1RfRVZFTlRfTkFNRVNQQUNFID0gXCJodHRwOmNocm9tZTpXZWJSZXF1ZXN0XCI7XHJcblxyXG4vKipcclxuICogUmVxdWlyZWQgcHJvcGVydGllcyBpbiBXZWJSZXF1ZXN0IGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBXRUJSRVFVRVNUX1JFUVVJUkVEX1BST1BFUlRJRVM6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHlBcnJheTxzdHJpbmc+PiA9IFtcclxuXHRbXCJkb2N1bWVudFVybFwiLCBcInR5cGVcIl0sXHJcblx0W1wiZG9jdW1lbnRDb21taXR0ZWRVcmxcIiwgXCJ0eXBlXCJdXHJcbl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZXhwb3J0IHR5cGUgQ2FuYmVMYXp5PFQ+ID0gVCB8IExhenk8VD47XHJcblxyXG4vLyBIYWNrIHRvIGltaXRhdGUgZ2V0dGVycyB3aGljaCBkb24ndCBleGlzdCBpbiBvbGQgSUVcclxudHlwZSBNdXRhYmxlTGF6eSA9IHsgaGFzVmFsdWU6IGJvb2xlYW47IH07XHJcblxyXG5leHBvcnQgY2xhc3MgTGF6eTxUPiB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBnZW5lcmF0b3I/OiAoKSA9PiBUO1xyXG5cdHByaXZhdGUgdmFsdWU/OiBUO1xyXG5cdHB1YmxpYyByZWFkb25seSBoYXNWYWx1ZTogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoZ2VuZXJhdG9yT3JWYWx1ZTogKCgpID0+IFQpIHwgVCkge1xyXG5cdFx0aWYgKHR5cGVvZiBnZW5lcmF0b3JPclZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0dGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3JPclZhbHVlIGFzICgoKSA9PiBUKTtcclxuXHRcdFx0dGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy52YWx1ZSA9IGdlbmVyYXRvck9yVmFsdWU7XHJcblx0XHRcdHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldFZhbHVlKCk6IFQge1xyXG5cdFx0Ly8gdHNsaW50OmRpc2FibGUgbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcblx0XHRpZiAoIXRoaXMuaGFzVmFsdWUpIHtcclxuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2VuZXJhdG9yISgpO1xyXG5cdFx0XHQodGhpcyBhcyBNdXRhYmxlTGF6eSkuaGFzVmFsdWUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUhO1xyXG5cdFx0Ly8gdHNsaW50OmVuYWJsZSBuby1ub24tbnVsbC1hc3NlcnRpb25cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbTxVPih2YWx1ZTogVSk6IExhenk8VT4ge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXp5KHZhbHVlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4dHJhY3QgdmFsdWUgZWl0aGVyIGZyb20gaW1tZWRpYXRlIG9yIGZyb20gbGF6eS5cclxuXHQgKi9cclxuXHRwdWJsaWMgc3RhdGljIGV4dHJhY3Q8VT4oY2FuYmVMYXp5OiBDYW5iZUxhenk8VT4pOiBVIHtcclxuXHRcdGlmIChjYW5iZUxhenkgaW5zdGFuY2VvZiBMYXp5KSB7XHJcblx0XHRcdC8vIFJlU2hhcnBlciBkaXNhYmxlIG9uY2UgVHNSZXNvbHZlZEZyb21JbmFjY2Vzc2libGVNb2R1bGVcclxuXHRcdFx0cmV0dXJuIGNhbmJlTGF6eS5nZXRWYWx1ZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGNhbmJlTGF6eTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi9sb2dcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IHsgTGF6eSwgQ2FuYmVMYXp5IH0gZnJvbSBcIi4vbGF6eVwiO1xyXG5cclxuLy8gLk5FVCBzdHlsZSBmb3IgY2FzZSBpbnNlbnNpdGl2ZSBvcHRpb25cclxuY29uc3QgRE9UTkVUX0NBU0VfSU5TRU5TSVRJVkUgPSAvXihcXF4/KVxcKFxcP2lcXCkoXFxePykoLiopLztcclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWRSZWdleChwYXR0ZXJuOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHR0cnkge1xyXG5cdFx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBXcm9uZ0V4cHJlc3Npb25TdGF0ZW1lbnRcclxuXHRcdC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbiovXHJcblx0XHRuZXcgUmVnRXhwKHBhdHRlcm4pO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvblwiLCBwYXR0ZXJuKTtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWwgY2xhc3MgZm9yIG9wdGltaXplZCByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hpbmcuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVnRXhwTWF0Y2hlciB7XHJcblx0LyoqIENhc2Ugc2Vuc2l0aXZlIHBhdHRlcm4uICovXHJcblx0cHJpdmF0ZSBtdWx0aVBhdHRlcm4/OiBzdHJpbmc7XHJcblx0LyoqIENhc2Ugc2Vuc2l0aXZlIHJlZ3VsYXIgZXhwcmVzc2lvbi4gKi9cclxuXHRwcml2YXRlIHJlZ2V4TWF0Y2hlcj86IFJlZ0V4cDtcclxuXHJcblx0LyoqIENhc2UgaW5zZW5zaXRpdmUgcGF0dGVybi4gKi9cclxuXHRwcml2YXRlIGltdWx0aVBhdHRlcm4/OiBzdHJpbmc7XHJcblx0LyoqIENhc2UgaW5zZW5zaXRpdmUgcmVndWxhciBleHByZXNzaW9uLiAgKi9cclxuXHRwcml2YXRlIGlyZWdleE1hdGNoZXI/OiBSZWdFeHA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwYXJhbSBwYXR0ZXJuIFBhdHRlcm4gdG8gbWF0Y2guXHJcblx0ICogQHBhcmFtIGlzRXhhY3QgV2hldGhlciB0byB1c2UgZXhhY3QgbWF0Y2ggb3IgZXF1YWxpdHlcclxuXHQgKiBAcGFyYW0gY2FzZUluc2Vuc2l0aXZlIEZvcmNlIGNhc2UgaW5zZW5zaXRpdmUgcGF0dGVybi4gVmFsaWQgb25seSBpZiBpc0V4YWN0IGlzIGZhbHNlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBhZGRNYXRjaGVyKHBhdHRlcm46IHN0cmluZywgaXNFeGFjdDogYm9vbGVhbiwgY2FzZUluc2Vuc2l0aXZlOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuXHRcdGlmIChpc0V4YWN0KSB7XHJcblx0XHRcdHRoaXMubXVsdGlQYXR0ZXJuID1cclxuXHRcdFx0XHRSZWdFeHBNYXRjaGVyLmFkZE11bHRpUGF0dGVybih0aGlzLm11bHRpUGF0dGVybiwgYF4ke1V0aWxzLmVzY2FwZVJlZ0V4cChwYXR0ZXJuKX0kYCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBIYW5kbGUgY2FzZSBpbnNlbnNpdGl2ZSBvcHRpb25cclxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gcGF0dGVybi5tYXRjaChET1RORVRfQ0FTRV9JTlNFTlNJVElWRSk7XHJcblx0XHRcdGNvbnN0IGljYXNlID0gZ3JvdXBzICE9IG51bGwgPyAoZ3JvdXBzWzFdICE9PSBcIlwiID8gZ3JvdXBzWzFdIDogZ3JvdXBzWzJdKSA6IFwiXCI7XHJcblx0XHRcdGNvbnN0IG1hdGNoUGF0dGVybiA9IGdyb3VwcyAhPSBudWxsID8gKGljYXNlICsgZ3JvdXBzWzNdKSA6IHBhdHRlcm47XHJcblxyXG5cdFx0XHQvLyBUZXN0IHJlZ3VsYXIgZXhwcmVzc2lvblxyXG5cdFx0XHRpZiAoIWlzVmFsaWRSZWdleChtYXRjaFBhdHRlcm4pKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoZ3JvdXBzICE9IG51bGwgfHwgY2FzZUluc2Vuc2l0aXZlKSB7XHJcblx0XHRcdFx0Ly8gU3RvcmUgcHJldmlvdXMgdmFsdWVcclxuXHRcdFx0XHRjb25zdCBwcmV2aU11bHRpUGF0dGVybiA9IHRoaXMuaW11bHRpUGF0dGVybjtcclxuXHRcdFx0XHQvLyBHZXQgbmV3IHBhdHRlcm5cclxuXHRcdFx0XHRjb25zdCBuZXdJTXVsdGlQYXR0ZXJuID0gUmVnRXhwTWF0Y2hlci5hZGRNdWx0aVBhdHRlcm4odGhpcy5pbXVsdGlQYXR0ZXJuLCBtYXRjaFBhdHRlcm4pO1xyXG5cclxuXHRcdFx0XHQvLyBJZiByZWdleCBpcyBub3QgdmFsaWQsIHJlc3RvcmUgcHJldmlvdXMgdmFsdWVcclxuXHRcdFx0XHRpZiAoaXNWYWxpZFJlZ2V4KG5ld0lNdWx0aVBhdHRlcm4pKSB7XHJcblx0XHRcdFx0XHQvLyBVcGRhdGUgcGF0dGVybiBhbmQgY2xlYXIgY2FjaGVcclxuXHRcdFx0XHRcdHRoaXMuaW11bHRpUGF0dGVybiA9IG5ld0lNdWx0aVBhdHRlcm47XHJcblx0XHRcdFx0XHR0aGlzLmlyZWdleE1hdGNoZXIgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuaW11bHRpUGF0dGVybiA9IHByZXZpTXVsdGlQYXR0ZXJuO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBTdG9yZSBwcmV2aW91cyB2YWx1ZVxyXG5cdFx0XHRcdGNvbnN0IHByZXZNdWx0aVBhdHRlcm4gPSB0aGlzLm11bHRpUGF0dGVybjtcclxuXHRcdFx0XHQvLyBHZXQgbmV3IHBhdHRlcm5cclxuXHRcdFx0XHRjb25zdCBuZXdNdWx0aVBhdHRlcm4gPSBSZWdFeHBNYXRjaGVyLmFkZE11bHRpUGF0dGVybih0aGlzLm11bHRpUGF0dGVybiwgbWF0Y2hQYXR0ZXJuKTtcclxuXHJcblx0XHRcdFx0Ly8gSWYgcmVnZXggaXMgbm90IHZhbGlkLCByZXN0b3JlIHByZXZpb3VzIHZhbHVlXHJcblx0XHRcdFx0aWYgKGlzVmFsaWRSZWdleChuZXdNdWx0aVBhdHRlcm4pKSB7XHJcblx0XHRcdFx0XHQvLyBVcGRhdGUgcGF0dGVybiBhbmQgY2xlYXIgY2FjaGVcclxuXHRcdFx0XHRcdHRoaXMubXVsdGlQYXR0ZXJuID0gbmV3TXVsdGlQYXR0ZXJuO1xyXG5cdFx0XHRcdFx0dGhpcy5yZWdleE1hdGNoZXIgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMubXVsdGlQYXR0ZXJuID0gcHJldk11bHRpUGF0dGVybjtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGFkZE11bHRpUGF0dGVybihtdWx0aVBhdHRlcm46IHN0cmluZyB8IHVuZGVmaW5lZCwgbWF0Y2hQYXR0ZXJuOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIChtdWx0aVBhdHRlcm4gPT0gbnVsbCA/IFwiXCIgOiBtdWx0aVBhdHRlcm4gKyBcInxcIikgKyBtYXRjaFBhdHRlcm47XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNNYXRjaChpbnB1dDogQ2FuYmVMYXp5PHN0cmluZz4pOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLm11bHRpUGF0dGVybiAhPSBudWxsKSB7XHJcblx0XHRcdGlmICh0aGlzLnJlZ2V4TWF0Y2hlciA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy5yZWdleE1hdGNoZXIgPSBuZXcgUmVnRXhwKHRoaXMubXVsdGlQYXR0ZXJuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMucmVnZXhNYXRjaGVyLnRlc3QoTGF6eS5leHRyYWN0KGlucHV0KSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmltdWx0aVBhdHRlcm4gIT0gbnVsbCkge1xyXG5cdFx0XHRpZiAodGhpcy5pcmVnZXhNYXRjaGVyID09IG51bGwpIHtcclxuXHRcdFx0XHR0aGlzLmlyZWdleE1hdGNoZXIgPSBuZXcgUmVnRXhwKHRoaXMuaW11bHRpUGF0dGVybiwgXCJpXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmlyZWdleE1hdGNoZXIudGVzdChMYXp5LmV4dHJhY3QoaW5wdXQpKSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGhhc01hdGNoZXIoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aVBhdHRlcm4gIT0gbnVsbCB8fCB0aGlzLmltdWx0aVBhdHRlcm4gIT0gbnVsbDtcclxuXHR9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBCcm93c2VyVHlwZSB9IGZyb20gXCIuLi9iYWNrZ3JvdW5kL1dhY0FQSVwiO1xyXG5cclxuXHJcbmludGVyZmFjZSBJQnJvd3NlckluZm8ge1xyXG5cdG5hbWU6IEJyb3dzZXJUeXBlO1xyXG5cdHZlcnNpb246IHN0cmluZztcclxuXHRtYWpvcjogbnVtYmVyO1xyXG5cdG1pbm9yOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vIHRzbGludDpkaXNhYmxlIG1heC1saW5lLWxlbmd0aFxyXG5cclxuLyogQ2hyb21lIFVzZXJBZ2VudDpcclxuICogXCJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xMV81KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNTEuMC4yNzA0LjEwNiBTYWZhcmkvNTM3LjM2XCJcclxuICogXCJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjE7IFdPVzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNTAuMC4yNjYxLjEwMiBTYWZhcmkvNTM3LjM2XCJcclxuICogXCJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzEuMC4zNTc4Ljk4IFNhZmFyaS81MzcuMzZcIlxyXG4gKiBDaHJvbWUgQXBwVmVyc2lvbjpcclxuICogXCI1LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzcxLjAuMzU3OC45OCBTYWZhcmkvNTM3LjM2XCJcclxuICovXHJcbmNvbnN0IENIUk9NRV9WRVJTSU9OID0gL0Nocm9tZVxcLygoWzAtOV0rKVxcLihbMC05XSspXFwuKFsuMC05XSspKS87XHJcblxyXG4vKiBTYWZhcmkgVXNlckFnZW50OlxyXG4gKiBcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzExXzUpIEFwcGxlV2ViS2l0LzYwMS42LjE3IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi85LjEuMSBTYWZhcmkvNjAxLjYuMTdcIlxyXG4gKiBcIk1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE0XzEpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMi4wLjEgU2FmYXJpLzYwNS4xLjE1XCJcclxuICogU2FmYXJpIEFwcFZlcnNpb246XHJcbiAqIFwiNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE0XzEpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMi4wLjEgU2FmYXJpLzYwNS4xLjE1XCJcclxuICovXHJcbmNvbnN0IFNBRkFSSV9WRVJTSU9OID0gL1ZlcnNpb25cXC8oKFswLTldKVxcLihbMC05XSlcXC4oWy4wLTldKykpXFxzK1NhZmFyaS87XHJcblxyXG4vKlxyXG4gKiBGaXJlZm94IFVzZXJBZ2VudDpcclxuICogXCJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFdpbjY0OyB4NjQ7IHJ2OjYwLjApIEdlY2tvLzIwMTAwMTAxIEZpcmVmb3gvNjAuMFwiXHJcbiAqIFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NDsgcnY6NjMuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC82My4wXCJcclxuICovXHJcbmNvbnN0IEZJUkVGT1hfVkVSU0lPTiA9IC9GaXJlZm94XFwvKChbMC05XSspXFwuKFswLTldKykpLztcclxuXHJcbi8qXHJcbiAqIENocm9taXVtIEVkZ2UgVXNlckFnZW50ICh0aGUgbmV3IENocm9taXVtIEVkZ2UgaW50cm9kdWNlZCBvbiAwMS8yMDIwKTpcclxuICogXCJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYgRWRnLzgwLjAuMzYxLjUwXCJcclxuICogQ2hyb21pdW0gRWRnZSBBcHBWZXJzaW9uOlxyXG4gKiBcIjUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYgRWRnLzgwLjAuMzYxLjUwXCJcclxuICovXHJcbmNvbnN0IENIUk9NSVVNX0VER0VfVkVSU0lPTiA9IC9FZGdcXC8oKFswLTldKylcXC4oWzAtOV0rKVxcLihbLjAtOV0rKSkvO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlckluZm8obmFtZTogQnJvd3NlclR5cGUsIG1hdGNoZXM6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPik6IElCcm93c2VySW5mbyB7XHJcblx0Y29uc3QgbWFqb3IgPSBtYXRjaGVzWzJdO1xyXG5cdGNvbnN0IG1pbm9yID0gbWF0Y2hlc1szXTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdG5hbWUsXHJcblx0XHR2ZXJzaW9uOiBtYXRjaGVzWzFdLFxyXG5cdFx0bWFqb3I6IHBhcnNlSW50KG1ham9yLCAxMCksXHJcblx0XHRtaW5vcjogcGFyc2VJbnQobWlub3IsIDEwKVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJuIEJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvbiBleHRyYWN0ZWQgZnJvbSBhcHBWZXJzaW9uIHN0cmluZyBvciB1c2VyQWdlbnQgc3RyaW5nLCBvYnRhaW5lZCBmcm9tIHRoZSB3aW5kb3cubmF2aWdhdG9yIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCcm93c2VySW5mbyhhcHBWZXJzaW9uOiBzdHJpbmcsIHVzZXJBZ2VudDogc3RyaW5nKTogSUJyb3dzZXJJbmZvIHtcclxuXHQvLyBUaGUgQ2hyb21pdW0gRWRnZSByZWdleCBzaG91bGQgYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBDaHJvbWUgYW5kIHRoZSBTYWZhcmkgcmVnZXgsIGFzIGl0cyBVc2VyIEFnZW50IGFuZCBBcHAgVmVyc2lvbiBzdHJpbmdzIGNvbnRhaW4gdGhlIGxhdGVyLlxyXG5cdC8vIGNvbnN0IG1hdGNoZXMgPSBDSFJPTUlVTV9FREdFX1ZFUlNJT04uZXhlYyhhcHBWZXJzaW9uKTtcclxuXHQvKlxyXG5cdGlmIChtYXRjaGVzICE9IG51bGwpIHtcclxuXHRcdHJldHVybiBjcmVhdGVCcm93c2VySW5mbyhCcm93c2VyVHlwZS5FZGdlLCBtYXRjaGVzKTtcclxuXHR9XHJcblx0Ki9cclxuXHRjb25zdCBtYXRjaGVzID0gQ0hST01FX1ZFUlNJT04uZXhlYyhhcHBWZXJzaW9uKTtcclxuXHRpZiAobWF0Y2hlcyAhPSBudWxsKSB7XHJcblx0XHRyZXR1cm4gY3JlYXRlQnJvd3NlckluZm8oQnJvd3NlclR5cGUuQ2hyb21lLCBtYXRjaGVzKTtcclxuXHR9XHJcblx0LypcclxuXHRtYXRjaGVzID0gU0FGQVJJX1ZFUlNJT04uZXhlYyhhcHBWZXJzaW9uKTtcclxuXHRpZiAobWF0Y2hlcyAhPSBudWxsKSB7XHJcblx0XHRyZXR1cm4gY3JlYXRlQnJvd3NlckluZm8oQnJvd3NlclR5cGUuU2FmYXJpLCBtYXRjaGVzKTtcclxuXHR9XHJcblxyXG5cdG1hdGNoZXMgPSBGSVJFRk9YX1ZFUlNJT04uZXhlYyh1c2VyQWdlbnQpO1xyXG5cdGlmIChtYXRjaGVzICE9IG51bGwpIHtcclxuXHRcdHJldHVybiBjcmVhdGVCcm93c2VySW5mbyhCcm93c2VyVHlwZS5GaXJlZm94LCBtYXRjaGVzKTtcclxuXHR9XHJcblx0Ki9cclxuXHRyZXR1cm4gY3JlYXRlQnJvd3NlckluZm8oQnJvd3NlclR5cGUuTkEsIFtcIlwiLCBcIjAuMC4wLjBcIiwgXCIwXCIsIFwiMFwiXSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKG5hdmlnYXRvci5hcHBWZXJzaW9uLCBuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuIiwiaW1wb3J0IHsgZGVlcEZyZWV6ZSB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xyXG5pbXBvcnQgeyBCYWNrZ3JvdW5kUGFnZUluZm9ybWF0aW9uIH0gZnJvbSBcIi4vUGFnZUluZm9ybWF0aW9uXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb3BlcnR5TWF0Y2gge1xyXG5cdC8vIFJlU2hhcnBlciBkaXNhYmxlIEluY29uc2lzdGVudE5hbWluZ1xyXG5cdFZhbHVlOiBzdHJpbmc7XHJcblx0TWF0Y2hUeXBlOiBzdHJpbmc7XHJcblx0Ly8gUmVTaGFycGVyIHJlc3RvcmUgSW5jb25zaXN0ZW50TmFtaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uZGl0aW9uT2JqZWN0IHtcclxuXHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBJbmNvbnNpc3RlbnROYW1pbmdcclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgcmVhZG9ubHktYXJyYXlcclxuXHRDb25kaXRpb25zOiB7IFtwcm9wZXJ0eTogc3RyaW5nXTogUHJvcGVydHlNYXRjaFtdOyB9O1xyXG5cdC8vIFJlU2hhcnBlciByZXN0b3JlIEluY29uc2lzdGVudE5hbWluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRvbmx5Q29uZGl0aW9uT2JqZWN0IHtcclxuXHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBJbmNvbnNpc3RlbnROYW1pbmdcclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgcmVhZG9ubHktYXJyYXlcclxuXHRyZWFkb25seSBDb25kaXRpb25zOiB7IHJlYWRvbmx5IFtwcm9wZXJ0eTogc3RyaW5nXTogUmVhZG9ubHlBcnJheTxQcm9wZXJ0eU1hdGNoPjsgfTtcclxuXHQvLyBSZVNoYXJwZXIgcmVzdG9yZSBJbmNvbnNpc3RlbnROYW1pbmdcclxufVxyXG5cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uZGl0aW9uc1BlckV2ZW50IHsgW2V2ZW50TmFtZTogc3RyaW5nXTogQ29uZGl0aW9uT2JqZWN0W107IH1cclxuZXhwb3J0IGludGVyZmFjZSBFdmVudHNQZXJQcm9wZXJ0eVZhbHVlIHsgW3Byb3BlcnR5TWF0Y2hlcjogc3RyaW5nXTogQ29uZGl0aW9uc1BlckV2ZW50OyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uc29saWRhdGVkRXZlbnRDb25maWcgeyBbY29uc29saWRhdGlvblByb3BlcnR5TmFtZTogc3RyaW5nXTogRXZlbnRzUGVyUHJvcGVydHlWYWx1ZTsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSZWFkb25seUNvbmRpdGlvbnNQZXJFdmVudCB7IHJlYWRvbmx5IFtldmVudE5hbWU6IHN0cmluZ106IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHlDb25kaXRpb25PYmplY3Q+OyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVhZG9ubHlFdmVudHNQZXJQcm9wZXJ0eVZhbHVlIHsgcmVhZG9ubHkgW3Byb3BlcnR5TWF0Y2hlcjogc3RyaW5nXTogUmVhZG9ubHlDb25kaXRpb25zUGVyRXZlbnQ7IH1cclxuZXhwb3J0IGludGVyZmFjZSBSZWFkb25seUNvbnNvbGlkYXRlZEV2ZW50Q29uZmlnIHsgcmVhZG9ubHkgW2NvbnNvbGlkYXRpb25Qcm9wZXJ0eU5hbWU6IHN0cmluZ106IFJlYWRvbmx5RXZlbnRzUGVyUHJvcGVydHlWYWx1ZTsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXb3JrVGltZVRocmVzaG9sZCB7XHJcblx0Ly8gUmVTaGFycGVyIGRpc2FibGUgSW5jb25zaXN0ZW50TmFtaW5nXHJcblx0V29ya1RpbWU6IG51bWJlcjtcclxuXHRUaW1lRnJhbWU6IG51bWJlcjtcclxuXHQvLyBSZVNoYXJwZXIgcmVzdG9yZSBJbmNvbnNpc3RlbnROYW1pbmdcclxufVxyXG5cclxuLyoqXHJcbiAqIE11c3QgbWF0Y2ggbmFtZXMgaW4gdGhlIEFnZW50ICFcclxuICpcclxuICogTXVzdCBiZSBzeW5jaHJvbml6ZWQgd2l0aCBIdG1sQ29uZmlndXJhdGlvbkRhdGEuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ3VyYXRpb25EYXRhIHtcclxuXHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBJbmNvbnNpc3RlbnROYW1pbmdcclxuXHRDb25maWd1cmF0aW9uVmVyc2lvbjogbnVtYmVyO1xyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdFdQTURvY3VtZW50VXJsRmlsdGVyc0xpc3Q6IEFycmF5PHN0cmluZz47XHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0V1BNQ29tbWl0dGVkVXJsRmlsdGVyc0xpc3Q6IEFycmF5PHN0cmluZz47XHJcblx0LyoqXHJcblx0ICogVVJMIGZpbHRlciBsaXN0IGZvciBodHRwOmNocm9tZTpXZWJQYWdlLlBhZ2VMb2FkLlxyXG5cdCAqL1xyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdEZ1bGxXcG1GaWx0ZXJzTGlzdDogQXJyYXk8c3RyaW5nPjtcclxuXHRNYXhQcm9wZXJ0eUxlbmd0aDogbnVtYmVyO1xyXG5cdFZpc2liaWxpdHlNb25pdG9yaW5nSW50ZXJ2YWxNczogbnVtYmVyO1xyXG5cdEVsZW1lbnRzRGlzY292ZXJ5SW50ZXJ2YWxNczogbnVtYmVyO1xyXG5cdEJhY2tvZmZHcmFjZVBlcmlvZE1zOiBudW1iZXI7XHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0V29ya1RpbWVUaHJlc2hvbGRzOiBBcnJheTxXb3JrVGltZVRocmVzaG9sZD47XHJcblx0RXZlbnRDb25maWc6IENvbmRpdGlvbnNQZXJFdmVudDtcclxuXHRDb25zb2xpZGF0ZWRFdmVudENvbmZpZzogQ29uc29saWRhdGVkRXZlbnRDb25maWc7XHJcblx0Ly8gUmVTaGFycGVyIHJlc3RvcmUgSW5jb25zaXN0ZW50TmFtaW5nXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNdXN0IG1hdGNoIG5hbWVzIGluIHRoZSBBZ2VudCAhXHJcbiAqXHJcbiAqIE11c3QgYmUgc3luY2hyb25pemVkIHdpdGggSHRtbENvbmZpZ3VyYXRpb25EYXRhLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhIHtcclxuXHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBJbmNvbnNpc3RlbnROYW1pbmdcclxuXHRyZWFkb25seSBDb25maWd1cmF0aW9uVmVyc2lvbjogbnVtYmVyO1xyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdHJlYWRvbmx5IFdQTURvY3VtZW50VXJsRmlsdGVyc0xpc3Q6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjtcclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgcmVhZG9ubHktYXJyYXlcclxuXHRyZWFkb25seSBXUE1Db21taXR0ZWRVcmxGaWx0ZXJzTGlzdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+O1xyXG5cdC8qKlxyXG5cdCAqIFVSTCBmaWx0ZXIgbGlzdCBmb3IgaHR0cDpjaHJvbWU6V2ViUGFnZS5QYWdlTG9hZC5cclxuXHQgKi9cclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgcmVhZG9ubHktYXJyYXlcclxuXHRyZWFkb25seSBGdWxsV3BtRmlsdGVyc0xpc3Q6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjtcclxuXHRyZWFkb25seSBNYXhQcm9wZXJ0eUxlbmd0aDogbnVtYmVyO1xyXG5cdHJlYWRvbmx5IFZpc2liaWxpdHlNb25pdG9yaW5nSW50ZXJ2YWxNczogbnVtYmVyO1xyXG5cdHJlYWRvbmx5IEVsZW1lbnRzRGlzY292ZXJ5SW50ZXJ2YWxNczogbnVtYmVyO1xyXG5cdHJlYWRvbmx5IEJhY2tvZmZHcmFjZVBlcmlvZE1zOiBudW1iZXI7XHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0cmVhZG9ubHkgV29ya1RpbWVUaHJlc2hvbGRzOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PFdvcmtUaW1lVGhyZXNob2xkPj47XHJcblx0cmVhZG9ubHkgRXZlbnRDb25maWc6IFJlYWRvbmx5Q29uZGl0aW9uc1BlckV2ZW50O1xyXG5cdHJlYWRvbmx5IENvbnNvbGlkYXRlZEV2ZW50Q29uZmlnOiBSZWFkb25seUNvbnNvbGlkYXRlZEV2ZW50Q29uZmlnO1xyXG5cdC8vIFJlU2hhcnBlciByZXN0b3JlIEluY29uc2lzdGVudE5hbWluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdwbVBhcmFtZXRlcnMge1xyXG5cdC8qKiBXUE0gdXNpbmcgSFRNTCBjYXJ0cmlkZ2UgKi9cclxuXHR3cG06IGJvb2xlYW47XHJcblx0LyoqIFdQTSB1c2luZyBVWCBjYXJ0cmlkZ2UgaHR0cDpjaHJvbWUgZXZlbnQgKi9cclxuXHRodHRwV2ViUGFnZUxvYWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJhbWV0ZXJzIHBhc3NlZCB0byBjb250ZW50IHNjcmlwdC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudFNjcmlwdFBhcmFtZXRlcnMge1xyXG5cdGNvbmZpZ3VyYXRpb25EYXRhOiBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhO1xyXG5cdHBhZ2VJbmZvcm1hdGlvbjogQmFja2dyb3VuZFBhZ2VJbmZvcm1hdGlvbjtcclxuXHRzdGF0dXNDb2RlPzogbnVtYmVyO1xyXG5cdHdwbVBhcmFtZXRlcnM6IFdwbVBhcmFtZXRlcnM7XHJcblx0LyoqXHJcblx0ICogRG9jdW1lbnQgdGl0bGUuXHJcblx0ICogSWdub3JlZCBieSBmcmFtZXMgdGhhdCBhcmUgaW4gdGhlIHNhbWUgZG9tYWluLCBzaW5jZSB0aGV5IGNhbiBhY2Nlc3MgdG9wIGZyYW1lIHRpdGxlIGRpcmVjdGx5LlxyXG5cdCAqL1xyXG5cdGRvY3VtZW50VGl0bGU/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV3BtU3RhdHVzQ29kZVJlc3BvbnNlIHtcclxuXHRzdGF0dXNDb2RlOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIHZlcnNpb24gZm9ybWF0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENPTkZJR1VSQVRJT05fVkVSU0lPTiA9IDI7XHJcblxyXG5leHBvcnQgY29uc3QgVklTSUJJTElUWV9NT05JVE9SSU5HX0lOVEVSVkFMX01TID0gMzAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IEVMRU1FTlRTX0RJU0NPVkVSWV9JTlRFUlZBTF9NUyA9IDE1MDA7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9CQUNLT0ZGX0dSQUNFX1BFUklPRCA9IDEwMDA7XHJcblxyXG5leHBvcnQgY29uc3QgTUFYX1BST1BFUlRZX0xFTkdUSCA9IDI1NjtcclxuXHJcbmNvbnN0IFdPUktUSU1FX1RIUkVTSE9MRF9BTExPV19BTEwgPSBbeyBXb3JrVGltZTogMTAwMDAwMCwgVGltZUZyYW1lOiAxMDAwMDAwIH1dO1xyXG5cclxuZnVuY3Rpb24gbWFrZU11dGFibGVEZWZhdWx0Q29uZmlndXJhdGlvbihcclxuXHR3cG1Vcmw6IHN0cmluZyxcclxuXHRldmVudENvbmZpZzogQ29uZGl0aW9uc1BlckV2ZW50LFxyXG5cdGFsbG93RXZlbnRzOiBib29sZWFuKTogQ29uZmlndXJhdGlvbkRhdGEge1xyXG5cclxuXHRjb25zdCByZXQ6IENvbmZpZ3VyYXRpb25EYXRhID0ge1xyXG5cdFx0Q29uZmlndXJhdGlvblZlcnNpb246IENPTkZJR1VSQVRJT05fVkVSU0lPTixcclxuXHRcdE1heFByb3BlcnR5TGVuZ3RoOiBNQVhfUFJPUEVSVFlfTEVOR1RILFxyXG5cdFx0V1BNRG9jdW1lbnRVcmxGaWx0ZXJzTGlzdDogW3dwbVVybF0sXHJcblx0XHRXUE1Db21taXR0ZWRVcmxGaWx0ZXJzTGlzdDogW3dwbVVybF0sXHJcblx0XHRGdWxsV3BtRmlsdGVyc0xpc3Q6IFt3cG1VcmxdLFxyXG5cdFx0RXZlbnRDb25maWc6IGV2ZW50Q29uZmlnLFxyXG5cdFx0V29ya1RpbWVUaHJlc2hvbGRzOiBhbGxvd0V2ZW50cyA/IFdPUktUSU1FX1RIUkVTSE9MRF9BTExPV19BTEwgOiBbXSxcclxuXHRcdENvbnNvbGlkYXRlZEV2ZW50Q29uZmlnOiB7fSxcclxuXHRcdFZpc2liaWxpdHlNb25pdG9yaW5nSW50ZXJ2YWxNczogVklTSUJJTElUWV9NT05JVE9SSU5HX0lOVEVSVkFMX01TLFxyXG5cdFx0RWxlbWVudHNEaXNjb3ZlcnlJbnRlcnZhbE1zOiBFTEVNRU5UU19ESVNDT1ZFUllfSU5URVJWQUxfTVMsXHJcblx0XHRCYWNrb2ZmR3JhY2VQZXJpb2RNczogREVGQVVMVF9CQUNLT0ZGX0dSQUNFX1BFUklPRFxyXG5cdH07XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VSZWFkb25seURlZmF1bHRDb25maWd1cmF0aW9uKFxyXG5cdHdwbVVybDogc3RyaW5nLFxyXG5cdGV2ZW50Q29uZmlnOiBDb25kaXRpb25zUGVyRXZlbnQsXHJcblx0YWxsb3dFdmVudHM6IGJvb2xlYW4pOiBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhIHtcclxuXHJcblx0Y29uc3QgY29uZmlndXJhdGlvbkRhdGEgPSBtYWtlTXV0YWJsZURlZmF1bHRDb25maWd1cmF0aW9uKHdwbVVybCwgZXZlbnRDb25maWcsIGFsbG93RXZlbnRzKTtcclxuXHQvLyBXb3JrYXJvdW5kIFJlU2hhcnBlciAyMDE3LjMgYnVnLCBzcGVjaWZ5IGdlbmVyaWMgcGFyYW1ldGVyIGV4cGxpY2l0bHlcclxuXHRyZXR1cm4gZGVlcEZyZWV6ZTxSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhPihjb25maWd1cmF0aW9uRGF0YSk7XHJcbn1cclxuXHJcbi8qKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb24sIGRvIG5vdGhpbmcuICovXHJcbmV4cG9ydCBjb25zdCBFTVBUWV9DT05GSUdVUkFUSU9OID0gbWFrZVJlYWRvbmx5RGVmYXVsdENvbmZpZ3VyYXRpb24oXCJcIiwge30sIGZhbHNlKTtcclxuXHJcbi8qIFN0YXJ0aW5nIGNvbmZpZ3VyYXRpb24gdG8gYmUgb3ZlcndyaXR0ZW4gYnkgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBBZ2VudC4gKi9cclxuZXhwb3J0IGNvbnN0IFNUQVJUSU5HX0NPTkZJR1VSQVRJT04gPSBtYWtlTXV0YWJsZURlZmF1bHRDb25maWd1cmF0aW9uKFwiXCIsIHt9LCBmYWxzZSk7XHJcblxyXG4vKiogUmVwb3J0IGV2ZXJ5dGhpbmcgY29uZmlndXJhdGlvbiAqL1xyXG5leHBvcnQgY29uc3QgUkVQT1JUX0VWRVJZVEhJTkdfQ09ORklHVVJBVElPTiA9XHJcblx0bWFrZVJlYWRvbmx5RGVmYXVsdENvbmZpZ3VyYXRpb24oXHJcblx0XHRcIi4qXCIsXHJcblx0XHR7XHJcblx0XHRcdEV2ZXJ5dGhpbmc6IFtdLFxyXG5cdFx0XHRcInVpOmNocm9tZTpUYWIuRXZlcnl0aGluZ1wiOiBbXSxcclxuXHRcdFx0XCJ1aTpjaHJvbWU6RG9jdW1lbnQuRXZlcnl0aGluZ1wiOiBbXVxyXG5cdFx0fSxcclxuXHRcdHRydWUpO1xyXG5cclxuLyoqIFJlcG9ydCB3cG0gY29uZmlndXJhdGlvbiAqL1xyXG5leHBvcnQgY29uc3QgUkVQT1JUX1dQTV9DT05GSUdVUkFUSU9OID1cclxuXHRtYWtlUmVhZG9ubHlEZWZhdWx0Q29uZmlndXJhdGlvbihcclxuXHRcdFwiLipcIixcclxuXHRcdHtcclxuXHRcdFx0XCJodHRwOmNocm9tZTpXZWJQYWdlLkV2ZXJ5dGhpbmdcIjogW10sXHJcblx0XHRcdFwid3BtOmNocm9tZTpQYWdlLkV2ZXJ5dGhpbmdcIjogW11cclxuXHRcdH0sXHJcblx0XHR0cnVlKTtcclxuIiwiLy8gUmVTaGFycGVyIGRpc2FibGUgSW5jb25zaXN0ZW50TmFtaW5nXHJcbmV4cG9ydCBjb25zdCBOVl9DSFJPTUVfV09SS1RJTUVfVklPTEFUSU9OID0gXCJudjpjaHJvbWU6V29ya1RpbWUuVmlvbGF0aW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSFRNTF9ERVNJR05FUl9FVkVOVF9OQU1FU1BBQ0UgPSBcInVpOmNocm9tZTpEb2N1bWVudFwiO1xyXG5leHBvcnQgY29uc3QgSFRNTF9PTkFQUF9FVkVOVF9OQU1FU1BBQ0UgPSBcInVpOmNocm9tZTpPbkFwcDpEb2N1bWVudFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IERPTV9FVkVOVF9OQU1FU1BBQ0UgPSBcInVpOmNocm9tZTpPbkFwcDpEb21cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBWSVNJQkxFX0VWRU5UX05BTUUgPSBnZXRGdWxsRG9tRXZlbnROYW1lKFwiVmlzaWJsZVwiKTtcclxuZXhwb3J0IGNvbnN0IElOVklTSUJMRV9FVkVOVF9OQU1FID0gZ2V0RnVsbERvbUV2ZW50TmFtZShcIkludmlzaWJsZVwiKTtcclxuLy8gUmVTaGFycGVyIHJlc3RvcmUgSW5jb25zaXN0ZW50TmFtaW5nXHJcblxyXG5mdW5jdGlvbiBnZXRGdWxsRG9tRXZlbnROYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0cmV0dXJuIERPTV9FVkVOVF9OQU1FU1BBQ0UgKyBcIi5cIiArIG5hbWU7XHJcbn1cclxuIiwiZXhwb3J0IGVudW0gRnJhbWVUeXBlIHtcclxuXHRET0NVTUVOVCA9IFwiZG9jdW1lbnRcIixcclxuXHRGUkFNRSA9IFwiZnJhbWVcIlxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lSWQgRnJhbWUgaWQgdG8gcmV0cmlldmUgdHlwZSBmcm9tLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm4gcHJvcGVydHkgJ3R5cGUnIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1lVHlwZShmcmFtZUlkOiBudW1iZXIpOiBGcmFtZVR5cGUge1xyXG5cdHJldHVybiBmcmFtZUlkID09PSAwID8gRnJhbWVUeXBlLkRPQ1VNRU5UIDogRnJhbWVUeXBlLkZSQU1FO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XHJcbmltcG9ydCAqIGFzIENvbmZpZ3VyYXRpb25VdGlscyBmcm9tIFwiLi9Db25maWd1cmF0aW9uVXRpbHNcIjtcclxuaW1wb3J0IHtcclxuXHRSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhLFxyXG5cdFByb3BlcnR5TWF0Y2gsXHJcblx0VklTSUJJTElUWV9NT05JVE9SSU5HX0lOVEVSVkFMX01TLFxyXG5cdEVMRU1FTlRTX0RJU0NPVkVSWV9JTlRFUlZBTF9NUyxcclxuXHRTVEFSVElOR19DT05GSUdVUkFUSU9OXHJcbn0gZnJvbSBcIi4uL0NvbmZpZ3VyYXRpb25EYXRhXCI7XHJcbmltcG9ydCB7IENhbmJlTGF6eSB9IGZyb20gXCIuLi8uLi91dGlscy9sYXp5XCI7XHJcbmltcG9ydCB7IFJlZ0V4cE1hdGNoZXIgfSBmcm9tIFwiLi4vLi4vdXRpbHMvUmVnRXhwTWF0Y2hlclwiO1xyXG5pbXBvcnQgeyBFdmVudENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9FdmVudENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHsgQmFja2dyb3VuZFBhZ2VJbmZvcm1hdGlvbiB9IGZyb20gXCIuLi9QYWdlSW5mb3JtYXRpb25cIjtcclxuaW1wb3J0IHsgV2l0aENTU1NlbGVjdG9yIH0gZnJvbSBcIi4uLy4uL0h0bWxNb25pdG9yaW5nL0F0ZXJuaXR5UHJvcGVydGllc1wiO1xyXG5pbXBvcnQgeyBUQVJHRVRfTk9ERV9OQU1FX1BST1BFUlRZIH0gZnJvbSBcIi4uLy4uL0h0bWxNb25pdG9yaW5nL0V2ZW50UHJvcGVydGllc1wiO1xyXG5cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLXJlcXVpcmUtaW1wb3J0c1xyXG5pbXBvcnQgU2ltcGxlTFJVID0gcmVxdWlyZShcInNpbXBsZS1scnVcIik7XHJcblxyXG5jb25zdCBNQVhfQ09ORklHVVJBVElPTl9DQUNIRV9TSVpFID0gMTAwO1xyXG5cclxudHlwZSBQcm9wZXJ0eU1hdGNoZXJOYW1lID1cclxuXHRrZXlvZiBCYWNrZ3JvdW5kUGFnZUluZm9ybWF0aW9uIHxcclxuXHRrZXlvZiBXaXRoQ1NTU2VsZWN0b3IgfFxyXG5cdHR5cGVvZiBUQVJHRVRfTk9ERV9OQU1FX1BST1BFUlRZO1xyXG5cclxuLyoqXHJcbiAqIEVuY2Fwc3VsYXRlcyBEYXRhLkNvbmZpZ3VyYXRpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uIHtcclxuXHQvKipcclxuXHQgKiBXUE0gdXNpbmcgSFRNTCBjYXJ0cmlkZ2UgZm9yIG5hdmlnYXRpb24gdXJsLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgd3BtRG9jdW1lbnRVcmxGaWx0ZXJzOiBSZWdFeHBNYXRjaGVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBXUE0gdXNpbmcgSFRNTCBjYXJ0cmlkZ2UgZm9yIGNvbW1pdHRlZCB1cmwuXHJcblx0ICovXHJcblx0cHJpdmF0ZSByZWFkb25seSB3cG1Db21taXR0ZWRVcmxGaWx0ZXJzOiBSZWdFeHBNYXRjaGVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBodHRwOmNocm9tZTpXZWJQYWdlLlBhZ2VMb2FkLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgaHR0cFdlYlBhZ2VMb2FkVXJsRmlsdGVyczogUmVnRXhwTWF0Y2hlcjtcclxuXHJcblx0cHVibGljIHJlYWRvbmx5IGdsb2JhbEV2ZW50Q29uZmlndXJhdGlvbjogRXZlbnRDb25maWd1cmF0aW9uO1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IHNwZWNpYWxpemVkRXZlbnRDb25maWd1cmF0aW9uOiB7XHJcblx0XHQgW2NvbnNvbGlkYXRpb25Qcm9wZXJ0eTogc3RyaW5nXToge1xyXG5cdFx0XHQgIFttYXRjaGVyOiBzdHJpbmddOiBSZWFkb25seTxFdmVudENvbmZpZ3VyYXRpb24+XHJcblx0XHQgfVxyXG5cdH0gPSB7fTtcclxuXHJcblx0cHVibGljIHJlYWRvbmx5IG1heFByb3BlcnR5TGVuZ3RoOiBudW1iZXI7XHJcblxyXG5cdHB1YmxpYyByZWFkb25seSB2aXNpYmlsaXR5TW9uaXRvcmluZ0ludGVydmFsTXM6IG51bWJlcjtcclxuXHJcblx0cHVibGljIHJlYWRvbmx5IGVsZW1lbnRzRGlzY292ZXJ5SW50ZXJ2YWxNczogbnVtYmVyO1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb25EYXRhOiBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhO1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb25EYXRhQ2FjaGUgPSBuZXcgU2ltcGxlTFJVPHN0cmluZywgUmVhZG9ubHlDb25maWd1cmF0aW9uRGF0YT4oTUFYX0NPTkZJR1VSQVRJT05fQ0FDSEVfU0laRSk7XHJcblxyXG5cdHB1YmxpYyBnZXRFdmVudHNGb3JQYWdlKFxyXG5cdFx0Y29uc29saWRhdGlvbktleXM6IHsgW2NvbnNvbGlkYXRpb25Qcm9wZXJ0eU5hbWU6IHN0cmluZ106IHN0cmluZyB9KTogUmVhZG9ubHlDb25maWd1cmF0aW9uRGF0YSB7XHJcblxyXG5cdFx0Y29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoY29uc29saWRhdGlvbktleXMpO1xyXG5cclxuXHRcdGNvbnN0IGNvbmZpZ3VyYXRpb25EYXRhRnJvbUNhY2hlID0gdGhpcy5jb25maWd1cmF0aW9uRGF0YUNhY2hlLmdldChrZXkpO1xyXG5cdFx0aWYgKGNvbmZpZ3VyYXRpb25EYXRhRnJvbUNhY2hlICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZ3VyYXRpb25EYXRhRnJvbUNhY2hlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uVXRpbHMuZ2V0RXZlbnRzRm9yUGFnZSh0aGlzLmNvbmZpZ3VyYXRpb25EYXRhLCBjb25zb2xpZGF0aW9uS2V5cyk7XHJcblx0XHR0aGlzLmNvbmZpZ3VyYXRpb25EYXRhQ2FjaGUuc2V0KGtleSwgY29uZmlndXJhdGlvbik7XHJcblx0XHRyZXR1cm4gY29uZmlndXJhdGlvbjtcclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25EYXRhOiBQYXJ0aWFsPFJlYWRvbmx5Q29uZmlndXJhdGlvbkRhdGE+KSB7XHJcblx0XHR0aGlzLmNvbmZpZ3VyYXRpb25EYXRhID0gU1RBUlRJTkdfQ09ORklHVVJBVElPTjtcclxuXHRcdFV0aWxzLnBvcHVsYXRlKGNvbmZpZ3VyYXRpb25EYXRhLCB0aGlzLmNvbmZpZ3VyYXRpb25EYXRhKTtcclxuXHJcblx0XHR0aGlzLm1heFByb3BlcnR5TGVuZ3RoID1cclxuXHRcdFx0Y29uZmlndXJhdGlvbkRhdGEuTWF4UHJvcGVydHlMZW5ndGggIT0gbnVsbFxyXG5cdFx0XHQ/IGNvbmZpZ3VyYXRpb25EYXRhLk1heFByb3BlcnR5TGVuZ3RoXHJcblx0XHRcdDogVklTSUJJTElUWV9NT05JVE9SSU5HX0lOVEVSVkFMX01TO1xyXG5cclxuXHRcdHRoaXMudmlzaWJpbGl0eU1vbml0b3JpbmdJbnRlcnZhbE1zID1cclxuXHRcdFx0Y29uZmlndXJhdGlvbkRhdGEuVmlzaWJpbGl0eU1vbml0b3JpbmdJbnRlcnZhbE1zICE9IG51bGxcclxuXHRcdFx0PyBjb25maWd1cmF0aW9uRGF0YS5WaXNpYmlsaXR5TW9uaXRvcmluZ0ludGVydmFsTXNcclxuXHRcdFx0OiBWSVNJQklMSVRZX01PTklUT1JJTkdfSU5URVJWQUxfTVM7XHJcblxyXG5cdFx0dGhpcy5lbGVtZW50c0Rpc2NvdmVyeUludGVydmFsTXMgPVxyXG5cdFx0XHRjb25maWd1cmF0aW9uRGF0YS5FbGVtZW50c0Rpc2NvdmVyeUludGVydmFsTXMgIT0gbnVsbFxyXG5cdFx0XHQ/IGNvbmZpZ3VyYXRpb25EYXRhLkVsZW1lbnRzRGlzY292ZXJ5SW50ZXJ2YWxNc1xyXG5cdFx0XHQ6IEVMRU1FTlRTX0RJU0NPVkVSWV9JTlRFUlZBTF9NUztcclxuXHJcblx0XHQvLyBXUE1cclxuXHRcdHRoaXMud3BtRG9jdW1lbnRVcmxGaWx0ZXJzID0gbmV3IFJlZ0V4cE1hdGNoZXIoKTtcclxuXHRcdGlmIChjb25maWd1cmF0aW9uRGF0YS5XUE1Eb2N1bWVudFVybEZpbHRlcnNMaXN0ICE9IG51bGwpIHtcclxuXHRcdFx0Zm9yIChjb25zdCB3cG1VcmxGaWx0ZXIgb2YgY29uZmlndXJhdGlvbkRhdGEuV1BNRG9jdW1lbnRVcmxGaWx0ZXJzTGlzdCkge1xyXG5cdFx0XHRcdHRoaXMud3BtRG9jdW1lbnRVcmxGaWx0ZXJzLmFkZE1hdGNoZXIod3BtVXJsRmlsdGVyLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLndwbUNvbW1pdHRlZFVybEZpbHRlcnMgPSBuZXcgUmVnRXhwTWF0Y2hlcigpO1xyXG5cdFx0aWYgKGNvbmZpZ3VyYXRpb25EYXRhLldQTUNvbW1pdHRlZFVybEZpbHRlcnNMaXN0ICE9IG51bGwpIHtcclxuXHRcdFx0Zm9yIChjb25zdCB3cG1VcmxGaWx0ZXIgb2YgY29uZmlndXJhdGlvbkRhdGEuV1BNQ29tbWl0dGVkVXJsRmlsdGVyc0xpc3QpIHtcclxuXHRcdFx0XHR0aGlzLndwbUNvbW1pdHRlZFVybEZpbHRlcnMuYWRkTWF0Y2hlcih3cG1VcmxGaWx0ZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZ1bGwgcGFnZVxyXG5cdFx0dGhpcy5odHRwV2ViUGFnZUxvYWRVcmxGaWx0ZXJzID0gbmV3IFJlZ0V4cE1hdGNoZXIoKTtcclxuXHRcdGlmIChjb25maWd1cmF0aW9uRGF0YS5GdWxsV3BtRmlsdGVyc0xpc3QgIT0gbnVsbCkge1xyXG5cdFx0XHRmb3IgKGNvbnN0IGZ1bGxXcG1VcmxGaWx0ZXIgb2YgY29uZmlndXJhdGlvbkRhdGEuRnVsbFdwbUZpbHRlcnNMaXN0KSB7XHJcblx0XHRcdFx0dGhpcy5odHRwV2ViUGFnZUxvYWRVcmxGaWx0ZXJzLmFkZE1hdGNoZXIoZnVsbFdwbVVybEZpbHRlciwgZmFsc2UsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZXZlbnRDb25maWcgPSBjb25maWd1cmF0aW9uRGF0YS5FdmVudENvbmZpZyAhPSBudWxsID8gY29uZmlndXJhdGlvbkRhdGEuRXZlbnRDb25maWcgOiB7fTtcclxuXHRcdHRoaXMuZ2xvYmFsRXZlbnRDb25maWd1cmF0aW9uID0gbmV3IEV2ZW50Q29uZmlndXJhdGlvbihldmVudENvbmZpZyk7XHJcblx0XHRjb25zdCBjb25zb2xpZGF0ZWRFdmVudENvbmZpZyA9IGNvbmZpZ3VyYXRpb25EYXRhLkNvbnNvbGlkYXRlZEV2ZW50Q29uZmlnO1xyXG5cclxuXHRcdGlmIChjb25zb2xpZGF0ZWRFdmVudENvbmZpZyAhPSBudWxsKSB7XHJcblx0XHRcdGZvciAoY29uc3QgY29uc29saWRhdGlvblByb3BlcnR5IGluIGNvbnNvbGlkYXRlZEV2ZW50Q29uZmlnKSB7XHJcblx0XHRcdFx0aWYgKCFjb25zb2xpZGF0ZWRFdmVudENvbmZpZy5oYXNPd25Qcm9wZXJ0eShjb25zb2xpZGF0aW9uUHJvcGVydHkpKSBjb250aW51ZTtcclxuXHRcdFx0XHRjb25zdCBjb25zb2xpZGF0ZWRDb25maWd1cmF0aW9uID0gY29uc29saWRhdGVkRXZlbnRDb25maWdbY29uc29saWRhdGlvblByb3BlcnR5XTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBtYXRjaGVyIGluIGNvbnNvbGlkYXRlZENvbmZpZ3VyYXRpb24pIHtcclxuXHRcdFx0XHRcdGlmICghY29uc29saWRhdGVkQ29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShtYXRjaGVyKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zcGVjaWFsaXplZEV2ZW50Q29uZmlndXJhdGlvbltjb25zb2xpZGF0aW9uUHJvcGVydHldID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zcGVjaWFsaXplZEV2ZW50Q29uZmlndXJhdGlvbltjb25zb2xpZGF0aW9uUHJvcGVydHldID0ge307XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLnNwZWNpYWxpemVkRXZlbnRDb25maWd1cmF0aW9uW2NvbnNvbGlkYXRpb25Qcm9wZXJ0eV1bbWF0Y2hlcl0gPVxyXG5cdFx0XHRcdFx0XHRuZXcgRXZlbnRDb25maWd1cmF0aW9uKGNvbnNvbGlkYXRlZENvbmZpZ3VyYXRpb25bbWF0Y2hlcl0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGhhc0V2ZW50RmlsdGVyKGV2ZW50TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHQvLyBDaGVjayBib3RoIGluIGV2ZW50IGZpbHRlcnMgYW5kIGluIGV2ZXJ5dGhpbmcgcHJlZml4ZXMuXHJcblx0XHRyZXR1cm4gdGhpcy5nbG9iYWxFdmVudENvbmZpZ3VyYXRpb24uZXZlbnRGaWx0ZXJzLmhhc0ZpbHRlcihldmVudE5hbWUpIHx8IHRoaXMuaXNNYXRjaEV2ZXJ5dGhpbmcoZXZlbnROYW1lKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIHRoZSBnaXZlbiBtb25pdG9yaW5nRXZlbnQgaXMgbW9uaXRvcmVkLlxyXG5cdCAqXHJcblx0ICogRm9yIGdpdmVuIGV2ZW50IGh0dHA6Y2hyb21lOldlYlJlcXVlc3QuU3RhcnQgdGhvc2UgZXZlbiBjYXRlZ29yaWVzIHJldHVybiB0cnVlOlxyXG5cdCAqIGh0dHA6Y2hyb21lOldlYlJlcXVlc3RcclxuXHQgKiBodHRwOmNocm9tZVxyXG5cdCAqIGh0dHBcclxuXHQgKlxyXG5cdCAqIEByZXR1cm4gdHJ1ZSBpZiBtb25pdG9yZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuXHQgKi9cclxuXHRwdWJsaWMgaXNNb25pdG9yaW5nKG1vbml0b3JpbmdFdmVudDogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHQvLyBDaGVjayBldmVudCBmaWx0ZXJcclxuXHRcdGlmICh0aGlzLmhhc0V2ZW50RmlsdGVyKG1vbml0b3JpbmdFdmVudCkpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgZXZlcnl0aGluZyBldmVudCBmaWx0ZXJzIGJ5IHByZWZpeFxyXG5cdFx0Zm9yIChjb25zdCBldmVyeXRoaW5nRXZlbnRGaWx0ZXIgb2YgdGhpcy5nbG9iYWxFdmVudENvbmZpZ3VyYXRpb24uZXZlcnl0aGluZ1ByZWZpeEV2ZW50cykge1xyXG5cdFx0XHRpZiAoVXRpbHMuc3RhcnRzV2l0aChldmVyeXRoaW5nRXZlbnRGaWx0ZXIsIG1vbml0b3JpbmdFdmVudCkpIHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGV2ZW50IGZpbHRlcnMgYnkgcHJlZml4XHJcblx0XHRmb3IgKGNvbnN0IGV2ZW50RmlsdGVyIG9mIHRoaXMuZ2xvYmFsRXZlbnRDb25maWd1cmF0aW9uLmV2ZW50RmlsdGVycy5nZXRFdmVudE5hbWVzKCkpIHtcclxuXHRcdFx0aWYgKFV0aWxzLnN0YXJ0c1dpdGgoZXZlbnRGaWx0ZXIsIG1vbml0b3JpbmdFdmVudCkpIHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpc01hdGNoRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcsIHByb3BlcnR5TmFtZTogc3RyaW5nLCBpbnB1dDogQ2FuYmVMYXp5PHN0cmluZz4pOiBib29sZWFuIHtcclxuXHRcdC8vIENoZWNrIGJvdGggaW4gZXZlbnQgZmlsdGVycyBhbmQgaW4gZXZlcnl0aGluZyBwcmVmaXhlcy5cclxuXHRcdHJldHVybiB0aGlzLmlzTWF0Y2hFdmVyeXRoaW5nKGV2ZW50TmFtZSkgfHxcclxuXHRcdFx0dGhpcy5nbG9iYWxFdmVudENvbmZpZ3VyYXRpb24uZXZlbnRGaWx0ZXJzLmlzTWF0Y2goZXZlbnROYW1lLCBwcm9wZXJ0eU5hbWUsIGlucHV0KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgaXNNYXRjaEV2ZXJ5dGhpbmcoZXZlbnROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmdsb2JhbEV2ZW50Q29uZmlndXJhdGlvbi5ldmVyeXRoaW5nUHJlZml4RXZlbnRzLnNvbWUocCA9PiBVdGlscy5zdGFydHNXaXRoKGV2ZW50TmFtZSwgcCkpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzTWF0Y2hXZWJSZXF1ZXN0RXZlbnQocHJvcGVydHlOYW1lOiBzdHJpbmcsIGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdC8vIEZpcnN0IGNoZWNrIHdoZXRoZXIgZXZlbnQgaXMgaW4gZXZlcnl0aGluZyBmaWx0ZXJzXHJcblx0XHRpZiAodGhpcy5nbG9iYWxFdmVudENvbmZpZ3VyYXRpb24ud2ViUmVxdWVzdEV2ZXJ5dGhpbmcpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2xvYmFsRXZlbnRDb25maWd1cmF0aW9uLndlYlJlcXVlc3RGaWx0ZXJzLmlzTWF0Y2gocHJvcGVydHlOYW1lLCBpbnB1dCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaGFzV2ViUmVxdWVzdEZpbHRlcihwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gRmlyc3QgY2hlY2sgd2hldGhlciBldmVudCBpcyBpbiBldmVyeXRoaW5nIGZpbHRlcnNcclxuXHRcdGlmICh0aGlzLmdsb2JhbEV2ZW50Q29uZmlndXJhdGlvbi53ZWJSZXF1ZXN0RXZlcnl0aGluZykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nbG9iYWxFdmVudENvbmZpZ3VyYXRpb24ud2ViUmVxdWVzdEZpbHRlcnMuaGFzRmlsdGVyKHByb3BlcnR5TmFtZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNNYXRjaEZvcldwbVVybHMoZG9jdW1lbnRVcmw6IHN0cmluZywgZG9jdW1lbnRDb21taXR0ZWRVcmw/OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLndwbURvY3VtZW50VXJsRmlsdGVycy5pc01hdGNoKGRvY3VtZW50VXJsKSkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZG9jdW1lbnRDb21taXR0ZWRVcmwgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy53cG1Db21taXR0ZWRVcmxGaWx0ZXJzLmlzTWF0Y2goZG9jdW1lbnRDb21taXR0ZWRVcmwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpc01hdGNoRm9ySHR0cFdlYlBhZ2VMb2FkVXJsKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5odHRwV2ViUGFnZUxvYWRVcmxGaWx0ZXJzLmlzTWF0Y2godXJsKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNXcG1GaWx0ZXIoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy53cG1Eb2N1bWVudFVybEZpbHRlcnMuaGFzTWF0Y2hlcigpIHx8XHJcblx0XHRcdHRoaXMud3BtQ29tbWl0dGVkVXJsRmlsdGVycy5oYXNNYXRjaGVyKCkgfHxcclxuXHRcdFx0dGhpcy5odHRwV2ViUGFnZUxvYWRVcmxGaWx0ZXJzLmhhc01hdGNoZXIoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRQcm9wZXJ0eU1hdGNoZXJzKGV2ZW50TmFtZTogc3RyaW5nLCBwcm9wZXJ0eU5hbWU6IFByb3BlcnR5TWF0Y2hlck5hbWUpOiBQcm9wZXJ0eU1hdGNoW10ge1xyXG5cdFx0Y29uc3QgcmVzdWx0OiBQcm9wZXJ0eU1hdGNoW10gPSBbXTtcclxuXHRcdGNvbnN0IGV2ZW50Q29uZmlnID0gdGhpcy5jb25maWd1cmF0aW9uRGF0YS5FdmVudENvbmZpZ1tldmVudE5hbWVdO1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudENvbmZpZyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoY29uc3QgY29uZGl0aW9ucyBvZiBldmVudENvbmZpZykge1xyXG5cdFx0XHRjb25zdCBwcm9wZXJ0eUNvbmRpdGlvbnMgPSBjb25kaXRpb25zLkNvbmRpdGlvbnNbcHJvcGVydHlOYW1lXTtcclxuXHRcdFx0aWYgKHR5cGVvZiBwcm9wZXJ0eUNvbmRpdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKGNvbnN0IHByb3BlcnR5TWF0Y2ggb2YgcHJvcGVydHlDb25kaXRpb25zKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2gocHJvcGVydHlNYXRjaCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGhhc1Byb3BlcnR5TWF0Y2hlcnMoZXZlbnROYW1lOiBzdHJpbmcsIHByb3BlcnR5TmFtZTogUHJvcGVydHlNYXRjaGVyTmFtZSk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgZXZlbnRDb25maWcgPSB0aGlzLmNvbmZpZ3VyYXRpb25EYXRhLkV2ZW50Q29uZmlnW2V2ZW50TmFtZV07XHJcblx0XHRpZiAodHlwZW9mIGV2ZW50Q29uZmlnID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGNvbnN0IGNvbmRpdGlvbnMgb2YgZXZlbnRDb25maWcpIHtcclxuXHRcdFx0Y29uc3QgcHJvcGVydHlDb25kaXRpb25zID0gY29uZGl0aW9ucy5Db25kaXRpb25zW3Byb3BlcnR5TmFtZV07XHJcblx0XHRcdGlmICh0eXBlb2YgcHJvcGVydHlDb25kaXRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG4vLyAjZW5kcmVnaW9uXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ2FuYmVMYXp5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2xhenlcIjtcclxuaW1wb3J0IHsgUmVnRXhwTWF0Y2hlciB9IGZyb20gXCIuLi8uLi91dGlscy9SZWdFeHBNYXRjaGVyXCI7XHJcblxyXG5pbnRlcmZhY2UgUmVnZXhQcm9wZXJ0eUZpbHRlcnMge1xyXG5cdHByb3BlcnR5OiBSZWdFeHA7XHJcblx0bWF0Y2hlcjogUmVnRXhwTWF0Y2hlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hdGNoIHByb3BlcnR5IG5hbWUgYnkgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKiBVc2Ugd2l0aCBjYXV0aW9uICFcclxuICovXHJcbmNvbnN0IFJFR0VYX1BST1BFUlRZID0gLyguKil+JC87XHJcblxyXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbkZpbHRlcnMge1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgcHJvcGVydHlGaWx0ZXJzOiB7IFtwcm9wZXJ0eU5hbWU6IHN0cmluZ106IFJlZ0V4cE1hdGNoZXI7IH0gPSB7fTtcclxuXHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0cHJpdmF0ZSByZWFkb25seSByZWdleFBvcGVydHlGaWx0ZXJzOiBSZWdleFByb3BlcnR5RmlsdGVyc1tdID0gW107XHJcblxyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdHB1YmxpYyBnZXRFeGFjdFByb3BlcnR5TmFtZXMoKTogc3RyaW5nW10ge1xyXG5cdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucHJvcGVydHlGaWx0ZXJzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNSZWdleFByb3BlcnR5TmFtZXMoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWdleFBvcGVydHlGaWx0ZXJzLmxlbmd0aCA+IDA7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgYWRkRmlsdGVyKHByb3BlcnR5TmFtZTogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcsIGlzRXhhY3Q6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVndWxhciBleHByZXNzaW9uIHByb3BlcnR5IG5hbWVcclxuXHRcdGNvbnN0IHJlZ2V4UHJvcGVydHkgPSBwcm9wZXJ0eU5hbWUubWF0Y2goUkVHRVhfUFJPUEVSVFkpO1xyXG5cdFx0aWYgKHJlZ2V4UHJvcGVydHkgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmFkZFJlZ2V4UHJvcGVydHlGaWx0ZXIocmVnZXhQcm9wZXJ0eVsxXSwgcGF0dGVybiwgaXNFeGFjdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodGhpcy5wcm9wZXJ0eUZpbHRlcnNbcHJvcGVydHlOYW1lXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0eUZpbHRlcnNbcHJvcGVydHlOYW1lXSA9IG5ldyBSZWdFeHBNYXRjaGVyKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5wcm9wZXJ0eUZpbHRlcnNbcHJvcGVydHlOYW1lXS5hZGRNYXRjaGVyKHBhdHRlcm4sIGlzRXhhY3QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhZGRSZWdleFByb3BlcnR5RmlsdGVyKHByb3BlcnR5OiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZywgaXNFeGFjdDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgcmUgPSBuZXcgUmVnRXhwKHByb3BlcnR5KTtcclxuXHJcblx0XHRcdGxldCBmaWx0ZXI6IFJlZ2V4UHJvcGVydHlGaWx0ZXJzIHwgdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0Ly8gQWRkIHRvIGV4aXN0aW5nXHJcblx0XHRcdGZvciAoY29uc3QgcHJvcGVydHlGaWx0ZXIgb2YgdGhpcy5yZWdleFBvcGVydHlGaWx0ZXJzKSB7XHJcblx0XHRcdFx0aWYgKHByb3BlcnR5RmlsdGVyLnByb3BlcnR5LnRvU3RyaW5nKCkgPT09IHJlLnRvU3RyaW5nKCkpIHtcclxuXHRcdFx0XHRcdGZpbHRlciA9IHByb3BlcnR5RmlsdGVyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gT3IgY3JlYXRlIGEgbmV3IG9uZVxyXG5cdFx0XHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIENvbmRpdGlvbklzQWx3YXlzQ29uc3RcclxuXHRcdFx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBIZXVyaXN0aWNhbGx5VW5yZWFjaGFibGVDb2RlXHJcblx0XHRcdGlmIChmaWx0ZXIgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGZpbHRlciA9IHtcclxuXHRcdFx0XHRcdHByb3BlcnR5OiByZSxcclxuXHRcdFx0XHRcdG1hdGNoZXI6IG5ldyBSZWdFeHBNYXRjaGVyKClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR0aGlzLnJlZ2V4UG9wZXJ0eUZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBZGQgbWF0Y2hlclxyXG5cdFx0XHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIFRzUmVzb2x2ZWRGcm9tSW5hY2Nlc3NpYmxlTW9kdWxlXHJcblx0XHRcdGZpbHRlci5tYXRjaGVyLmFkZE1hdGNoZXIocGF0dGVybiwgaXNFeGFjdCk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBub3QgdmFsaWQsIHNraXAgaXQuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNGaWx0ZXIocHJvcGVydHlOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBwcm9wZXJ0eU5hbWUgaW4gdGhpcy5wcm9wZXJ0eUZpbHRlcnMgfHxcclxuXHRcdFx0dGhpcy5yZWdleFBvcGVydHlGaWx0ZXJzLnNvbWUoZiA9PiBmLnByb3BlcnR5LnRlc3QocHJvcGVydHlOYW1lKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGaXJzdCBjaGVja2luZyBleGFjdCBvbmVzIGFuZCB0aGVuIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXHJcblx0ICovXHJcblx0cHVibGljIGlzTWF0Y2gocHJvcGVydHlOYW1lOiBzdHJpbmcsIGlucHV0OiBDYW5iZUxhenk8c3RyaW5nPik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgZmlsdGVycyA9IHRoaXMucHJvcGVydHlGaWx0ZXJzW3Byb3BlcnR5TmFtZV07XHJcblx0XHRpZiAoZmlsdGVycyAhPSBudWxsICYmIGZpbHRlcnMuaXNNYXRjaChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZWdleFBvcGVydHlGaWx0ZXJzLnNvbWUoXHJcblx0XHRcdFx0ZiA9PiBmLnByb3BlcnR5LnRlc3QocHJvcGVydHlOYW1lKSAmJiBmLm1hdGNoZXIuaXNNYXRjaChpbnB1dCkpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQge1xyXG5cdFJlYWRvbmx5Q29uZmlndXJhdGlvbkRhdGEsXHJcblx0Q29uZGl0aW9uT2JqZWN0LFxyXG5cdFJlYWRvbmx5Q29uZGl0aW9uT2JqZWN0LFxyXG5cdFByb3BlcnR5TWF0Y2hcclxufSBmcm9tIFwiLi4vQ29uZmlndXJhdGlvbkRhdGFcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XHJcbmltcG9ydCB7IFJlZ0V4cE1hdGNoZXIgfSBmcm9tIFwiLi4vLi4vdXRpbHMvUmVnRXhwTWF0Y2hlclwiO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGdpdmVuIGNvbnNvbGlkYXRpb24ga2V5c1xyXG4gKlxyXG4gKiBAcGFyYW0gY29uZmlndXJhdGlvbkRhdGEgQ29uZmlndXJhdGlvbiBkYXRhIHRvIGV4dHJhY3QgY29uZmlndXJhdGlvbiBmcm9tLlxyXG4gKiBAcGFyYW0gY29uc29saWRhdGlvbktleXMgTWFwcGluZyBmcm9tIGNvbnNvbGlkYXRpb24ga2V5IHRvIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50c0ZvclBhZ2UoXHJcblx0Y29uZmlndXJhdGlvbkRhdGE6IFJlYWRvbmx5Q29uZmlndXJhdGlvbkRhdGEsXHJcblx0Y29uc29saWRhdGlvbktleXM6IHsgcmVhZG9ubHkgW3Byb3BlcnR5TmFtZTogc3RyaW5nXTogc3RyaW5nIH1cclxuXHQpOiBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhIHtcclxuXHJcblx0Y29uc3QgcmVzdWx0OiB7IFtldmVudE5hbWU6IHN0cmluZ106IENvbmRpdGlvbk9iamVjdFtdOyB9ID0ge307XHJcblxyXG5cdGZvciAoY29uc3QgcHJvcGVydHkgaW4gY29uc29saWRhdGlvbktleXMpIHtcclxuXHRcdGlmICghY29uc29saWRhdGlvbktleXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSBjb250aW51ZTtcclxuXHJcblx0XHRjb25zdCBmb3JQcm9wZXJ0eSA9IGNvbmZpZ3VyYXRpb25EYXRhLkNvbnNvbGlkYXRlZEV2ZW50Q29uZmlnW3Byb3BlcnR5XTtcclxuXHRcdGlmIChmb3JQcm9wZXJ0eSA9PSBudWxsKSBjb250aW51ZTsgLy8gVGhlbiB3ZSBkb24ndCBoYXZlIGEgY29uc29saWRhdGlvbiBieSB0aGlzIHByb3BlcnR5XHJcblxyXG5cdFx0Zm9yIChjb25zdCBmaWx0ZXIgaW4gZm9yUHJvcGVydHkpIHtcclxuXHRcdFx0aWYgKCFmb3JQcm9wZXJ0eS5oYXNPd25Qcm9wZXJ0eShmaWx0ZXIpKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGNvbnN0IG1hdGNoZXIgPSBuZXcgUmVnRXhwTWF0Y2hlcigpO1xyXG5cdFx0XHRtYXRjaGVyLmFkZE1hdGNoZXIoZmlsdGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHRpZiAobWF0Y2hlci5pc01hdGNoKGNvbnNvbGlkYXRpb25LZXlzW3Byb3BlcnR5XSkpIHtcclxuXHRcdFx0XHRjb25zdCBldmVudHMgPSBmb3JQcm9wZXJ0eVtmaWx0ZXJdO1xyXG5cdFx0XHRcdGV4dGVuZEV2ZW50Q29uZmlnKHJlc3VsdCwgZXZlbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y29uc3QgcmV0OiBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhID0ge1xyXG5cdFx0Q29uZmlndXJhdGlvblZlcnNpb246IGNvbmZpZ3VyYXRpb25EYXRhLkNvbmZpZ3VyYXRpb25WZXJzaW9uLFxyXG5cdFx0TWF4UHJvcGVydHlMZW5ndGg6IGNvbmZpZ3VyYXRpb25EYXRhLk1heFByb3BlcnR5TGVuZ3RoLFxyXG5cdFx0VmlzaWJpbGl0eU1vbml0b3JpbmdJbnRlcnZhbE1zOiBjb25maWd1cmF0aW9uRGF0YS5WaXNpYmlsaXR5TW9uaXRvcmluZ0ludGVydmFsTXMsXHJcblx0XHRCYWNrb2ZmR3JhY2VQZXJpb2RNczogY29uZmlndXJhdGlvbkRhdGEuQmFja29mZkdyYWNlUGVyaW9kTXMsXHJcblx0XHRFbGVtZW50c0Rpc2NvdmVyeUludGVydmFsTXM6IGNvbmZpZ3VyYXRpb25EYXRhLkVsZW1lbnRzRGlzY292ZXJ5SW50ZXJ2YWxNcyxcclxuXHRcdFdvcmtUaW1lVGhyZXNob2xkczogY29uZmlndXJhdGlvbkRhdGEuV29ya1RpbWVUaHJlc2hvbGRzLFxyXG5cdFx0RXZlbnRDb25maWc6IHJlc3VsdCxcclxuXHRcdENvbnNvbGlkYXRlZEV2ZW50Q29uZmlnOiB7fSxcclxuXHJcblx0XHQvLyBERTIyNTYwOiBXUE0gaXMgcGFydCBvZiB0aGUgY29uZmlndXJhdGlvbiBpbnRlbmRlZCBmb3IgdGhlIGJhY2tncm91bmQgb25seSAtXHJcblx0XHQvLyBpdCdzIG9mIG5vIHVzZSB0byB0aGUgY29udGVudCBzY3JpcHRcclxuXHRcdFdQTURvY3VtZW50VXJsRmlsdGVyc0xpc3Q6IFtdLFxyXG5cdFx0V1BNQ29tbWl0dGVkVXJsRmlsdGVyc0xpc3Q6IFtdLFxyXG5cdFx0RnVsbFdwbUZpbHRlcnNMaXN0OiBbXVxyXG5cdH07XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZEV2ZW50Q29uZmlnKFxyXG5cdHRhcmdldDogeyBbZXZlbnROYW1lOiBzdHJpbmddOiBDb25kaXRpb25PYmplY3RbXTsgfSxcclxuXHRzb3VyY2U6IHsgcmVhZG9ubHkgW2V2ZW50TmFtZTogc3RyaW5nXTogUmVhZG9ubHlBcnJheTxSZWFkb25seUNvbmRpdGlvbk9iamVjdD47IH0pOiB2b2lkIHtcclxuXHJcblx0Zm9yIChjb25zdCBldmVudE5hbWUgaW4gc291cmNlKSB7XHJcblx0XHRpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSBjb250aW51ZTtcclxuXHRcdGNvbnN0IGNvbmRpdGlvbnMgPSBzb3VyY2VbZXZlbnROYW1lXTtcclxuXHRcdGlmIChjb25kaXRpb25zLmxlbmd0aCAhPT0gMSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBDb25kaXRpb25PYmplY3RzIG5vdCBzdXBwb3J0ZWRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xyXG5cdFx0XHQvLyBSZVNoYXJwZXIgMjAxNy4zIGJ1ZyB3b3JrYXJvdW5kXHJcblx0XHRcdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxyXG5cdFx0XHR0YXJnZXRbZXZlbnROYW1lXSA9IFV0aWxzLmRlZXBDbG9uZShjb25kaXRpb25zKSBhcyBDb25kaXRpb25PYmplY3RbXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0YXJnZXRbZXZlbnROYW1lXS5sZW5ndGggIT09IDEpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBDb25kaXRpb25PYmplY3RzIG5vdCBzdXBwb3J0ZWRcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3QgdGFyZ2V0Q29uZGl0aW9ucyA9IHRhcmdldFtldmVudE5hbWVdWzBdLkNvbmRpdGlvbnM7XHJcblx0XHRcdGNvbnN0IHNvdXJjZUNvbmRpdGlvbnMgPSBjb25kaXRpb25zWzBdLkNvbmRpdGlvbnM7XHJcblxyXG5cdFx0XHRleHRlbmRDb25kaXRpb25zKHRhcmdldENvbmRpdGlvbnMsIHNvdXJjZUNvbmRpdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZVByb3BlcnR5TWF0Y2goYTogUHJvcGVydHlNYXRjaCwgYjogUHJvcGVydHlNYXRjaCk6IGJvb2xlYW4ge1xyXG5cdHJldHVybiBhLk1hdGNoVHlwZSA9PT0gYi5NYXRjaFR5cGUgJiYgYS5WYWx1ZSA9PT0gYi5WYWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5kQ29uZGl0aW9ucyhcclxuXHR0YXJnZXQ6IHsgW3Byb3BlcnR5OiBzdHJpbmddOiBQcm9wZXJ0eU1hdGNoW107IH0sXHJcblx0c291cmNlOiB7IHJlYWRvbmx5IFtwcm9wZXJ0eTogc3RyaW5nXTogUmVhZG9ubHlBcnJheTxSZWFkb25seTxQcm9wZXJ0eU1hdGNoPj47IH0pOiB2b2lkIHtcclxuXHRmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBpbiBzb3VyY2UpIHtcclxuXHRcdGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIGNvbnRpbnVlO1xyXG5cdFx0aWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG5cdFx0XHQvLyBSZVNoYXJwZXIgMjAxNy4zIGJ1ZyB3b3JrYXJvdW5kXHJcblx0XHRcdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxyXG5cdFx0XHR0YXJnZXRbcHJvcGVydHlOYW1lXSA9IFV0aWxzLmRlZXBDbG9uZShzb3VyY2VbcHJvcGVydHlOYW1lXSkgYXMgUHJvcGVydHlNYXRjaFtdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0TWF0Y2hlcnMgPSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcclxuXHRcdFx0Y29uc3Qgc291cmNlTWF0Y2hlciA9IHNvdXJjZVtwcm9wZXJ0eU5hbWVdO1xyXG5cdFx0XHRmb3IgKGNvbnN0IG1hdGNoZXIgb2Ygc291cmNlTWF0Y2hlcikge1xyXG5cdFx0XHRcdGlmICh0YXJnZXRNYXRjaGVycy5zb21lKG0gPT4gY29tcGFyZVByb3BlcnR5TWF0Y2gobSwgbWF0Y2hlcikpKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTsgLy8gV2UgYWxyZWFkeSBoYXZlIGl0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRhcmdldE1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XHJcbmltcG9ydCAqIGFzIENvbnN0cyBmcm9tIFwiLi4vY29uc3RzXCI7XHJcbmltcG9ydCB7IENvbmZpZ3VyYXRpb25GaWx0ZXJzIH0gZnJvbSBcIi4vQ29uZmlndXJhdGlvbkZpbHRlcnNcIjtcclxuaW1wb3J0IHsgRXZlbnRGaWx0ZXJzIH0gZnJvbSBcIi4vRXZlbnRGaWx0ZXJzXCI7XHJcbmltcG9ydCB7IFJlYWRvbmx5Q29uZGl0aW9uT2JqZWN0IH0gZnJvbSBcIi4uL0NvbmZpZ3VyYXRpb25EYXRhXCI7XHJcblxyXG4vKlxyXG4gKiBSZXBvcnQgZXZlcnl0aGluZyBmb3IgdGhpcyBldmVudC5cclxuICovXHJcbmNvbnN0IEVWRVJZVEhJTkdfRVZFTlRfU1VGRklYID0gbmV3IFJlZ0V4cChcIiguKilcIiArIENvbnN0cy5SRVBPUlRfRVZFUllUSElORyArIFwiJFwiKTtcclxuXHJcbi8qXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIHdoaWNoIG11c3QgYmUgc2VuZCB0byB0aGUgYWdlbnQgd2l0aCBhbnkgZXZlbnRcclxuICovXHJcbmNvbnN0IE1BTkRBVE9SWV9QUk9QRVJUSUVTOiBSZWFkb25seUFycmF5PHN0cmluZz4gPSBbXCJ0YWJJZFwiXTtcclxuXHJcbmV4cG9ydCBjbGFzcyBFdmVudENvbmZpZ3VyYXRpb24ge1xyXG5cdHB1YmxpYyByZWFkb25seSBldmVudEZpbHRlcnM6IEV2ZW50RmlsdGVycztcclxuXHJcblx0LyoqXHJcblx0ICogRXZlbnRzIHByZWZpeGVzIHdoaWNoIHJlcG9ydCBldmVyeXRoaW5nLlxyXG5cdCAqL1xyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdHB1YmxpYyByZWFkb25seSBldmVyeXRoaW5nUHJlZml4RXZlbnRzOiBzdHJpbmdbXTtcclxuXHJcblx0cHVibGljIHJlYWRvbmx5IHdlYlJlcXVlc3RGaWx0ZXJzOiBDb25maWd1cmF0aW9uRmlsdGVycztcclxuXHJcblx0cHVibGljIHdlYlJlcXVlc3RFdmVyeXRoaW5nOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihldmVudFRvTGV2ZWxzOiB7IHJlYWRvbmx5IFtldmVudE5hbWU6IHN0cmluZ106IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHlDb25kaXRpb25PYmplY3Q+OyB9KSB7XHJcblx0XHR0aGlzLmV2ZW50RmlsdGVycyA9IG5ldyBFdmVudEZpbHRlcnMoKTtcclxuXHRcdHRoaXMuZXZlcnl0aGluZ1ByZWZpeEV2ZW50cyA9IFtdO1xyXG5cclxuXHRcdHRoaXMud2ViUmVxdWVzdEV2ZXJ5dGhpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMud2ViUmVxdWVzdEZpbHRlcnMgPSBuZXcgQ29uZmlndXJhdGlvbkZpbHRlcnMoKTtcclxuXHJcblx0XHRmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudFRvTGV2ZWxzKSB7XHJcblx0XHRcdGlmICghZXZlbnRUb0xldmVscy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSBjb250aW51ZTtcclxuXHRcdFx0aWYgKHRoaXMudHJ5QWRkRXZlcnl0aGluZyhldmVudE5hbWUpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGxldmVscyA9IGV2ZW50VG9MZXZlbHNbZXZlbnROYW1lXTtcclxuXHRcdFx0Ly8gQ3VycmVudGx5IHdlIHN1cHBvcnQgb25seSBvbmUgbGV2ZWxcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihsZXZlbHMubGVuZ3RoLCAxKTsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3QgY29uZGl0aW9ucyA9IGxldmVsc1tpXS5Db25kaXRpb25zO1xyXG5cdFx0XHRcdGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIGNvbmRpdGlvbnMpIHtcclxuXHRcdFx0XHRcdGlmICghY29uZGl0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdGNvbnN0IG1hdGNoZXJzID0gY29uZGl0aW9uc1twcm9wZXJ0eU5hbWVdO1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBtYXRjaGVyIG9mIG1hdGNoZXJzKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gbWF0Y2hlci5WYWx1ZTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgaXNFeGFjdCA9IG1hdGNoZXIuTWF0Y2hUeXBlID09PSBcImV4YWN0XCI7XHJcblx0XHRcdFx0XHRcdHRoaXMuYWRkRmlsdGVyKGV2ZW50TmFtZSwgcHJvcGVydHlOYW1lLCB2YWx1ZSwgaXNFeGFjdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52ZXJpZnlNYW5kYXRvcnlQcm9wZXJ0aWVzKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHRyeUFkZEV2ZXJ5dGhpbmcoZXZlbnROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdC8vIFRlc3QgZm9yIGV2ZXJ5dGhpbmcgY2FzZVxyXG5cdFx0Y29uc3QgZXZlcnl0aGluZ01hdGNoID0gZXZlbnROYW1lLm1hdGNoKEVWRVJZVEhJTkdfRVZFTlRfU1VGRklYKTtcclxuXHRcdGlmIChldmVyeXRoaW5nTWF0Y2ggIT0gbnVsbCkge1xyXG5cdFx0XHRjb25zdCBldmVudFByZWZpeCA9IGV2ZXJ5dGhpbmdNYXRjaFsxXTtcclxuXHJcblx0XHRcdC8vIEFkZCBpZiBoYXNuJ3QgYmVlbiBhZGRlZCBiZWZvcmVcclxuXHRcdFx0aWYgKHRoaXMuZXZlcnl0aGluZ1ByZWZpeEV2ZW50cy5pbmRleE9mKGV2ZW50UHJlZml4KSA9PT0gLTEpIHtcclxuXHRcdFx0XHR0aGlzLmV2ZXJ5dGhpbmdQcmVmaXhFdmVudHMucHVzaChldmVudFByZWZpeCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNwZWNpYWwgV2ViUmVxdWVzdCBldmVyeXRoaW5nIGNhc2VcclxuXHRcdFx0dGhpcy53ZWJSZXF1ZXN0RXZlcnl0aGluZyA9XHJcblx0XHRcdFx0dGhpcy53ZWJSZXF1ZXN0RXZlcnl0aGluZyB8fFxyXG5cdFx0XHRcdFV0aWxzLnN0YXJ0c1dpdGgoQ29uc3RzLldFQlJFUVVFU1RfRVZFTlRfTkFNRVNQQUNFLCBldmVudFByZWZpeCkgfHxcclxuXHRcdFx0XHRldmVudFByZWZpeC5sZW5ndGggPT09IDAgfHxcclxuXHRcdFx0XHRDb25zdHMuV0VCUkVRVUVTVF9FVkVOVF9SRS50ZXN0KGV2ZW50UHJlZml4KTtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhZGRGaWx0ZXIoZXZlbnROYW1lOiBzdHJpbmcsIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBpc0V4YWN0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCBjb25maWdQcm9wZXJ0eU5hbWUgPSBFdmVudENvbmZpZ3VyYXRpb24ubm9ybWFsaXplUHJvcGVydHkocHJvcGVydHlOYW1lKTtcclxuXHJcblx0XHQvLyBTcGVjaWFsIHdlYlJlcXVlc3QgcHJvcGVydGllcy5cclxuXHRcdGlmIChDb25zdHMuV0VCUkVRVUVTVF9FVkVOVF9SRS50ZXN0KGV2ZW50TmFtZSkpIHtcclxuXHRcdFx0dGhpcy53ZWJSZXF1ZXN0RmlsdGVycy5hZGRGaWx0ZXIoXHJcblx0XHRcdFx0Y29uZmlnUHJvcGVydHlOYW1lLFxyXG5cdFx0XHRcdHZhbHVlLFxyXG5cdFx0XHRcdGlzRXhhY3QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZXZlbnRGaWx0ZXJzLmFkZEZpbHRlcihcclxuXHRcdFx0ZXZlbnROYW1lLFxyXG5cdFx0XHRjb25maWdQcm9wZXJ0eU5hbWUsXHJcblx0XHRcdHZhbHVlLFxyXG5cdFx0XHRpc0V4YWN0KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhFQURFUl9QUk9QRVJUWSA9IC9eKHJlcXVlc3RIZWFkZXJ8cmVzcG9uc2VIZWFkZXIpKC4qKS87XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgaGVhZGVyIHByb3BlcnR5IHRvIGJlIGxvd2VyIGNhc2UuXHJcblx0ICogTGVhdmUgb3RoZXIgcHJvcGVydGllcyBhcy1pcy5cclxuXHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBub3JtYWxpemVQcm9wZXJ0eShwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBncm91cHMgPSBwcm9wZXJ0eU5hbWUubWF0Y2goRXZlbnRDb25maWd1cmF0aW9uLkhFQURFUl9QUk9QRVJUWSk7XHJcblx0XHRpZiAoZ3JvdXBzICE9IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGdyb3Vwc1sxXSArIGdyb3Vwc1syXS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHByb3BlcnR5TmFtZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgbWFuZGF0b3J5IHByb3BlcnR5IG5hbWVzIGFyZSBpbiB0aGUgY29uZmlndXJhdGlvblxyXG5cdHByaXZhdGUgdmVyaWZ5TWFuZGF0b3J5UHJvcGVydGllcygpOiB2b2lkIHtcclxuXHRcdGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE1BTkRBVE9SWV9QUk9QRVJUSUVTKSB7XHJcblx0XHRcdGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5ldmVudEZpbHRlcnMuZ2V0RXZlbnROYW1lcygpKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRGaWx0ZXIoZXZlbnQsIHByb3BlcnR5TmFtZSwgXCIuKlwiLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDYW5iZUxhenkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvbGF6eVwiO1xyXG5pbXBvcnQgeyBDb25maWd1cmF0aW9uRmlsdGVycyB9IGZyb20gXCIuL0NvbmZpZ3VyYXRpb25GaWx0ZXJzXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRXZlbnRGaWx0ZXJzIHtcclxuXHRwcml2YXRlIHJlYWRvbmx5IGV2ZW50RmlsdGVyczogeyBbZXZlbnROYW1lOiBzdHJpbmddOiBDb25maWd1cmF0aW9uRmlsdGVyczsgfSA9IHt9O1xyXG5cclxuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgcmVhZG9ubHktYXJyYXlcclxuXHRwdWJsaWMgZ2V0RXZlbnROYW1lcygpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5ldmVudEZpbHRlcnMpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEV2ZW50RmlsdGVycyhldmVudE5hbWU6IHN0cmluZyk6IENvbmZpZ3VyYXRpb25GaWx0ZXJzIHtcclxuXHRcdHJldHVybiB0aGlzLmV2ZW50RmlsdGVyc1tldmVudE5hbWVdO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZEZpbHRlcihldmVudE5hbWU6IHN0cmluZywgcHJvcGVydHlOYW1lOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZywgaXNFeGFjdDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuZXZlbnRGaWx0ZXJzW2V2ZW50TmFtZV0gPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmV2ZW50RmlsdGVyc1tldmVudE5hbWVdID0gbmV3IENvbmZpZ3VyYXRpb25GaWx0ZXJzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ldmVudEZpbHRlcnNbZXZlbnROYW1lXS5hZGRGaWx0ZXIocHJvcGVydHlOYW1lLCBwYXR0ZXJuLCBpc0V4YWN0KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBoYXNGaWx0ZXIoZXZlbnROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBldmVudE5hbWUgaW4gdGhpcy5ldmVudEZpbHRlcnM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNNYXRjaChldmVudE5hbWU6IHN0cmluZywgcHJvcGVydHlOYW1lOiBzdHJpbmcsIGlucHV0OiBDYW5iZUxhenk8c3RyaW5nPik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgZmlsdGVycyA9IHRoaXMuZXZlbnRGaWx0ZXJzW2V2ZW50TmFtZV07XHJcblx0XHRyZXR1cm4gZmlsdGVycyAhPSBudWxsICYmIGZpbHRlcnMuaXNNYXRjaChwcm9wZXJ0eU5hbWUsIGlucHV0KTtcclxuXHR9XHJcbn1cclxuIiwiOyhmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogZXhwb3J0IFNpbXBsZUxSVSBmb3IgQ29tbW9uSlMsIEFNRFxuICAgKi9cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBTaW1wbGVMUlU7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUxSVTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5TaW1wbGVMUlUgPSBTaW1wbGVMUlU7XG4gIH1cblxuICBTaW1wbGVMUlUudmVyc2lvbiA9ICcwLjAuMyc7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBtaXhpbiB1dGlsaXR5XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kKG9iajEsIG9iajIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMikgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLyoqXG4gICAqIE9iamVjdCBkYXRhIHN0b3JlXG4gICAqIHRoaXMgaXMgYSBgT2JqZWN0LmNyZWF0ZWAgZmFsbGJhY2sgaW4gb3JkZXIgdG8gc3VwcG9ydCBJRThcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YXIgRGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERhdGEsIHByb3RvO1xuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVDcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5hdGl2ZUNyZWF0ZShudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHByb3RvID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiAhISB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgIH07XG5cbiAgICAgIHByb3RvID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZGF0YSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBleHRlbmQocHJvdG8sIHtcbiAgICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gdmFsO1xuICAgICAgfSxcbiAgICAgIGRlbDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtrZXldO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4dGVuZChEYXRhLnByb3RvdHlwZSwgcHJvdG8pO1xuXG4gICAgcmV0dXJuIERhdGE7XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIENhY2hlIGVudHJ5IGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfVxuICAgKiBAcGFyYW0ge2FueX1cbiAgICogQHBhcmFtIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gRW50cnkoa2V5LCB2YWwsIGluZGV4KSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsZUxSVSBjb25zdHJ1Y3RvclxuICAgKiBJdCBob2xkcyBmb2xsb3dpbmcgcHJpdmF0ZSBwcm9wZXJ0aWVzLiBTZWUgYCNyZXNldCgpYFxuICAgKlxuICAgKiAgIF9ieUtleSAgICB7RGF0YX0gICAgbWFwIGJ5IGtleVxuICAgKiAgIF9ieU9yZGVyICB7T2JqZWN0fSAgbWFwIGJ5IHJlY2VudGx5IHVzZWQgb3JkZXJcbiAgICogICBfaGVhZCAgICAge051bWJlcn0gIGluZGV4IG9mIG5leHQgZW50cnlcbiAgICogICBfdGFpbCAgICAge051bWJlcn0gIGluZGV4IG9mIGxlYXN0IHJlY2VudGx5IHVzZWQgY2FjaGUgaXRlbVxuICAgKiAgIF9sZW4gICAgICB7TnVtYmVyfSAgdG90YWwgbnVtYmVyIG9mIGNhY2hlIGl0ZW1zXG4gICAqXG4gICAqIGBfdGFpbGAgaXMgYW4gaW5kZXggb2YgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgY2FjaGUgaXRlbS5cbiAgICogYF9oZWFkYCBpcyBhbiBpbmRleCBvZiB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGNhY2hlIGl0ZW0gKnBsdXMqIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heCBsZW5ndGggb2YgY2FjaGUgaXRlbVxuICAgKi9cbiAgZnVuY3Rpb24gU2ltcGxlTFJVKG1heCkge1xuICAgIGlmICh0eXBlb2YgbWF4ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IGlzIHJlcXVyaWVkJyk7XG4gICAgdGhpcy5tYXgobWF4KTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBleHRlbmQoU2ltcGxlTFJVLnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogU2V0IGNhY2hlIGJ5IGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1bmlxdWUgc3RyaW5nIGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxOdW1iZXJ9IGFueSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLl9ieUtleS5nZXQoa2V5KTtcblxuICAgICAgLy8gcmV1c2UgZW50cnkgaWYgdGhlIGtleSBleGlzdHNcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICB0aGlzLl90b3VjaChlbnRyeSk7XG4gICAgICAgIGVudHJ5LnZhbCA9IHZhbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbnRyeSA9IG5ldyBFbnRyeShrZXksIHZhbCwgdGhpcy5faGVhZCsrKTtcbiAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIGVudHJ5KTtcbiAgICAgIHRoaXMuX2J5T3JkZXJbZW50cnkuaW5kZXhdID0gZW50cnk7XG4gICAgICB0aGlzLl9sZW4rKztcbiAgICAgIHRoaXMuX3RyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVsZXRlIGNhY2hlIGJ5IGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAgICogQHJldHVybiB7U3RyaW5nfE9iamVjdHxOdW1iZXJ9IGNhY2hlZCB2YWx1ZVxuICAgICAqL1xuICAgIGRlbDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fYnlLZXkuZGVsKGtleSk7XG4gICAgICBpZiAoIWVudHJ5KSByZXR1cm47XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9ieU9yZGVyW2VudHJ5LmluZGV4XTtcbiAgICAgIHRoaXMuX2xlbi0tO1xuXG4gICAgICBpZiAodGhpcy5fbGVuID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSBtb3N0IGluZGV4IGlmIGl0IHdhcyBtb3N0IGxlY2VudGx5IHVzZWQgZW50cnlcbiAgICAgICAgaWYgKGVudHJ5LmluZGV4ID09PSB0aGlzLl9oZWFkIC0gMSkgdGhpcy5fcG9wKCk7XG4gICAgICAgIC8vIHVwZGF0ZSBsZWFzdCBpbmRleCBpZiBpdCB3YXMgbGVhc3QgbGVjZW50bHkgdXNlZCBlbnRyeVxuICAgICAgICBpZiAoZW50cnkuaW5kZXggPT09IHRoaXMuX3RhaWwpIHRoaXMuX3NoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBjYWNoZSBieSBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfVxuICAgICAqIEByZXR1cm4ge2FueX0gY2FjaGUgaWYgaXQgZXhpc3RzXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLl9ieUtleS5nZXQoa2V5KTtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICB0aGlzLl90b3VjaChlbnRyeSk7XG4gICAgICAgIHJldHVybiBlbnRyeS52YWw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIGNhY2hlIGJ5IGtleSB3aXRob3V0IHRvdWNoaW5nIGluZGV4XG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIHBlZWs6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2J5S2V5LmdldChrZXkpO1xuICAgICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnkudmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZWUgaWYga2V5IGlzIGV4aXN0cyBvciBub3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J5S2V5LmhhcyhrZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0b3RhbCBudW1iZXIgb2YgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjbGVhciBhbGwgc3RvcmVkIGNhY2hlXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IERhdGEoKTtcbiAgICAgIHRoaXMuX2J5T3JkZXIgPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuX2hlYWQgPSAwO1xuICAgICAgdGhpcy5fdGFpbCA9IDA7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXR0ZXJ8U2V0dGVyIGZ1bmN0aW9uIG9mIFwibWF4XCIgb3B0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlmIHNldHRlclxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24gKG1heCkge1xuICAgICAgaWYgKHR5cGVvZiBtYXggIT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5fbWF4O1xuICAgICAgaWYgKG1heCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIHZhciBzaHJpbmsgPSAodGhpcy5fbWF4IHx8IDApID4gbWF4O1xuICAgICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgICAgaWYgKHNocmluaykgdGhpcy5fdHJpbSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYXJyYXkgb2Yga2V5cyBpbiBsZWFzdCByZWNlbnRseSB1c2VkIG9yZGVyXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAga2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvdW50ID0gMFxuICAgICAgICAsIHRhaWwgPSB0aGlzLl90YWlsXG4gICAgICAgICwgaGVhZCA9IHRoaXMuX2hlYWRcbiAgICAgICAgLCBrZXlzID0gbmV3IEFycmF5KHRoaXMuX2xlbik7XG5cbiAgICAgIGZvciAodmFyIGkgPSB0YWlsOyBpIDwgaGVhZDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2J5T3JkZXJbaV07XG4gICAgICAgIGlmIChlbnRyeSkga2V5c1tjb3VudCsrXSA9IGVudHJ5LmtleTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBsZWFzdCByZWNlbnRseSB1c2VkIGluZGV4IG9mIGFuIGVudHJ5IHRvIFwiX2hlYWRcIlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbnRyeX1cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG91Y2g6IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgLy8gdXBkYXRlIG1vc3QgbnVtYmVyIHRvIGtleVxuICAgICAgaWYgKGVudHJ5LmluZGV4ICE9PSB0aGlzLl9oZWFkIC0gMSkge1xuICAgICAgICB2YXIgaXNUYWlsID0gZW50cnkuaW5kZXggPT09IHRoaXMuX3RhaWw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieU9yZGVyW2VudHJ5LmluZGV4XTtcbiAgICAgICAgZW50cnkuaW5kZXggPSB0aGlzLl9oZWFkKys7XG4gICAgICAgIHRoaXMuX2J5T3JkZXJbZW50cnkuaW5kZXhdID0gZW50cnk7XG4gICAgICAgIGlmIChpc1RhaWwpIHRoaXMuX3NoaWZ0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRyaW0gZW50cmllc1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIF90cmltOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF4ID0gdGhpcy5fbWF4O1xuICAgICAgd2hpbGUgKG1heCA8IHRoaXMuX2xlbikge1xuICAgICAgICB2YXIgdGFpbEVudHJ5ID0gdGhpcy5fYnlPcmRlclt0aGlzLl90YWlsXTtcbiAgICAgICAgdGhpcy5kZWwodGFpbEVudHJ5LmtleSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0YWlsIGluZGV4XG4gICAgICogQHJldHVybiB7RW50cnl8dW5kZWZpbmVkfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaGlmdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhaWwgPSB0aGlzLl90YWlsXG4gICAgICAgICwgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBmb3IgKHZhciBpID0gdGFpbDsgaSA8IGhlYWQ7IGkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9ieU9yZGVyW2ldO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB0aGlzLl90YWlsID0gaTtcbiAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIGhlYWQgaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgX3BvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhaWwgPSB0aGlzLl90YWlsXG4gICAgICAgICwgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBmb3IgKHZhciBpID0gaGVhZCAtIDE7IGkgPj0gdGFpbDsgaS0tKSB7XG4gICAgICAgIHZhciBoZWFkRW50cnkgPSB0aGlzLl9ieU9yZGVyW2ldO1xuICAgICAgICBpZiAoaGVhZEVudHJ5KSB7XG4gICAgICAgICAgdGhpcy5faGVhZCA9IGkgKyAxO1xuICAgICAgICAgIHJldHVybiBoZWFkRW50cnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG59KSgpOyIsImltcG9ydCB7IElEb3dubG9hZHNNb25pdG9yaW5nIH0gZnJvbSBcIi4vSURvd25sb2Fkc01vbml0b3JpbmdcIjtcclxuaW1wb3J0IHsgSUJhY2tncm91bmRNYW5hZ2VyIH0gZnJvbSBcIi4vSUJhY2tncm91bmRNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IElBZ2VudENvbW11bmljYXRpb24gfSBmcm9tIFwiLi9JQWdlbnRDb21tdW5pY2F0aW9uXCI7XHJcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCIuLi91dGlscy9sb2dcIjtcclxuLy8gaW1wb3J0IHsgQmFja2dyb3VuZFBhZ2VJbmZvcm1hdGlvbiB9IGZyb20gXCIuLi9jb21tb24vUGFnZUluZm9ybWF0aW9uXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VUeXBlLCBPdXRnb2luZ0Jhc2VOYXRpdmVNZXNzYWdlLCBPdXRnb2luZ0V2ZW50TWVzc2FnZURhdGEgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NhZ2luZ01vZGVsXCI7XHJcbmltcG9ydCB7IFVYRGF0YSB9IGZyb20gXCIuLi9jb21tb24vVVhEYXRhXCI7XHJcbmltcG9ydCB7IHRpbWVQcm92aWRlciB9IGZyb20gXCIuLi91dGlscy90aW1lUHJvdmlkZXJcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBET1dOTE9BRFNfRVZFTlRfTkFNRVNQQUNFID0gXCJ1aTpjaHJvbWU6RG93bmxvYWRzXCI7XHJcblxyXG5jbGFzcyBEb3dubG9hZEl0ZW0gaW1wbGVtZW50cyBjaHJvbWUuZG93bmxvYWRzLkRvd25sb2FkSXRlbSB7XHJcblx0LyoqIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBzbyBmYXIgZnJvbSB0aGUgaG9zdCwgd2l0aG91dCBjb25zaWRlcmluZyBmaWxlIGNvbXByZXNzaW9uLiAqL1xyXG5cdHB1YmxpYyBieXRlc1JlY2VpdmVkITogbnVtYmVyO1xyXG5cdC8qKiBJbmRpY2F0aW9uIG9mIHdoZXRoZXIgdGhpcyBkb3dubG9hZCBpcyB0aG91Z2h0IHRvIGJlIHNhZmUgb3Iga25vd24gdG8gYmUgc3VzcGljaW91cy4gKi9cclxuXHRwdWJsaWMgZGFuZ2VyITogY2hyb21lLmRvd25sb2Fkcy5EYW5nZXJUeXBlO1xyXG5cdC8qKiBBYnNvbHV0ZSBkb3dubG9hZCBVUkwuID09IGZpbmFsVXJsPyAqL1xyXG5cdHB1YmxpYyB1cmwhOiBzdHJpbmc7XHJcblx0LyoqXHJcblx0ICogVGhlIGFic29sdXRlIFVSTCB0aGF0IHRoaXMgZG93bmxvYWQgaXMgYmVpbmcgbWFkZSBmcm9tLCBhZnRlciBhbGwgcmVkaXJlY3RzLlxyXG5cdCAqIEBzaW5jZSBTaW5jZSBDaHJvbWUgNTQuXHJcblx0ICovXHJcblx0cHVibGljIGZpbmFsVXJsITogc3RyaW5nO1xyXG5cdC8qKiBOdW1iZXIgb2YgYnl0ZXMgaW4gdGhlIHdob2xlIGZpbGUsIHdpdGhvdXQgY29uc2lkZXJpbmcgZmlsZSBjb21wcmVzc2lvbiwgb3IgLTEgaWYgdW5rbm93bi4gKi9cclxuXHRwdWJsaWMgdG90YWxCeXRlcyE6IG51bWJlcjtcclxuXHQvKiogQWJzb2x1dGUgbG9jYWwgcGF0aC4gKi9cclxuXHRwdWJsaWMgZmlsZW5hbWUhOiBzdHJpbmc7XHJcblx0LyoqIFRydWUgaWYgdGhlIGRvd25sb2FkIGhhcyBzdG9wcGVkIHJlYWRpbmcgZGF0YSBmcm9tIHRoZSBob3N0LCBidXQga2VwdCB0aGUgY29ubmVjdGlvbiBvcGVuLiAqL1xyXG5cdHB1YmxpYyBwYXVzZWQhOiBib29sZWFuO1xyXG5cdC8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZG93bmxvYWQgaXMgcHJvZ3Jlc3NpbmcsIGludGVycnVwdGVkLCBvciBjb21wbGV0ZS4gKi9cclxuXHRwdWJsaWMgc3RhdGUhOiBjaHJvbWUuZG93bmxvYWRzLkRvd25sb2FkU3RhdGU7XHJcblx0LyoqIFRoZSBmaWxlJ3MgTUlNRSB0eXBlLiAqL1xyXG5cdHB1YmxpYyBtaW1lITogc3RyaW5nO1xyXG5cdC8qKiBOdW1iZXIgb2YgYnl0ZXMgaW4gdGhlIHdob2xlIGZpbGUgcG9zdC1kZWNvbXByZXNzaW9uLCBvciAtMSBpZiB1bmtub3duLiAqL1xyXG5cdHB1YmxpYyBmaWxlU2l6ZSE6IG51bWJlcjtcclxuXHQvKiogVGhlIHRpbWUgd2hlbiB0aGUgZG93bmxvYWQgYmVnYW4gaW4gSVNPIDg2MDEgZm9ybWF0LiBNYXkgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBEYXRlIGNvbnN0cnVjdG9yOlxyXG5cdCAqIGNocm9tZS5kb3dubG9hZHMuc2VhcmNoKHt9LCBmdW5jdGlvbihpdGVtcyl7aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtjb25zb2xlLmxvZyhuZXcgRGF0ZShpdGVtLnN0YXJ0VGltZSkpfSl9KVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdGFydFRpbWUhOiBzdHJpbmc7XHJcblx0LyoqIE9wdGlvbmFsLiBXaHkgdGhlIGRvd25sb2FkIHdhcyBpbnRlcnJ1cHRlZC4gU2V2ZXJhbCBraW5kcyBvZiBIVFRQIGVycm9ycyBtYXkgYmUgZ3JvdXBlZCB1bmRlciBvbmUgb2YgdGhlIGVycm9yc1xyXG5cdCAqIGJlZ2lubmluZyB3aXRoIFNFUlZFUl8uIEVycm9ycyByZWxhdGluZyB0byB0aGUgbmV0d29yayBiZWdpbiB3aXRoIE5FVFdPUktfLCBlcnJvcnMgcmVsYXRpbmcgdG8gdGhlIHByb2Nlc3Mgb2ZcclxuXHQgKiB3cml0aW5nIHRoZSBmaWxlIHRvIHRoZSBmaWxlIHN5c3RlbSBiZWdpbiB3aXRoIEZJTEVfLCBhbmQgaW50ZXJydXB0aW9ucyBpbml0aWF0ZWQgYnkgdGhlIHVzZXIgYmVnaW4gd2l0aCBVU0VSXy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXJyb3I/OiBjaHJvbWUuZG93bmxvYWRzLkRvd25sb2FkSW50ZXJydXB0UmVhc29uO1xyXG5cdC8qKiBPcHRpb25hbC4gVGhlIHRpbWUgd2hlbiB0aGUgZG93bmxvYWQgZW5kZWQgaW4gSVNPIDg2MDEgZm9ybWF0LiBNYXkgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBEYXRlIGNvbnN0cnVjdG9yOlxyXG5cdCAqIGNocm9tZS5kb3dubG9hZHMuc2VhcmNoKHt9LCBmdW5jdGlvbihpdGVtcyl7aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtpZiAoaXRlbS5lbmRUaW1lKSBjb25zb2xlLmxvZyhuZXcgRGF0ZShpdGVtLmVuZFRpbWUpKX0pfSlcclxuXHQgKi9cclxuXHRwdWJsaWMgZW5kVGltZT86IHN0cmluZztcclxuXHQvKiogQW4gaWRlbnRpZmllciB0aGF0IGlzIHBlcnNpc3RlbnQgYWNyb3NzIGJyb3dzZXIgc2Vzc2lvbnMuICovXHJcblx0cHVibGljIGlkITogbnVtYmVyO1xyXG5cdC8qKiBGYWxzZSBpZiB0aGlzIGRvd25sb2FkIGlzIHJlY29yZGVkIGluIHRoZSBoaXN0b3J5LCB0cnVlIGlmIGl0IGlzIG5vdCByZWNvcmRlZC4gKi9cclxuXHRwdWJsaWMgaW5jb2duaXRvITogYm9vbGVhbjtcclxuXHQvKiogQWJzb2x1dGUgVVJMLiAqL1xyXG5cdHB1YmxpYyByZWZlcnJlciE6IHN0cmluZztcclxuXHQvKiogT3B0aW9uYWwuIEVzdGltYXRlZCB0aW1lIHdoZW4gdGhlIGRvd25sb2FkIHdpbGwgY29tcGxldGUgaW4gSVNPIDg2MDEgZm9ybWF0LiBNYXkgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBEYXRlXHJcblx0ICogY29uc3RydWN0b3I6IGNocm9tZS5kb3dubG9hZHMuc2VhcmNoKHt9LCBmdW5jdGlvbihpdGVtcyl7aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtpZiAoaXRlbS5lc3RpbWF0ZWRFbmRUaW1lKVxyXG5cdCAqIGNvbnNvbGUubG9nKG5ldyBEYXRlKGl0ZW0uZXN0aW1hdGVkRW5kVGltZSkpfSl9KVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBlc3RpbWF0ZWRFbmRUaW1lPzogc3RyaW5nO1xyXG5cdC8qKiBUcnVlIGlmIHRoZSBkb3dubG9hZCBpcyBpbiBwcm9ncmVzcyBhbmQgcGF1c2VkLCBvciBlbHNlIGlmIGl0IGlzIGludGVycnVwdGVkIGFuZCBjYW4gYmUgcmVzdW1lZCBzdGFydGluZyBmcm9tXHJcblx0ICogd2hlcmUgaXQgd2FzIGludGVycnVwdGVkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYW5SZXN1bWUhOiBib29sZWFuO1xyXG5cdC8qKiBXaGV0aGVyIHRoZSBkb3dubG9hZGVkIGZpbGUgc3RpbGwgZXhpc3RzLiBUaGlzIGluZm9ybWF0aW9uIG1heSBiZSBvdXQgb2YgZGF0ZSBiZWNhdXNlIENocm9tZSBkb2VzIG5vdFxyXG5cdCAqIGF1dG9tYXRpY2FsbHkgd2F0Y2ggZm9yIGZpbGUgcmVtb3ZhbC4gQ2FsbCBzZWFyY2goKSBpbiBvcmRlciB0byB0cmlnZ2VyIHRoZSBjaGVjayBmb3IgZmlsZSBleGlzdGVuY2UuXHJcblx0ICogV2hlbiB0aGUgZXhpc3RlbmNlIGNoZWNrIGNvbXBsZXRlcywgaWYgdGhlIGZpbGUgaGFzIGJlZW4gZGVsZXRlZCwgdGhlbiBhbiBvbkNoYW5nZWQgZXZlbnQgd2lsbCBmaXJlLlxyXG5cdCAqIE5vdGUgdGhhdCBzZWFyY2goKSBkb2VzIG5vdCB3YWl0IGZvciB0aGUgZXhpc3RlbmNlIGNoZWNrIHRvIGZpbmlzaCBiZWZvcmUgcmV0dXJuaW5nLCBzbyByZXN1bHRzIGZyb21cclxuXHQgKiBzZWFyY2goKSBtYXkgbm90IGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgZmlsZSBzeXN0ZW0uIEFsc28sIHNlYXJjaCgpIG1heSBiZSBjYWxsZWQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5LFxyXG5cdCAqIGJ1dCB3aWxsIG5vdCBjaGVjayBmb3IgZmlsZSBleGlzdGVuY2UgYW55IG1vcmUgZnJlcXVlbnRseSB0aGFuIG9uY2UgZXZlcnkgMTAgc2Vjb25kcy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXhpc3RzITogYm9vbGVhbjtcclxuXHQvKiogT3B0aW9uYWwuIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgZXh0ZW5zaW9uIHRoYXQgaW5pdGlhdGVkIHRoaXMgZG93bmxvYWQgaWYgdGhpcyBkb3dubG9hZCB3YXNcclxuXHQgKiBpbml0aWF0ZWQgYnkgYW4gZXh0ZW5zaW9uLiBEb2VzIG5vdCBjaGFuZ2Ugb25jZSBpdCBpcyBzZXQuXHJcblx0ICovXHJcblx0cHVibGljIGJ5RXh0ZW5zaW9uSWQ/OiBzdHJpbmc7XHJcblx0LyoqIE9wdGlvbmFsLiBUaGUgbG9jYWxpemVkIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiB0aGF0IGluaXRpYXRlZCB0aGlzIGRvd25sb2FkIGlmIHRoaXMgZG93bmxvYWRcclxuXHQgKiB3YXMgaW5pdGlhdGVkIGJ5IGFuIGV4dGVuc2lvbi4gTWF5IGNoYW5nZSBpZiB0aGUgZXh0ZW5zaW9uIGNoYW5nZXMgaXRzIG5hbWUgb3IgaWYgdGhlIHVzZXIgY2hhbmdlcyB0aGVpciBsb2NhbGUuXHJcblx0ICovXHJcblx0cHVibGljIGJ5RXh0ZW5zaW9uTmFtZT86IHN0cmluZztcclxuXHRwdWJsaWMgdG90YWxUaW1lTWlsbGlzOiBudW1iZXI7XHJcblx0cHVibGljIGludGVyYWN0aW9uVGltZU1pbGxpczogbnVtYmVyO1xyXG5cdHB1YmxpYyB0cmFuc2ZlclRpbWVNaWxsaXM6IG51bWJlcjtcclxuXHRwdWJsaWMgbGFzdFJlc3VtZVRpbWU6IG51bWJlcjsgICAvLyBvbkNyZWF0ZWQuc3RhcnRUaW1lXHJcblxyXG5cdGNvbnN0cnVjdG9yKGl0ZW06IGNocm9tZS5kb3dubG9hZHMuRG93bmxvYWRJdGVtKSB7XHJcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIGl0ZW0pO1xyXG5cclxuXHRcdHRoaXMudG90YWxUaW1lTWlsbGlzID0gMDtcclxuXHRcdHRoaXMuaW50ZXJhY3Rpb25UaW1lTWlsbGlzID0gMDtcclxuXHRcdHRoaXMudHJhbnNmZXJUaW1lTWlsbGlzID0gMDtcclxuXHRcdHRoaXMubGFzdFJlc3VtZVRpbWUgPSBuZXcgRGF0ZShpdGVtLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xyXG5cdFx0dGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgZ2V0RG93bmxvYWRJbnRlcnJ1cHRSZWFzb24ocmVhc29uOiBzdHJpbmcpOiBjaHJvbWUuZG93bmxvYWRzLkRvd25sb2FkSW50ZXJydXB0UmVhc29uIHtcclxuXHRcdHN3aXRjaCAocmVhc29uKSB7XHJcblx0XHRcdGNhc2UgXCJGSUxFX0ZBSUxFRFwiOlxyXG5cdFx0XHRjYXNlIFwiRklMRV9BQ0NFU1NfREVOSUVEXCI6XHJcblx0XHRcdGNhc2UgXCJGSUxFX05PX1NQQUNFXCI6XHJcblx0XHRcdGNhc2UgXCJGSUxFX05BTUVfVE9PX0xPTkdcIjpcclxuXHRcdFx0Y2FzZSBcIkZJTEVfVE9PX0xBUkdFXCI6XHJcblx0XHRcdGNhc2UgXCJGSUxFX1ZJUlVTX0lORkVDVEVEXCI6XHJcblx0XHRcdGNhc2UgXCJGSUxFX1RSQU5TSUVOVF9FUlJPUlwiOlxyXG5cdFx0XHRjYXNlIFwiRklMRV9CTE9DS0VEXCI6XHJcblx0XHRcdGNhc2UgXCJGSUxFX1NFQ1VSSVRZX0NIRUNLX0ZBSUxFRFwiOlxyXG5cdFx0XHRjYXNlIFwiRklMRV9UT09fU0hPUlRcIjpcclxuXHRcdFx0Y2FzZSBcIkZJTEVfSEFTSF9NSVNNQVRDSFwiOlxyXG5cdFx0XHRjYXNlIFwiRklMRV9TQU1FX0FTX1NPVVJDRVwiOlxyXG5cdFx0XHRjYXNlIFwiTkVUV09SS19GQUlMRURcIjpcclxuXHRcdFx0Y2FzZSBcIk5FVFdPUktfVElNRU9VVFwiOlxyXG5cdFx0XHRjYXNlIFwiTkVUV09SS19ESVNDT05ORUNURURcIjpcclxuXHRcdFx0Y2FzZSBcIk5FVFdPUktfU0VSVkVSX0RPV05cIjpcclxuXHRcdFx0Y2FzZSBcIk5FVFdPUktfSU5WQUxJRF9SRVFVRVNUXCI6XHJcblx0XHRcdGNhc2UgXCJTRVJWRVJfRkFJTEVEXCI6XHJcblx0XHRcdGNhc2UgXCJTRVJWRVJfTk9fUkFOR0VcIjpcclxuXHRcdFx0Y2FzZSBcIlNFUlZFUl9CQURfQ09OVEVOVFwiOlxyXG5cdFx0XHRjYXNlIFwiU0VSVkVSX1VOQVVUSE9SSVpFRFwiOlxyXG5cdFx0XHRjYXNlIFwiU0VSVkVSX0NFUlRfUFJPQkxFTVwiOlxyXG5cdFx0XHRjYXNlIFwiU0VSVkVSX0ZPUkJJRERFTlwiOlxyXG5cdFx0XHRjYXNlIFwiU0VSVkVSX1VOUkVBQ0hBQkxFXCI6XHJcblx0XHRcdGNhc2UgXCJTRVJWRVJfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0hcIjpcclxuXHRcdFx0Y2FzZSBcIlNFUlZFUl9DUk9TU19PUklHSU5fUkVESVJFQ1RcIjpcclxuXHRcdFx0Y2FzZSBcIlVTRVJfQ0FOQ0VMRURcIjpcclxuXHRcdFx0Y2FzZSBcIlVTRVJfU0hVVERPV05cIjpcclxuXHRcdFx0Y2FzZSBcIkNSQVNIXCI6XHJcblx0XHRcdFx0cmV0dXJuIHJlYXNvbjtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRyZXR1cm4gXCJDUkFTSFwiO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gVGhlIHNlbnQgbWVzc2FnZSBkb2VzICpub3QqIGluY2x1ZGUgdGFiL2ZyYW1lIGluZm8uIFNvIGl0IGV4dGVuZHMgQmFzZU5hdGl2ZU1lc3NhZ2UsXHJcbi8vIG5vdCBQYWdlTmF0aXZlTWVzc2FnZS5cclxuZXhwb3J0IGNsYXNzIE91dGdvaW5nRG93bmxvYWRNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdCYXNlTmF0aXZlTWVzc2FnZSB7XHJcblx0cHVibGljIG1lc3NhZ2VEYXRhOiBPdXRnb2luZ0V2ZW50TWVzc2FnZURhdGE8VVhEYXRhPjtcclxuXHJcblx0Y29uc3RydWN0b3IoZXZlbnRUeXBlOiBzdHJpbmcsIHRpbWVTdGFtcDogbnVtYmVyKSB7XHJcblx0XHRzdXBlcihNZXNzYWdlVHlwZS5FVkVOVCwgdGltZVN0YW1wKTtcclxuXHRcdHRoaXMubWVzc2FnZURhdGEgPSB7XHJcblx0XHRcdEV2ZW50VHlwZTogZXZlbnRUeXBlLFxyXG5cdFx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55XHJcblx0XHRcdERhdGE6IFsoe30pIGFzIGFueSBhcyBVWERhdGFdXHJcblx0XHR9O1xyXG5cdH1cclxufVxyXG5cclxuaW50ZXJmYWNlIERvd25sb2FkcyB7XHJcblx0W2lkOiBudW1iZXJdOiBEb3dubG9hZEl0ZW07XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBEb3dubG9hZHNNb25pdG9yaW5nIGltcGxlbWVudHMgSURvd25sb2Fkc01vbml0b3Jpbmcge1xyXG5cdHByaXZhdGUgbWFuYWdlcj86IElCYWNrZ3JvdW5kTWFuYWdlcjsgICAvLyBmb3IgY29uZmlndXJhdGlvblxyXG5cdHByaXZhdGUgY29tbXVuaWNhdGlvbj86IElBZ2VudENvbW11bmljYXRpb247XHJcblx0Ly8gVE9ETzogRXZlciBhY2N1bXVsYXRpbmc/IFNob3VsZG4ndCB3ZSByZW1vdmUgaXRlbXMgYWZ0ZXIgd2Ugc2VuZCBhIGNvbXBsZXRlL2ZhaWxlZCBtZXNzYWdlIGZvciB0aGVtP1xyXG5cdHByaXZhdGUgcmVhZG9ubHkgZG93bmxvYWRzOiBEb3dubG9hZHM7XHJcblx0cHJpdmF0ZSByZWFkb25seSBhY3RpdmVEb3dubG9hZElEczogbnVtYmVyW107XHJcblx0cHJpdmF0ZSBwb2xsaW5nVGltZXI/OiBOb2RlSlMuVGltZXIgO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHRoaXMuZG93bmxvYWRzID0ge307XHJcblx0XHR0aGlzLmFjdGl2ZURvd25sb2FkSURzID0gW107XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaW5pdERvd25sb2Fkc01vbml0b3JpbmcobWFuYWdlcjogSUJhY2tncm91bmRNYW5hZ2VyLCBjb21tdW5pY2F0aW9uOiBJQWdlbnRDb21tdW5pY2F0aW9uKTogdm9pZCB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHRcdHRoaXMuY29tbXVuaWNhdGlvbiA9IGNvbW11bmljYXRpb247XHJcblxyXG5cdFx0Y2hyb21lLmRvd25sb2Fkcy5vbkNoYW5nZWQuYWRkTGlzdGVuZXIodGhpcy5vbkRvd25sb2FkQ2hhbmdlZCk7XHJcblx0XHRjaHJvbWUuZG93bmxvYWRzLm9uQ3JlYXRlZC5hZGRMaXN0ZW5lcih0aGlzLm9uRG93bmxvYWRDcmVhdGVkKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1bmluaXREb3dubG9hZHNNb25pdG9yaW5nKCk6IHZvaWQge1xyXG5cdFx0Y2hyb21lLmRvd25sb2Fkcy5vbkNoYW5nZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkRvd25sb2FkQ2hhbmdlZCk7XHJcblx0XHRjaHJvbWUuZG93bmxvYWRzLm9uQ3JlYXRlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uRG93bmxvYWRDcmVhdGVkKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgbWFrZUV2ZW50TmFtZShldmVudDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBET1dOTE9BRFNfRVZFTlRfTkFNRVNQQUNFICsgXCIuXCIgKyBldmVudDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgY3JlYXRlRGF0YU1lc3NhZ2UoZXZlbnQ6IHN0cmluZywgaXRlbTogRG93bmxvYWRJdGVtKTogT3V0Z29pbmdEb3dubG9hZE1lc3NhZ2Uge1xyXG5cdFx0Y29uc3QgbWVzc2FnZSA9IG5ldyBPdXRnb2luZ0Rvd25sb2FkTWVzc2FnZSh0aGlzLm1ha2VFdmVudE5hbWUoZXZlbnQpLCB0aW1lUHJvdmlkZXIubm93KCkpO1xyXG5cdFx0Y29uc3QgbWVzc2FnZURhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0bWVzc2FnZURhdGEuZG93bmxvYWRVcmwgPSBpdGVtLnVybDtcclxuXHRcdG1lc3NhZ2VEYXRhLnJlZmVycmVyUGFnZVVybCA9IGl0ZW0ucmVmZXJyZXI7XHJcblx0XHRtZXNzYWdlRGF0YS50b3RhbEJ5dGVzID0gaXRlbS50b3RhbEJ5dGVzO1xyXG5cdFx0bWVzc2FnZURhdGEuZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xyXG5cdFx0bWVzc2FnZURhdGEubWltZSA9IGl0ZW0ubWltZTtcclxuXHRcdG1lc3NhZ2VEYXRhLnN0YXJ0VGltZSA9IG5ldyBEYXRlKGl0ZW0uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XHJcblxyXG5cdFx0aWYgKGl0ZW0uZXJyb3IgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRtZXNzYWdlRGF0YS5lcnJvciA9IGl0ZW0uZXJyb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0bWVzc2FnZURhdGEudG90YWxUaW1lTWlsbGlzID0gaXRlbS50b3RhbFRpbWVNaWxsaXM7XHJcblx0XHRtZXNzYWdlRGF0YS50cmFuc2ZlclRpbWVNaWxsaXMgPSBpdGVtLnRyYW5zZmVyVGltZU1pbGxpcztcclxuXHRcdG1lc3NhZ2VEYXRhLmludGVyYWN0aW9uVGltZU1pbGxpcyA9IGl0ZW0uaW50ZXJhY3Rpb25UaW1lTWlsbGlzO1xyXG5cdFx0bWVzc2FnZURhdGEud2FpdFRpbWVNaWxsaXMgPSBpdGVtLnRvdGFsVGltZU1pbGxpcyAtIGl0ZW0uaW50ZXJhY3Rpb25UaW1lTWlsbGlzO1xyXG5cdFx0bWVzc2FnZURhdGEuYnl0ZXNSZWNlaXZlZCA9IGl0ZW0uYnl0ZXNSZWNlaXZlZDtcclxuXHRcdHJldHVybiBtZXNzYWdlO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBwb2xsRG93bmxvYWRzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hY3RpdmVEb3dubG9hZElEcy5mb3JFYWNoKGlkID0+IGNocm9tZS5kb3dubG9hZHMuc2VhcmNoKHsgaWQ6IGlkIH0sIChpdGVtOiBjaHJvbWUuZG93bmxvYWRzLkRvd25sb2FkSXRlbVtdKSA9PiB7XHJcblx0XHRcdC8vIE1ha2UgY2hhbmdlcyBvbmx5IGlmIGRvd25sb2FkIGlzIGluIHByb2dyZXNzIChieXRlc1JlY2VpdmVkIGZvciBmYWlsZWQgLyBjYW5jZWxsZWQgZG93bmxvYWRzIGFyZSAwKVxyXG5cdFx0XHRpZiAoaXRlbVswXS5ieXRlc1JlY2VpdmVkID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGRvd25sb2FkaW5nSXRlbSA9IHRoaXMuZG93bmxvYWRzW2lkXTtcclxuXHRcdFx0XHRkb3dubG9hZGluZ0l0ZW0uYnl0ZXNSZWNlaXZlZCA9IGl0ZW1bMF0uYnl0ZXNSZWNlaXZlZDtcclxuXHJcblx0XHRcdFx0Ly8gIElmIGl0ZW0gd2FzIGNvbXBsZXRlbHkgZG93bmxvYWRlZCAtIGhhbmRsZSBjb21wbGV0aW9uXHJcblx0XHRcdFx0aWYgKGl0ZW1bMF0uYnl0ZXNSZWNlaXZlZCA9PT0gZG93bmxvYWRpbmdJdGVtLnRvdGFsQnl0ZXMpIHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vdyA9IHRpbWVQcm92aWRlci5ub3coKTtcclxuXHRcdFx0XHRcdGRvd25sb2FkaW5nSXRlbS50cmFuc2ZlclRpbWVNaWxsaXMgKz0gbm93IC0gZG93bmxvYWRpbmdJdGVtLmxhc3RSZXN1bWVUaW1lO1xyXG5cdFx0XHRcdFx0ZG93bmxvYWRpbmdJdGVtLmxhc3RSZXN1bWVUaW1lID0gbm93O1xyXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVJdGVtRnJvbVBvbGxpbmcoaXRlbVswXS5pZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGhhbmRsZUNvbXBsZXRpb24oaXRlbTogRG93bmxvYWRJdGVtKTogdm9pZCB7XHJcblx0XHRnZXRMb2dnZXIoKS5pbmZvKFwiRG93bmxvYWQgY29tcGxldGUgbWVzc2FnZVwiLCBpdGVtKTtcclxuXHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2FuIGhhcHBlbiB3aGVuIHRoZSBmaWxlIGlzIHRvbyBzbWFsbCBhbmQgaXRlbS5ieXRlc1JlY2VpdmVkIHdlcmUgbm90IHVwZGF0ZWQgeWV0XHJcblx0XHRpZiAoaXRlbS5ieXRlc1JlY2VpdmVkID09PSAwKSB7XHJcblx0XHRcdGl0ZW0uYnl0ZXNSZWNlaXZlZCA9IGl0ZW0udG90YWxCeXRlcztcclxuXHRcdFx0Y29uc3Qgbm93ID0gdGltZVByb3ZpZGVyLm5vdygpO1xyXG5cdFx0XHRpdGVtLnRyYW5zZmVyVGltZU1pbGxpcyArPSBub3cgLSBpdGVtLmxhc3RSZXN1bWVUaW1lO1xyXG5cdFx0XHRpdGVtLnRvdGFsVGltZU1pbGxpcyA9IG5vdyAtIG5ldyBEYXRlKGl0ZW0uc3RhcnRUaW1lKS5nZXRUaW1lKCk7IC8vIHVwZGF0ZSB0b3RhbCB0aW1lIC0gdG8gYmUgbW9yZSBhY2N1cmF0ZVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5yZW1vdmVJdGVtRnJvbVBvbGxpbmcoaXRlbS5pZCk7XHJcblx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5jcmVhdGVEYXRhTWVzc2FnZShcIkNvbXBsZXRlZFwiLCBpdGVtKTtcclxuXHRcdHRoaXMuY29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVtb3ZlSXRlbUZyb21Eb3dubG9hZHMoaWQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgaXRlbURvd25sb2FkZWQgPSB0aGlzLmRvd25sb2Fkc1tpZF07XHJcblx0XHRpZiAoaXRlbURvd25sb2FkZWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5kb3dubG9hZHNbaWRdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGFydFBvbGxpbmcoKTogdm9pZCB7XHJcblx0XHR0aGlzLnBvbGxpbmdUaW1lciA9IHNldEludGVydmFsKHRoaXMucG9sbERvd25sb2Fkcy5iaW5kKHRoaXMpLCAxMDApO1xyXG5cdFx0Z2V0TG9nZ2VyKCkuaW5mbyhcIlN0YXJ0ZWQgZG93bmxvYWRzIHBvbGxpbmcsIGludGVydmFsIElEOiBcIiwgdGhpcy5wb2xsaW5nVGltZXIpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSByZW1vdmVJdGVtRnJvbVBvbGxpbmcoZG93bmxvYWRJZDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuYWN0aXZlRG93bmxvYWRJRHMuaW5kZXhPZihkb3dubG9hZElkKTtcclxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0dGhpcy5hY3RpdmVEb3dubG9hZElEcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmFjdGl2ZURvd25sb2FkSURzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLnN0b3BQb2xsaW5nKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0b3BQb2xsaW5nKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMucG9sbGluZ1RpbWVyICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnBvbGxpbmdUaW1lcik7XHJcblx0XHRcdGdldExvZ2dlcigpLmluZm8oXCJTdG9wcGVkIGRvd25sb2FkcyBwb2xsaW5nLCBpbnRlcnZhbCBJRDogXCIsIHRoaXMucG9sbGluZ1RpbWVyKTtcclxuXHRcdFx0dGhpcy5wb2xsaW5nVGltZXIgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uRG93bmxvYWRDcmVhdGVkID0gKGl0ZW06IGNocm9tZS5kb3dubG9hZHMuRG93bmxvYWRJdGVtKSA9PiB7XHJcblx0XHRpZiAodGhpcy5tYW5hZ2VyID09IG51bGwgfHwgIXRoaXMubWFuYWdlci5hY3RpdmUgfHwgdGhpcy5jb21tdW5pY2F0aW9uID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpdGVtLnN0YXRlICE9PSBcImluX3Byb2dyZXNzXCIpIHtcclxuXHRcdFx0Ly8gV2hlbiBvcGVuaW5nIHRoZSAnZG93bmxvYWRzJyBwYWdlIGZvciB0aGUgZmlyc3QgdGltZSBpbiBhIHNlc3Npb24sXHJcblx0XHRcdC8vIGFscmVhZHktZG93bmxvYWRlZCBpdGVtcyBmaXJlIG9uQ3JlYXRlZCB3aXRoIHN0YXRlICdjb21wbGV0ZScsIG9yICdpbnRlcnJ1cHRlZCcgZXRjLlxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIHRoZSBpdGVtJ3MgaWQgdG8gdGhlIGFjdGl2ZURvd25sb2FkSURzIGFycmF5LCBvbmx5IGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuYWN0aXZlRG93bmxvYWRJRHMuaW5kZXhPZihpdGVtLmlkKTtcclxuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0dGhpcy5hY3RpdmVEb3dubG9hZElEcy5wdXNoKGl0ZW0uaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0YXJ0IHRoZSBwb2xsaW5nIG9ubHkgb25jZVxyXG5cdFx0aWYgKHRoaXMuYWN0aXZlRG93bmxvYWRJRHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHRoaXMuc3RhcnRQb2xsaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kb3dubG9hZHNbaXRlbS5pZF0gPSBuZXcgRG93bmxvYWRJdGVtKGl0ZW0pO1xyXG5cdFx0dGhpcy5kb3dubG9hZHNbaXRlbS5pZF0ubGFzdFJlc3VtZVRpbWUgPSBuZXcgRGF0ZShpdGVtLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xyXG5cclxuXHRcdC8vIFNhdmUgdGhlIG9yaWdpbmFsIGZpbmFsIG5hbWUsIGJlZm9yZSB0aGUgb3ZlcnJpZGVcclxuXHRcdHRoaXMuZG93bmxvYWRzW2l0ZW0uaWRdLmZpbGVuYW1lID0gaXRlbS51cmwuc3BsaXQoXCIvXCIpLnBvcCgpIGFzIHN0cmluZztcclxuXHR9O1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uRG93bmxvYWRDaGFuZ2VkID0gKGRlbHRhOiBjaHJvbWUuZG93bmxvYWRzLkRvd25sb2FkRGVsdGEpID0+IHtcclxuXHRcdGlmICh0aGlzLm1hbmFnZXIgPT0gbnVsbCB8fCAhdGhpcy5tYW5hZ2VyLmFjdGl2ZSB8fCB0aGlzLmNvbW11bmljYXRpb24gPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVmVyaWZ5IHRoZSBjaGFuZ2UgaXMgcmVsZXZhbnRcclxuXHRcdGlmIChkZWx0YS5maWxlU2l6ZSA9PT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdGRlbHRhLnRvdGFsQnl0ZXMgPT09IHVuZGVmaW5lZCAmJlxyXG5cdFx0XHRkZWx0YS5maWxlbmFtZSA9PT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdGRlbHRhLnBhdXNlZCA9PT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdGRlbHRhLmVuZFRpbWUgPT09IHVuZGVmaW5lZCAmJlxyXG5cdFx0XHRkZWx0YS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpdGVtID0gdGhpcy5kb3dubG9hZHNbZGVsdGEuaWRdO1xyXG5cdFx0aWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkRvd25sb2FkQ2hhbmdlZCB3aXRob3V0IG1hdGNoaW5nIERvd25sb2FkQ3JlYXRlZDogXCIsIGRlbHRhKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkZWx0YS5maWxlU2l6ZSAhPT0gdW5kZWZpbmVkICYmIGRlbHRhLmZpbGVTaXplLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpdGVtLmZpbGVTaXplID0gZGVsdGEuZmlsZVNpemUuY3VycmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZGVsdGEudG90YWxCeXRlcyAhPT0gdW5kZWZpbmVkICYmIGRlbHRhLnRvdGFsQnl0ZXMuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGl0ZW0udG90YWxCeXRlcyA9IGRlbHRhLnRvdGFsQnl0ZXMuY3VycmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZGVsdGEuZmlsZW5hbWUgIT09IHVuZGVmaW5lZCAmJiBkZWx0YS5maWxlbmFtZS5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gRmlsZW5hbWUgaXMgc2V0IC0gaW50ZXJhY3Rpb24gaGFzIGVuZGVkXHJcblx0XHRcdGlmIChpdGVtLmZpbGVuYW1lID09PSBcIlwiKSB7IC8vIEluIGNhc2UgZmlsZW5hbWUgd2FzIG1pc3NpbmdcclxuXHRcdFx0XHRpdGVtLmZpbGVuYW1lID0gZGVsdGEuZmlsZW5hbWUuY3VycmVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBUcmFjayBoZXJlIHdoZW4gaXQncyB0aW1lIHRvIHJldGhpbmsgdGhpcyBjb2RlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05ODIyMzIjYzBcclxuXHRcdFx0aXRlbS5pbnRlcmFjdGlvblRpbWVNaWxsaXMgPSB0aW1lUHJvdmlkZXIubm93KCkgLSBuZXcgRGF0ZShpdGVtLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhhbmRsZSBwYXVzZS9yZXN1bWVcclxuXHRcdGlmIChkZWx0YS5wYXVzZWQgIT09IHVuZGVmaW5lZCAmJiBkZWx0YS5wYXVzZWQuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmIChkZWx0YS5wYXVzZWQuY3VycmVudCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHQvLyBKdXN0IHJlc3VtZWRcclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5kZWJ1ZyhcIkRvd25sb2FkIHJlc3VtZWQ6IFwiLCBpdGVtKTtcclxuXHRcdFx0XHRpdGVtLmxhc3RSZXN1bWVUaW1lID0gdGltZVByb3ZpZGVyLm5vdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLmRlYnVnKFwiRG93bmxvYWQgcGF1c2VkOiBcIiwgaXRlbSk7XHJcblx0XHRcdFx0aXRlbS50cmFuc2ZlclRpbWVNaWxsaXMgKz0gdGltZVByb3ZpZGVyLm5vdygpIC0gaXRlbS5sYXN0UmVzdW1lVGltZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhhbmRsZSBjb21wbGV0aW9uXHJcblx0XHRpZiAoZGVsdGEuZW5kVGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGl0ZW0udG90YWxUaW1lTWlsbGlzID0gdGltZVByb3ZpZGVyLm5vdygpIC0gbmV3IERhdGUoaXRlbS5zdGFydFRpbWUpLmdldFRpbWUoKTtcclxuXHRcdFx0dGhpcy5oYW5kbGVDb21wbGV0aW9uKGl0ZW0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhhbmRsZSBjYW5jZWxsYXRpb24vZmFpbHVyZVxyXG5cdFx0aWYgKGRlbHRhLmVycm9yICE9PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0KGRlbHRhLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgZGVsdGEuc3RhdGUuY3VycmVudCA9PT0gXCJpbnRlcnJ1cHRlZFwiKSkge1xyXG5cclxuXHRcdFx0dGhpcy5yZW1vdmVJdGVtRnJvbVBvbGxpbmcoaXRlbS5pZCk7XHJcblxyXG5cdFx0XHRpdGVtLnRvdGFsVGltZU1pbGxpcyA9IHRpbWVQcm92aWRlci5ub3coKSAtIG5ldyBEYXRlKGl0ZW0uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XHJcblx0XHRcdGl0ZW0udHJhbnNmZXJUaW1lTWlsbGlzICs9IHRpbWVQcm92aWRlci5ub3coKSAtIGl0ZW0ubGFzdFJlc3VtZVRpbWU7XHJcblxyXG5cdFx0XHRpZiAoaXRlbS5pbnRlcmFjdGlvblRpbWVNaWxsaXMgPT09IDApIHtcclxuXHRcdFx0XHQvLyBVc2VyIGp1c3QgY2FuY2VsbGVkIGF0IHRoZSBmaWxlIGRpYWxvZ1xyXG5cdFx0XHRcdGl0ZW0uaW50ZXJhY3Rpb25UaW1lTWlsbGlzID0gaXRlbS50b3RhbFRpbWVNaWxsaXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkZWx0YS5lcnJvciAhPT0gdW5kZWZpbmVkICYmIGRlbHRhLmVycm9yLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGl0ZW0uZXJyb3IgPSBEb3dubG9hZEl0ZW0uZ2V0RG93bmxvYWRJbnRlcnJ1cHRSZWFzb24oZGVsdGEuZXJyb3IuY3VycmVudCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdldExvZ2dlcigpLmluZm8oXCJEb3dubG9hZCBmYWlsZWQgbWVzc2FnZVwiLCBpdGVtKTtcclxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlRGF0YU1lc3NhZ2UoXCJGYWlsZWRcIiwgaXRlbSk7XHJcblx0XHRcdHRoaXMuY29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShtZXNzYWdlKTtcclxuXHJcblx0XHRcdHRoaXMucmVtb3ZlSXRlbUZyb21Eb3dubG9hZHMoZGVsdGEuaWQpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogT3JkZXIgb2YgdGhlIG5hdGl2ZSBtZXNzYWdlLlxyXG4gKi9cclxubGV0IG5hdGl2ZU1lc3NhZ2VPcmRlciA9IDA7XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROYXRpdmVNZXNzYWdlT3JkZXIoKTogbnVtYmVyIHtcclxuXHQvLyBMaW1pdCBvcmRlciBieSBtYXggdWludDMyXHJcblx0aWYgKG5hdGl2ZU1lc3NhZ2VPcmRlciA+IDIgKiAxMDI0ICogMTAyNCAqIDEwMjQpIHtcclxuXHRcdG5hdGl2ZU1lc3NhZ2VPcmRlciA9IDA7XHJcblx0fVxyXG5cdHJldHVybiBuYXRpdmVNZXNzYWdlT3JkZXIrKztcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qIHRzbGludDpkaXNhYmxlIG5vLWFueSAqL1xyXG5leHBvcnQgZW51bSBJbmNvbWluZ0FjdGlvbiB7XHJcblx0Q29uZmlndXJhdGlvbiA9IFwiY29uZmlndXJhdGlvblwiLFxyXG5cdERlYWN0aXZhdGUgPSBcImRlYWN0aXZhdGVcIixcclxuXHRXYWNNZXNzYWdlID0gXCJ3YWNcIixcclxufVxyXG4vKiB0c2xpbnQ6ZGlzYWJsZSBuby1hbnkgKi9cclxuXHJcbmV4cG9ydCBjb25zdCBJTkNPTUlOR19WRVJTSU9OID0gMTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW5jb21pbmdOYXRpdmVNZXNzYWdlIHtcclxuXHR2ZXJzaW9uOiBudW1iZXI7XHJcblx0dHlwZTogSW5jb21pbmdBY3Rpb247XHJcblx0ZGF0YToge307XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmF0aXZlQ29uZmlndXJhdGlvbk1lc3NhZ2UgZXh0ZW5kcyBJbmNvbWluZ05hdGl2ZU1lc3NhZ2Uge1xyXG5cdGRhdGE6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgV2FjTmF0aXZlTWVzc2FnZSA9IEluY29taW5nTmF0aXZlTWVzc2FnZTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCIuLi91dGlscy9sb2dcIjtcclxuaW1wb3J0IHsgTWVzc2FnZVR5cGUsIE91dGdvaW5nRXZlbnRNZXNzYWdlLCBPdXRnb2luZ1BhZ2VOYXRpdmVNZXNzYWdlIH0gZnJvbSBcIi4uL2NvbW1vbi9NZXNzYWdpbmdNb2RlbFwiO1xyXG5pbXBvcnQgKiBhcyBDb25zdHMgZnJvbSBcIi4uL2NvbW1vbi9jb25zdHNcIjtcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XHJcbmltcG9ydCB7IGdldE5hdGl2ZU1lc3NhZ2VPcmRlciB9IGZyb20gXCIuL01lc3NhZ2VPcmRlclwiO1xyXG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbW1vbi9jb25maWd1cmF0aW9uL0NvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHsgRnJhbWVTdGF0ZSwgVGFic1N0YXRlcyB9IGZyb20gXCIuL1RhYnNTdGF0ZVwiO1xyXG5pbXBvcnQgeyBXZWJSZXF1ZXN0c1N0YXRlcywgV2ViUmVxdWVzdFN0YXRlIH0gZnJvbSBcIi4vV2ViUmVxdWVzdHNTdGF0ZVwiO1xyXG5pbXBvcnQgeyBXZWJSZXF1ZXN0RXZlbnQgfSBmcm9tIFwiLi9XZWJSZXF1ZXN0RXZlbnRcIjtcclxuaW1wb3J0IHsgSUJhY2tncm91bmRNYW5hZ2VyIH0gZnJvbSBcIi4vSUJhY2tncm91bmRNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IElBZ2VudENvbW11bmljYXRpb24gfSBmcm9tIFwiLi9JQWdlbnRDb21tdW5pY2F0aW9uXCI7XHJcbmltcG9ydCB7IElUYWJzTW9uaXRvcmluZyB9IGZyb20gXCIuL0lUYWJzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyBJV2ViUmVxdWVzdCB9IGZyb20gXCIuL0lXZWJSZXF1ZXN0XCI7XHJcbmltcG9ydCB7IFVYRGF0YSB9IGZyb20gXCIuLi9jb21tb24vVVhEYXRhXCI7XHJcbmltcG9ydCB7IENvbnRlbnRTY3JpcHRQYXJhbWV0ZXJzLCBXcG1QYXJhbWV0ZXJzLCBXcG1TdGF0dXNDb2RlUmVzcG9uc2UgYXMgQ29udGVudFBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vY29tbW9uL0NvbmZpZ3VyYXRpb25EYXRhXCI7XHJcbmltcG9ydCB3ZWJSZXF1ZXN0ID0gY2hyb21lLndlYlJlcXVlc3Q7XHJcbmltcG9ydCBIdHRwSGVhZGVyID0gd2ViUmVxdWVzdC5IdHRwSGVhZGVyO1xyXG5pbXBvcnQgQmxvY2tpbmdSZXNwb25zZSA9IHdlYlJlcXVlc3QuQmxvY2tpbmdSZXNwb25zZTtcclxuaW1wb3J0IFJlcXVlc3RGaWx0ZXIgPSB3ZWJSZXF1ZXN0LlJlcXVlc3RGaWx0ZXI7XHJcbmltcG9ydCB7IHNlbmRNZXNzYWdlVG9UYWJXaXRoTG9nIH0gZnJvbSBcIi4vdGFic1wiO1xyXG5pbXBvcnQgeyBDb250ZW50TWVzc2FnZVR5cGUgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NhZ2luZ01vZGVsXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElXZWJSZXF1ZXN0RXZlbnREYXRhIGV4dGVuZHMgVVhEYXRhIHtcclxuXHQvLyAjcmVnaW9uIEdlbmVyaWMgZXZlbnQgcHJvcGVydGllc1xyXG5cclxuXHRyZXF1ZXN0SWQ6IHN0cmluZztcclxuXHR1cmw6IHN0cmluZztcclxuXHJcblx0bWV0aG9kOiBzdHJpbmc7XHJcblx0dHlwZTogc3RyaW5nO1xyXG5cdGZyYW1lSWQ6IG51bWJlcjtcclxuXHRwYXJlbnRGcmFtZUlkOiBudW1iZXI7XHJcblx0dGFiSWQ6IG51bWJlcjtcclxuXHJcblx0ZnJhbWVVcmw6IHN0cmluZztcclxuXHRmcmFtZUN1cnJlbnRVcmw6IHN0cmluZztcclxuXHRmcmFtZUNvbW1pdHRlZFVybDogc3RyaW5nO1xyXG5cdGRvY3VtZW50VXJsOiBzdHJpbmc7XHJcblx0ZG9jdW1lbnRDdXJyZW50VXJsOiBzdHJpbmc7XHJcblx0ZG9jdW1lbnRDb21taXR0ZWRVcmw6IHN0cmluZztcclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG5cclxuXHQvLyAjcmVnaW9uIEV2ZW50IHNwZWNpZmljIHByb3BlcnRpZXNcclxuXHJcblx0cmVxdWVzdEJvZHlUeXBlPzogc3RyaW5nO1xyXG5cdHJlcXVlc3RCb2R5RXJyb3I/OiBzdHJpbmc7XHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0cmVxdWVzdEJvZHlSYXc/OiBzdHJpbmdbXTtcclxuXHRzdGF0dXNDb2RlPzogbnVtYmVyO1xyXG5cdHN0YXR1c0xpbmU/OiBzdHJpbmc7XHJcblx0aXNQcm94eT86IGJvb2xlYW47XHJcblx0cmVhbG0/OiBzdHJpbmc7XHJcblx0c2NoZW1lPzogc3RyaW5nO1xyXG5cdGNoYWxsZW5nZXJIb3N0Pzogc3RyaW5nO1xyXG5cdGNoYWxsZW5nZXJQb3J0PzogbnVtYmVyO1xyXG5cdGlwPzogc3RyaW5nO1xyXG5cdHJlZGlyZWN0VXJsPzogc3RyaW5nO1xyXG5cdGVycm9yPzogc3RyaW5nO1xyXG5cdGZyb21DYWNoZT86IGJvb2xlYW47XHJcblxyXG5cdC8vICNlbmRyZWdpb25cclxufVxyXG5cclxuaW50ZXJmYWNlIElXZWJSZXF1ZXN0TmV0d29ya0V2ZW50RGF0YSBleHRlbmRzIElXZWJSZXF1ZXN0RXZlbnREYXRhIHtcclxuXHRhdGVybml0eU91dGdvaW5nQnl0ZXM/OiBudW1iZXI7XHJcblx0YXRlcm5pdHlJbmNvbWluZ0J5dGVzPzogbnVtYmVyO1xyXG5cdGF0ZXJuaXR5TmV0d29ya1N0YXJ0VGltZT86IG51bWJlcjtcclxuXHRhdGVybml0eU5ldHdvcmtFbmRUaW1lPzogbnVtYmVyO1xyXG5cdGF0ZXJuaXR5VG90YWxTZXJ2ZXJUaW1lPzogbnVtYmVyO1xyXG5cdGF0ZXJuaXR5RXZlbnRUaW1lcz86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEZyYW1lIG1vbml0b3JlZCBzdGF0ZSBmb3IgZ2l2ZW4gZnJhbWUgc3RhdGUuXHJcbiAqL1xyXG5pbnRlcmZhY2UgRnJhbWVNb25pdG9yZWRTdGF0ZSB7XHJcblx0cmVhZG9ubHkgbW9uaXRvcldlYlJlcXVlc3Q6IGJvb2xlYW47XHJcblx0cmVhZG9ubHkgbW9uaXRvcldQTTogYm9vbGVhbjtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNNb25pdG9yZWRTdGF0ZShmcmFtZU1vbml0b3JlZFN0YXRlOiBSZWFkb25seTxGcmFtZU1vbml0b3JlZFN0YXRlPik6IGJvb2xlYW4ge1xyXG5cdHJldHVybiBmcmFtZU1vbml0b3JlZFN0YXRlLm1vbml0b3JXZWJSZXF1ZXN0IHx8IGZyYW1lTW9uaXRvcmVkU3RhdGUubW9uaXRvcldQTTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBXRUJfUkVRVUVTVF9FVkVOVF9OQU1FU1BBQ0UgPSBcImh0dHA6Y2hyb21lOldlYlJlcXVlc3RcIjtcclxuXHJcbmZ1bmN0aW9uIG1ha2VFdmVudE5hbWUoZXZlbnQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0cmV0dXJuIFdFQl9SRVFVRVNUX0VWRU5UX05BTUVTUEFDRSArIFwiLlwiICsgZXZlbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBXZWJSZXF1ZXN0IGltcGxlbWVudHMgSVdlYlJlcXVlc3Qge1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IHRhYnNTdGF0ZXM6IFRhYnNTdGF0ZXM7XHJcblx0cHJpdmF0ZSByZWFkb25seSB3ZWJSZXF1ZXN0c1N0YXRlcyA9IG5ldyBXZWJSZXF1ZXN0c1N0YXRlcygpO1xyXG5cclxuXHRwcml2YXRlIG1hbmFnZXI/OiBJQmFja2dyb3VuZE1hbmFnZXI7XHJcblx0cHJpdmF0ZSBjb21tdW5pY2F0aW9uPzogSUFnZW50Q29tbXVuaWNhdGlvbjtcclxuXHRwcml2YXRlIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uO1xyXG5cdHByaXZhdGUgdGFic01vbml0b3Jpbmc/OiBJVGFic01vbml0b3Jpbmc7XHJcblxyXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvcih0YWJzU3RhdGVzOiBUYWJzU3RhdGVzKSB7XHJcblx0XHR0aGlzLnRhYnNTdGF0ZXMgPSB0YWJzU3RhdGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gI3JlZ2lvbiBVdGlsaXR5IGZ1bmN0aW9uc1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYmFzZSB3ZWJSZXF1ZXN0IG1lc3NhZ2UuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBjcmVhdGVEYXRhTWVzc2FnZShcclxuXHRcdGV2ZW50OiBzdHJpbmcsXHJcblx0XHRkZXRhaWxzOiBSZWFkb25seTx3ZWJSZXF1ZXN0LlJlc291cmNlUmVxdWVzdD4sXHJcblx0XHRmcmFtZVN0YXRlOiBSZWFkb25seTxGcmFtZVN0YXRlPik6XHJcblx0XHRPdXRnb2luZ0V2ZW50TWVzc2FnZTxJV2ViUmVxdWVzdEV2ZW50RGF0YT4ge1xyXG5cclxuXHRcdGNvbnN0IG1lc3NhZ2UgPVxyXG5cdFx0XHRuZXcgT3V0Z29pbmdFdmVudE1lc3NhZ2U8SVdlYlJlcXVlc3RFdmVudERhdGE+KG1ha2VFdmVudE5hbWUoZXZlbnQpLCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblxyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhWzBdO1xyXG5cdFx0ZXZlbnREYXRhLnJlcXVlc3RJZCA9IGRldGFpbHMucmVxdWVzdElkO1xyXG5cdFx0ZXZlbnREYXRhLnVybCA9IGRldGFpbHMudXJsO1xyXG5cclxuXHRcdGlmICh0eXBlb2YgKGRldGFpbHMgYXMgd2ViUmVxdWVzdC5XZWJSZXF1ZXN0RGV0YWlscykubWV0aG9kICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdGV2ZW50RGF0YS5tZXRob2QgPSAoZGV0YWlscyBhcyB3ZWJSZXF1ZXN0LldlYlJlcXVlc3REZXRhaWxzKS5tZXRob2Q7XHJcblx0XHR9XHJcblxyXG5cdFx0ZXZlbnREYXRhLnR5cGUgPSBkZXRhaWxzLnR5cGU7XHJcblx0XHRldmVudERhdGEuZnJhbWVJZCA9IGRldGFpbHMuZnJhbWVJZDtcclxuXHRcdGV2ZW50RGF0YS5wYXJlbnRGcmFtZUlkID0gZGV0YWlscy5wYXJlbnRGcmFtZUlkO1xyXG5cdFx0ZXZlbnREYXRhLnRhYklkID0gZGV0YWlscy50YWJJZDtcclxuXHJcblx0XHQvLyBBZGQgdXJsc1xyXG5cdFx0ZXZlbnREYXRhLmZyYW1lVXJsID0gZnJhbWVTdGF0ZS5zdGFydFVybDtcclxuXHRcdGV2ZW50RGF0YS5mcmFtZUN1cnJlbnRVcmwgPSBmcmFtZVN0YXRlLmN1cnJlbnRVcmw7XHJcblx0XHRpZiAoZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgIT0gbnVsbCkge1xyXG5cdFx0XHRldmVudERhdGEuZnJhbWVDb21taXR0ZWRVcmwgPSBmcmFtZVN0YXRlLmNvbW1pdHRlZFVybDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZGV0YWlscy5mcmFtZUlkID09PSAwKSB7XHJcblx0XHRcdGV2ZW50RGF0YS5kb2N1bWVudFVybCA9IGZyYW1lU3RhdGUuc3RhcnRVcmw7XHJcblx0XHRcdGV2ZW50RGF0YS5kb2N1bWVudEN1cnJlbnRVcmwgPSBmcmFtZVN0YXRlLmN1cnJlbnRVcmw7XHJcblx0XHRcdGlmIChmcmFtZVN0YXRlLmNvbW1pdHRlZFVybCAhPSBudWxsKSB7XHJcblx0XHRcdFx0ZXZlbnREYXRhLmRvY3VtZW50Q29tbWl0dGVkVXJsID0gZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmw7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IG1haW5GcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldFRhYihkZXRhaWxzLnRhYklkKTtcclxuXHRcdFx0aWYgKG1haW5GcmFtZVN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0XHRldmVudERhdGEuZG9jdW1lbnRVcmwgPSBtYWluRnJhbWVTdGF0ZS5zdGFydFVybDtcclxuXHRcdFx0XHRldmVudERhdGEuZG9jdW1lbnRDdXJyZW50VXJsID0gbWFpbkZyYW1lU3RhdGUuY3VycmVudFVybDtcclxuXHRcdFx0XHRpZiAobWFpbkZyYW1lU3RhdGUuY29tbWl0dGVkVXJsICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGV2ZW50RGF0YS5kb2N1bWVudENvbW1pdHRlZFVybCA9IG1haW5GcmFtZVN0YXRlLmNvbW1pdHRlZFVybDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWVzc2FnZTtcclxuXHR9XHJcblxyXG5cdC8qXHJcblx0ICogRnJhbWUgaXMgZWl0aGVyIG1haW5fZnJhbWUgb3Igc3ViX2ZyYW1lIHR5cGUuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBpc0ZyYW1lVHlwZSh0eXBlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0eXBlID09PSBcIm1haW5fZnJhbWVcIiB8fCB0eXBlID09PSBcInN1Yl9mcmFtZVwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHJldHVybiB0cnVlIGlmIHRoZSB0YWIgaXMgbW9uaXRvcmVkIG9yIGZhbHNlIG90aGVyd2lzZS5cclxuXHQgKi9cclxuXHRwcml2YXRlIGlzTW9uaXRvcmVkKGRldGFpbHM6IFJlYWRvbmx5PHdlYlJlcXVlc3QuUmVzb3VyY2VSZXF1ZXN0PiwgdmFsaWRhdGVUYWJTdGF0ZTogYm9vbGVhbiA9IHRydWUpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLm1hbmFnZXIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1hbmFnZXIuYWN0aXZlICYmXHJcblx0XHRcdC8vIHRhYklkIHNldCB0byAtMSBpZiB0aGUgcmVxdWVzdCBpc24ndCByZWxhdGVkIHRvIGEgdGFiLlxyXG5cdFx0XHRkZXRhaWxzLnRhYklkICE9PSAtMSAmJlxyXG5cdFx0XHQoIXZhbGlkYXRlVGFiU3RhdGUgfHwgdGhpcy50YWJzU3RhdGVzLmdldFRhYihkZXRhaWxzLnRhYklkKSAhPSBudWxsKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGZpbHRlcnMgYWNjb3JkaW5nIHRvIGNvbmZpZ3VyYXRpb25cclxuXHQgKiBJZiB0aGUgbWFpbiBmcmFtZSBkb2Vzbid0IGV4aXN0LCB0aGUgZ2l2ZW4gZnJhbWUgaXMgbm90IG1vbml0b3JlZCBzaW5jZSB3ZSBkb24ndCBrbm93XHJcblx0ICogdGhlIFVSTCBvZiB0aGUgcGFnZS5cclxuXHQgKi9cclxuXHRwcml2YXRlIGdldE1vbml0b3JlZFN0YXRlKFxyXG5cdFx0ZnJhbWVTdGF0ZTogUmVhZG9ubHk8RnJhbWVTdGF0ZT4sXHJcblx0XHRkZXRhaWxzOiBSZWFkb25seTx3ZWJSZXF1ZXN0LlJlc291cmNlUmVxdWVzdD4pOiBGcmFtZU1vbml0b3JlZFN0YXRlIHtcclxuXHJcblx0XHRjb25zdCBtYWluRnJhbWVTdGF0ZSA9IGRldGFpbHMuZnJhbWVJZCA9PT0gMCA/XHJcblx0XHRcdGZyYW1lU3RhdGUgOlxyXG5cdFx0XHR0aGlzLnRhYnNTdGF0ZXMuZ2V0VGFiKGRldGFpbHMudGFiSWQpO1xyXG5cclxuXHRcdC8vIE5vIG1haW4gZnJhbWUgc3RhdGUsIG5vdCBtb25pdG9yaW5nLlxyXG5cdFx0aWYgKG1haW5GcmFtZVN0YXRlID09IG51bGwgfHwgdGhpcy5jb25maWd1cmF0aW9uID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHsgbW9uaXRvcldlYlJlcXVlc3Q6IGZhbHNlLCBtb25pdG9yV1BNOiBmYWxzZSB9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb247XHJcblx0XHRjb25zdCBkb2N1bWVudE5hdmlnYXRpb25VcmwgPSBtYWluRnJhbWVTdGF0ZS5zdGFydFVybDtcclxuXHRcdGNvbnN0IG1vbml0b3JXZWJSZXF1ZXN0ID0gdGhpcy5pc1dlYlJlcXVlc3RNb25pdG9yZWQoY29uZmlndXJhdGlvbiwgbWFpbkZyYW1lU3RhdGUsIGRldGFpbHMpO1xyXG5cclxuXHRcdGNvbnN0IG1vbml0b3JXUE0gPVxyXG5cdFx0XHR0aGlzLmNvbmZpZ3VyYXRpb24uaXNNYXRjaEZvcldwbVVybHMoZG9jdW1lbnROYXZpZ2F0aW9uVXJsLCBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwpIHx8XHJcblx0XHRcdHRoaXMuY29uZmlndXJhdGlvbi5pc01hdGNoRm9ySHR0cFdlYlBhZ2VMb2FkVXJsKGRvY3VtZW50TmF2aWdhdGlvblVybCk7XHJcblxyXG5cdFx0cmV0dXJuIHsgbW9uaXRvcldlYlJlcXVlc3QsIG1vbml0b3JXUE0gfTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIHdoZXRoZXIgd2ViUmVxdWVzdCBzaG91bGQgYmUgcmVwb3J0ZWQgZm9yIHRoaXMgdGFiLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgaXNXZWJSZXF1ZXN0TW9uaXRvcmVkKFxyXG5cdFx0Y29uZmlndXJhdGlvbjogUmVhZG9ubHk8Q29uZmlndXJhdGlvbj4sXHJcblx0XHRtYWluRnJhbWVTdGF0ZTogUmVhZG9ubHk8RnJhbWVTdGF0ZT4sXHJcblx0XHRkZXRhaWxzOiBSZWFkb25seTx3ZWJSZXF1ZXN0LlJlc291cmNlUmVxdWVzdD4pOiBib29sZWFuIHtcclxuXHJcblx0XHRjb25zdCBkb2N1bWVudE5hdmlnYXRpb25VcmwgPSBtYWluRnJhbWVTdGF0ZS5zdGFydFVybDtcclxuXHJcblx0XHQvLyBDaGVjayBkb2N1bWVudFVybCBhbmQgdHlwZVxyXG5cdFx0aWYgKGNvbmZpZ3VyYXRpb24uaXNNYXRjaFdlYlJlcXVlc3RFdmVudChcImRvY3VtZW50VXJsXCIsIGRvY3VtZW50TmF2aWdhdGlvblVybCkgJiZcclxuXHRcdFx0Y29uZmlndXJhdGlvbi5pc01hdGNoV2ViUmVxdWVzdEV2ZW50KFwidHlwZVwiLCBkZXRhaWxzLnR5cGUpKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHRoZXJlIGFyZSBubyBkb2N1bWVudENvbW1pdHRlZFVybCBmaWx0ZXJzLCBkb24ndCByZXBvcnQgd2ViUmVxdWVzdC5cclxuXHRcdGlmICghY29uZmlndXJhdGlvbi5oYXNXZWJSZXF1ZXN0RmlsdGVyKFwiZG9jdW1lbnRDb21taXR0ZWRVcmxcIikpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1haW4gZnJhbWUgaXMgYWx3YXlzIHJlcG9ydGVkIHdoZW4gZG9jdW1lbnRDb21taXR0ZWRVcmwgZmlsdGVyIGlzIHByZXNlbnQuXHJcblx0XHRpZiAoZGV0YWlscy50eXBlID09PSBcIm1haW5fZnJhbWVcIikge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb2N1bWVudENvbW1pdHRlZCB1cmwgc2hvdWxkIGJlIHNldCBpbiBvblJlc3BvbnNlU3RhcnRlZCBjYWxsYmFjayBvZiBtYWluIGZyYW1lLlxyXG5cdFx0Ly8gSWYgaXQgaXMgbm90IHNldCwgc29tZXRoaW5nIGJhZCBoYXBwZW5lZCwgZG9uJ3QgcmVwb3J0LlxyXG5cdFx0Y29uc3QgZG9jdW1lbnRDb21taXR0ZWRVcmwgPSBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmw7XHJcblx0XHRpZiAoZG9jdW1lbnRDb21taXR0ZWRVcmwgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgZG9jdW1lbnRDb21taXR0ZWRVcmwgYW5kIHR5cGVcclxuXHRcdHJldHVybiBjb25maWd1cmF0aW9uLmlzTWF0Y2hXZWJSZXF1ZXN0RXZlbnQoXCJkb2N1bWVudENvbW1pdHRlZFVybFwiLCBkb2N1bWVudENvbW1pdHRlZFVybCkgJiZcclxuXHRcdFx0Y29uZmlndXJhdGlvbi5pc01hdGNoV2ViUmVxdWVzdEV2ZW50KFwidHlwZVwiLCBkZXRhaWxzLnR5cGUpO1xyXG5cdH1cclxuXHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0cHJpdmF0ZSBzdGF0aWMgbWFrZUtleSguLi5zOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gcy5qb2luKENvbnN0cy5LRVlfREVMSU1JVEVSKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGdldENvbnRlbnRMZW5ndGgoZGV0YWlsczogd2ViUmVxdWVzdC5XZWJSZXF1ZXN0SGVhZGVyc0RldGFpbHMsIGhlYWRlcnM6IFJlYWRvbmx5QXJyYXk8SHR0cEhlYWRlcj4pOiBudW1iZXIge1xyXG5cclxuXHRcdGxldCBjb250ZW50TGVuZ3RoID0gMDtcclxuXHRcdGxldCBoZWFkZXJzTGVuZ3RoID0gMDtcclxuXHJcblx0XHRmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XHJcblx0XHRcdGlmIChoZWFkZXIubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtbGVuZ3RoXCIpIHtcclxuXHRcdFx0XHRpZiAodHlwZW9mIGhlYWRlci52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0Y29udGVudExlbmd0aCA9IHBhcnNlSW50KGhlYWRlci52YWx1ZSwgMTApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRoZWFkZXJzTGVuZ3RoICs9IGhlYWRlci5uYW1lLmxlbmd0aDtcclxuXHRcdFx0XHRpZiAodHlwZW9mIGhlYWRlci52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0aGVhZGVyc0xlbmd0aCArPSBoZWFkZXIudmFsdWUubGVuZ3RoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNvbWV0aW1lcyBubyBDb250ZW50LUxlbmd0aCBpcyByZWNlaXZlZCwgd2UgY2FsY3VsYXRlIGFuIGFwcHJveGltYXRpb24gb3Vyc2VsdmVzXHJcblxyXG5cdFx0aWYgKGNvbnRlbnRMZW5ndGggPT09IDAgJiYgdHlwZW9mIGRldGFpbHMudXJsICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdGNvbnRlbnRMZW5ndGggKz0gZGV0YWlscy51cmwubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb250ZW50TGVuZ3RoICsgaGVhZGVyc0xlbmd0aDtcclxuXHR9XHJcblxyXG5cdC8vICNlbmRyZWdpb25cclxuXHJcblx0Ly8gI3JlZ2lvbiBQb3B1bGF0ZSB1dGlsaXR5IHByaXZhdGVcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBub3JtYWxpemVkIGhlYWRlciBwcm9wcmV0eSBrZXkuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgbWFrZUhlYWRlclByb3BlcnR5KHByZWZpeDogc3RyaW5nLCBoZWFkZXI6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gV2ViUmVxdWVzdC5tYWtlS2V5KHByZWZpeCwgaGVhZGVyLnRvTG93ZXJDYXNlKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSGVhZGVyIGluZGljYXRpbmcgQXBwSW50ZXJuYWxzIG1vbml0b3JpbmcuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQVBQSU5URVJOQUxTX1RSQUNFX0hFQURFUiA9IFwiWC1PUE5FVC1UcmFuc2FjdGlvbi1UcmFjZVwiO1xyXG5cclxuXHQvKipcclxuXHQgKiBIZWFkZXIgaW5kaWNhdGluZyBBcHBJbnRlcm5hbHMgbW9uaXRvcmluZyBpbiBVWCBwcm9wZXJ0eSBmb3JtYXQuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgV0VCUkVRVUVTVF9BUFBJTlRFUk5BTFNfUkVTUE9OU0VfSEVBREVSID1cclxuXHRcdFdlYlJlcXVlc3QubWFrZUhlYWRlclByb3BlcnR5KFwicmVzcG9uc2VIZWFkZXJzXCIsIFdlYlJlcXVlc3QuQVBQSU5URVJOQUxTX1RSQUNFX0hFQURFUik7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBoZWFkZXJzIHRvIHRoZSBvYmplY3QuXHJcblx0ICogVGhlIGhlYWRlcnMgYXJlIGFkZGVkIHdpdGggdGhlIGdpdmVuIHByZWZpeC5cclxuXHQgKlxyXG5cdCAqIEhlYWRlciBuYW1lIGlzIGNhc2UgaW5zZW5zaXRpdmUsIHRoZXJlZm9yZSBpdCBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIHBvcHVsYXRlSGVhZGVycyhcclxuXHRcdGhlYWRlcnM6IFJlYWRvbmx5QXJyYXk8SHR0cEhlYWRlcj4gfCB1bmRlZmluZWQsXHJcblx0XHRwcmVmaXg6IHN0cmluZyxcclxuXHRcdGV2ZW50RGF0YTogSVdlYlJlcXVlc3RFdmVudERhdGEpOiB2b2lkIHtcclxuXHJcblx0XHRpZiAoaGVhZGVycyA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XHJcblx0XHRcdGNvbnN0IGtleSA9IFdlYlJlcXVlc3QubWFrZUtleShwcmVmaXgsIGhlYWRlci5uYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuXHRcdFx0aWYgKGhlYWRlci52YWx1ZSAhPSBudWxsKSB7XHJcblx0XHRcdFx0ZXZlbnREYXRhW2tleV0gPSBoZWFkZXIudmFsdWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXZlbnREYXRhW2tleV0gPSBcInxCaW5hcnlWYWx1ZXxcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIG5ldHdvcmsgdmFsdWVzLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIHBvcHVsYXRlTmV0d29yayhcclxuXHRcdHJlcXVlc3RTdGF0ZTogV2ViUmVxdWVzdFN0YXRlIHwgdW5kZWZpbmVkLFxyXG5cdFx0dGltZVN0YW1wOiBudW1iZXIsXHJcblx0XHRldmVudERhdGE6IElXZWJSZXF1ZXN0TmV0d29ya0V2ZW50RGF0YSk6IHZvaWQge1xyXG5cclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0ZXZlbnREYXRhLmF0ZXJuaXR5SW5jb21pbmdCeXRlcyA9IHJlcXVlc3RTdGF0ZS50b3RhbEluY29taW5nQnl0ZXM7XHJcblx0XHRldmVudERhdGEuYXRlcm5pdHlPdXRnb2luZ0J5dGVzID0gcmVxdWVzdFN0YXRlLnRvdGFsT3V0Z29pbmdCeXRlcztcclxuXHRcdGV2ZW50RGF0YS5hdGVybml0eU5ldHdvcmtTdGFydFRpbWUgPSBNYXRoLmZsb29yKHJlcXVlc3RTdGF0ZS5yZXF1ZXN0U3RhcnRUaW1lKTtcclxuXHRcdGV2ZW50RGF0YS5hdGVybml0eU5ldHdvcmtFbmRUaW1lID0gTWF0aC5mbG9vcih0aW1lU3RhbXApO1xyXG5cdFx0ZXZlbnREYXRhLmF0ZXJuaXR5VG90YWxTZXJ2ZXJUaW1lID0gTWF0aC5mbG9vcihyZXF1ZXN0U3RhdGUudG90YWxTZXJ2ZXJUaW1lKTtcclxuXHRcdGV2ZW50RGF0YS5hdGVybml0eUV2ZW50VGltZXMgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0U3RhdGUuZXZlbnRUaW1lcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXZSBkb24ndCB3YW50IHRvIHNlbmQgb3V0IHBhc3N3b3JkcyAoaWYgd2UgY2FuIGhlbHAgaXQpXHJcblx0ICogTW9zdCB3ZWJzaXRlcyB1c2UgdGhlIHNhbWUgbmFtZXMgZm9yIHBhc3N3b3JkIGZpZWxkcywgc28gd2UgdHJ5IGFuZCBmaW5kIHRob3NlIHZhbHVlc1xyXG5cdCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHBhc3N3b3JkUmVnRXggPSBuZXcgUmVnRXhwKFxyXG5cdFx0XCIoLipwd2QkKXwocGFzcyl8KC4qcHckKXwoaGVzbG8pfChjb250cmFzZcOxYSl8KGNvbnRyYXNlbmEpfChhZGdhbmdza29kZSl8XCIgK1xyXG5cdFx0XCIo0L/QsNGA0L7Qu9GMKXwoc2VuaGEpfChvcmRpbmUpfChwYXN3b29yZCl8KOWvhueggSl8KOWvhueivCl8KOCkquCkvuCkuOCkteCksOCljeCkoSl8KNeh15nXoSlcIiwgXCJpXCIpO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBpc0ZpZWxkQmxhY2tsaXN0ZWQoZmllbGROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBXZWJSZXF1ZXN0LnBhc3N3b3JkUmVnRXgudGVzdChmaWVsZE5hbWUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGZvcm1EYXRhIGFzIGFycmF5IG9mIHN0cmluZ3NcclxuXHQgKiBAcmV0dXJuIH50b3RhbCBudW1iZXIgb2YgY2hhcnMgKE5PVCBFWEFDVCEpXHJcblx0ICovXHJcblx0cHJpdmF0ZSBwb3B1bGF0ZUZvcm1EYXRhKFxyXG5cdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0XHRmb3JtRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9LFxyXG5cdFx0ZXZlbnREYXRhOiBVWERhdGEpOiBudW1iZXIge1xyXG5cdFx0bGV0IHJldCA9IDA7XHJcblx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gZm9ybURhdGEpIHtcclxuXHRcdFx0aWYgKCFmb3JtRGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XHJcblx0XHRcdHJldCArPSBuYW1lLmxlbmd0aCArIGZvcm1EYXRhW25hbWVdLnRvU3RyaW5nKCkubGVuZ3RoO1xyXG5cdFx0XHRpZiAoV2ViUmVxdWVzdC5pc0ZpZWxkQmxhY2tsaXN0ZWQobmFtZSkpIHtcclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5kZWJ1ZyhcIkp1c3QgZmlsdGVyZWQgXCIgKyBuYW1lICsgXCIuXCIpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnN0IGtleSA9IFdlYlJlcXVlc3QubWFrZUtleShcImZvcm1EYXRhXCIsIG5hbWUpO1xyXG5cclxuXHRcdFx0Ly8gV29ya2Fyb3VuZCBGaXJlZm94IHBhcnNpbmcgaW5jb3JyZWN0IGZvcm1EYXRhIHdoaWNoIGlzIG5vdCBpbiBrZXk9dmFsdWUgZm9ybWF0LlxyXG5cdFx0XHQvLyBXaGVuIHRoZSByZXF1ZXN0IGJvZHkgaXMgbm90IGluIHRoZSBjb3JyZWN0IGZvcm1hdCwgaXQgY3JlYXRlcyBhIGtleSB3aXRoIHZhbHVlIG9mIHVuZGVmaW5lZC5cclxuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSB2YWx1ZSBpbnN0ZWFkLlxyXG5cdFx0XHRpZiAoIShmb3JtRGF0YVtuYW1lXS5sZW5ndGggPT09IDEgJiYgZm9ybURhdGFbbmFtZV1bMF0gPT09IHVuZGVmaW5lZCkpIHtcclxuXHRcdFx0XHRVdGlscy5jb25jYXRPckluaXQoZXZlbnREYXRhIGFzIHR5cGVvZiBmb3JtRGF0YSwga2V5LCBmb3JtRGF0YVtuYW1lXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXZlbnREYXRhW2tleV0gPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBuZXcgZnJhbWUgdG8gdGFicyBzdGF0ZXMgYW5kIGEgbmV3IHJlcXVlc3RJZCB0byB3ZWJSZXF1ZXN0cyBzdGF0ZXMuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBhZGRGcmFtZShkZXRhaWxzOiBSZWFkb25seTx3ZWJSZXF1ZXN0LldlYlJlcXVlc3RCb2R5RGV0YWlscz4pOiBGcmFtZVN0YXRlIHtcclxuXHRcdHJldHVybiB0aGlzLnRhYnNTdGF0ZXMuYWRkRnJhbWUoXHJcblx0XHRcdGRldGFpbHMudGFiSWQsXHJcblx0XHRcdGRldGFpbHMuZnJhbWVJZCxcclxuXHRcdFx0ZGV0YWlscy51cmwsXHJcblx0XHRcdGRldGFpbHMudHlwZSxcclxuXHRcdFx0ZGV0YWlscy5yZXF1ZXN0SWQpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBwb3N0U3RhcnRNZXNzYWdlKFxyXG5cdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHJlYWRvbmx5LWFycmF5XHJcblx0XHRyZXF1ZXN0SGVhZGVyczogSHR0cEhlYWRlcltdIHwgdW5kZWZpbmVkLFxyXG5cdFx0b3JpZ2luYWxNZXNzYWdlOiBPdXRnb2luZ0V2ZW50TWVzc2FnZTxJV2ViUmVxdWVzdEV2ZW50RGF0YT4sXHJcblx0XHRvcmRlcjogbnVtYmVyKTogdm9pZCB7XHJcblxyXG5cdFx0Ly8gTWFrZSBhIG5ldyBtZXNzYWdlIHdpdGggY29tYmluZWQgZGF0YSBhbmQgdGltZSBzdGFtcCBmcm9tIEJlZm9yZVJlcXVlc3RcclxuXHRcdGNvbnN0IHN0YXJ0TWVzc2FnZSA9IG5ldyBPdXRnb2luZ0V2ZW50TWVzc2FnZTxJV2ViUmVxdWVzdEV2ZW50RGF0YT4oXHJcblx0XHRcdG1ha2VFdmVudE5hbWUoXCJTdGFydFwiKSxcclxuXHRcdFx0b3JpZ2luYWxNZXNzYWdlLnRpbWVTdGFtcCk7XHJcblx0XHRzdGFydE1lc3NhZ2Uub3JkZXIgPSBvcmRlcjtcclxuXHRcdHN0YXJ0TWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhID0gb3JpZ2luYWxNZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGE7XHJcblxyXG5cdFx0Ly8gQWRkIHJlcXVlc3RIZWFkZXJzXHJcblx0XHRjb25zdCBldmVudERhdGEgPSBzdGFydE1lc3NhZ2UubWVzc2FnZURhdGEuRGF0YVswXTtcclxuXHRcdGlmIChyZXF1ZXN0SGVhZGVycyAhPSBudWxsKSB7XHJcblx0XHRcdFdlYlJlcXVlc3QucG9wdWxhdGVIZWFkZXJzKHJlcXVlc3RIZWFkZXJzLCBcInJlcXVlc3RIZWFkZXJzXCIsIGV2ZW50RGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuY29tbXVuaWNhdGlvbiAhPSBudWxsKSB7XHJcblx0XHRcdHRoaXMuY29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShzdGFydE1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdC8vICNlbmRyZWdpb25cclxuXHJcblx0Ly8gI3JlZ2lvbiBIYW5kbGVyc1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uQmVmb3JlUmVxdWVzdCA9IChkZXRhaWxzOiB3ZWJSZXF1ZXN0LldlYlJlcXVlc3RCb2R5RGV0YWlscyk6IEJsb2NraW5nUmVzcG9uc2UgfCB1bmRlZmluZWQgPT4ge1xyXG5cdFx0aWYgKCF0aGlzLmlzTW9uaXRvcmVkKGRldGFpbHMsIGZhbHNlKSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJXZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdFwiLCBkZXRhaWxzKTtcclxuXHJcblx0XHQvLyBHZXQgZnJhbWUgc3RhdGVcclxuXHRcdGxldCBmcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKGRldGFpbHMpO1xyXG5cclxuXHRcdC8vIEluIGNhc2Ugd2UgaGF2ZSB0aGUgc2FtZSB0YWIgaWQgYW5kIGZyYW1lIGlkIGFuZCB0aGUgcmVxdWVzdElkIGlzIGRpZmZlcmVudCxcclxuXHRcdC8vIGFuZCB0aGUgdHlwZSBpcyBcIm1haW5fZnJhbWVcIiBvciBcInN1Yl9mcmFtZVwiLCB3ZSBoYXZlIGEgbmV3IG5hdmlnYXRpb24uXHJcblx0XHRpZiAoZnJhbWVTdGF0ZSAhPSBudWxsICYmIGZyYW1lU3RhdGUucmVxdWVzdElkICE9PSBkZXRhaWxzLnJlcXVlc3RJZCkge1xyXG5cdFx0XHQvLyBGcmFtZSBzdGF0ZSBleGlzdHMsIG9ubHkgZnJhbWUgdHlwZSBtZWFucyBuYXZpZ2F0aW9uLlxyXG5cdFx0XHRpZiAodGhpcy5pc0ZyYW1lVHlwZShkZXRhaWxzLnR5cGUpKSB7XHJcblx0XHRcdFx0Ly8gUmVtb3ZlIHN0YXRlc1xyXG5cdFx0XHRcdHRoaXMudGFic1N0YXRlcy5yZW1vdmVGcmFtZShkZXRhaWxzLnRhYklkLCBkZXRhaWxzLmZyYW1lSWQpO1xyXG5cdFx0XHRcdHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMucmVtb3ZlKGZyYW1lU3RhdGUucmVxdWVzdElkKTtcclxuXHJcblx0XHRcdFx0ZnJhbWVTdGF0ZSA9IHRoaXMuYWRkRnJhbWUoZGV0YWlscyk7XHJcblxyXG5cdFx0XHRcdC8vIFJlbW92ZSBpbnN0YW50IHRhYnNcclxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHRoaXMudGFic1N0YXRlcy52YWxpZGF0ZVRhYihkZXRhaWxzLnRhYklkKSwgNjAgKiAxMDAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBXZWIgcmVxdWVzdCBpcyBpbml0aWFsaXplZCBvbmx5IGZvciBzdGFydCBuYXZpZ2F0aW9uIGV2ZW50LlxyXG5cdFx0bGV0IHJlcXVlc3RTdGF0ZSA9IHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMuZ2V0KGRldGFpbHMucmVxdWVzdElkKTtcclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXF1ZXN0U3RhdGUgPSB0aGlzLndlYlJlcXVlc3RzU3RhdGVzLmFkZChkZXRhaWxzLnJlcXVlc3RJZCwgZGV0YWlscy50aW1lU3RhbXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoaXMgY2hlY2sgbmV2ZXIgcG9zaXRpdmUgc2luY2UgdGhlcmUgaXMgYXNzaWdubWVudCBiZWZvcmUuXHJcblx0XHRpZiAoZnJhbWVTdGF0ZSA9PSBudWxsIHx8IHJlcXVlc3RTdGF0ZSA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGZyYW1lJ3MgY3VycmVudCB1cmwgaWYgaXQgaXMgZnJhbWUgcmVxdWVzdC5cclxuXHRcdGlmICh0aGlzLmlzRnJhbWVUeXBlKGRldGFpbHMudHlwZSkpIHtcclxuXHRcdFx0ZnJhbWVTdGF0ZS5jdXJyZW50VXJsID0gZGV0YWlscy51cmw7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBVcGRhdGUgb25seSBpZiB3YXNuJ3QgZGVmaW5lZCBiZWZvcmVcclxuXHRcdFx0aWYgKHR5cGVvZiBmcmFtZVN0YXRlLmN1cnJlbnRVcmwgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHRmcmFtZVN0YXRlLmN1cnJlbnRVcmwgPSBkZXRhaWxzLnVybDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpbHRlciBldmVudFxyXG5cdFx0Y29uc3QgbW9uaXRvcmVkU3RhdGUgPSB0aGlzLmdldE1vbml0b3JlZFN0YXRlKGZyYW1lU3RhdGUsIGRldGFpbHMpO1xyXG5cdFx0aWYgKCFpc01vbml0b3JlZFN0YXRlKG1vbml0b3JlZFN0YXRlKSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1hcmsgZG93biB0aGUgdGltZVxyXG5cdFx0cmVxdWVzdFN0YXRlLnN0b3JlRXZlbnRUaW1lKFdlYlJlcXVlc3RFdmVudC5CZWZvcmVSZXF1ZXN0LCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG1lc3NhZ2VcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiQmVmb3JlUmVxdWVzdFwiLCBkZXRhaWxzLCBmcmFtZVN0YXRlKTtcclxuXHRcdGNvbnN0IGV2ZW50RGF0YSA9IG1lc3NhZ2UubWVzc2FnZURhdGEuRGF0YVswXTtcclxuXHJcblx0XHQvLyBQYXJzZSB1cmwgcGFyYW1ldGVycyBpbnRvIGZvcm1EYXRhXHJcblx0XHRjb25zdCB1cmxQYXJhbXMgPSBVdGlscy5nZXRVcmxQYXJhbXMoZGV0YWlscy51cmwpO1xyXG5cdFx0dGhpcy5wb3B1bGF0ZUZvcm1EYXRhKHVybFBhcmFtcywgZXZlbnREYXRhKTtcclxuXHJcblx0XHQvLyBBZGQgcmVxdWVzdEJvZHlcclxuXHRcdGlmIChkZXRhaWxzLnJlcXVlc3RCb2R5ICE9IG51bGwpIHtcclxuXHRcdFx0aWYgKGRldGFpbHMucmVxdWVzdEJvZHkuZXJyb3IgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGV2ZW50RGF0YS5yZXF1ZXN0Qm9keVR5cGUgPSBcIkVycm9yXCI7XHJcblx0XHRcdFx0ZXZlbnREYXRhLnJlcXVlc3RCb2R5RXJyb3IgPSBkZXRhaWxzLnJlcXVlc3RCb2R5LmVycm9yO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGRldGFpbHMucmVxdWVzdEJvZHkuZm9ybURhdGEgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGV2ZW50RGF0YS5yZXF1ZXN0Qm9keVR5cGUgPSBcIkZvcm1EYXRhXCI7XHJcblx0XHRcdFx0cmVxdWVzdFN0YXRlLnRvdGFsT3V0Z29pbmdCeXRlcyArPSB0aGlzLnBvcHVsYXRlRm9ybURhdGEoZGV0YWlscy5yZXF1ZXN0Qm9keS5mb3JtRGF0YSwgZXZlbnREYXRhKTtcclxuXHRcdFx0fSBlbHNlIGlmIChkZXRhaWxzLnJlcXVlc3RCb2R5LnJhdyAhPSBudWxsKSB7XHJcblx0XHRcdFx0ZXZlbnREYXRhLnJlcXVlc3RCb2R5VHlwZSA9IFwiUmF3XCI7XHJcblx0XHRcdFx0ZXZlbnREYXRhLnJlcXVlc3RCb2R5UmF3ID0gW107XHJcblx0XHRcdFx0Zm9yIChjb25zdCB1cGxvYWREYXRhIG9mIGRldGFpbHMucmVxdWVzdEJvZHkucmF3KSB7XHJcblx0XHRcdFx0XHRpZiAodXBsb2FkRGF0YS5ieXRlcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJlcXVlc3RTdGF0ZS50b3RhbE91dGdvaW5nQnl0ZXMgKz0gdXBsb2FkRGF0YS5ieXRlcy5ieXRlTGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRldmVudERhdGEucmVxdWVzdEJvZHlSYXcucHVzaChcIkJ5dGVzXCIpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0aWYgKHVwbG9hZERhdGEuZmlsZSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVxdWVzdFN0YXRlLnRvdGFsT3V0Z29pbmdCeXRlcyArPSB1cGxvYWREYXRhLmZpbGUubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRcdGV2ZW50RGF0YS5yZXF1ZXN0Qm9keVJhdy5wdXNoKHVwbG9hZERhdGEuZmlsZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgYmVmb3JlUmVxdWVzdEV2ZW50IG9ubHkgaW4gdGhlIGZpcnN0IHJlcXVlc3QuXHJcblx0XHRpZiAoIXJlcXVlc3RTdGF0ZS5zZXRCZWZvcmVSZXF1ZXN0RXZlbnQpIHtcclxuXHRcdFx0cmVxdWVzdFN0YXRlLmJlZm9yZVJlcXVlc3RFdmVudCA9IFV0aWxzLmRlZXBDbG9uZShtZXNzYWdlKTtcclxuXHRcdFx0cmVxdWVzdFN0YXRlLnN0YXJ0TWVzYWdlT3JkZXIgPSBnZXROYXRpdmVNZXNzYWdlT3JkZXIoKTtcclxuXHRcdFx0cmVxdWVzdFN0YXRlLnNldEJlZm9yZVJlcXVlc3RFdmVudCA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuY29tbXVuaWNhdGlvbiAhPSBudWxsICYmIG1vbml0b3JlZFN0YXRlLm1vbml0b3JXZWJSZXF1ZXN0KSB7XHJcblx0XHRcdC8vIEFsd2F5cyBwb3N0IGlmIEFwcEludGVybmFscyBoZWFkZXIgcHJlc2VudFxyXG5cdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25CZWZvcmVTZW5kSGVhZGVycyA9IChkZXRhaWxzOiB3ZWJSZXF1ZXN0LldlYlJlcXVlc3RIZWFkZXJzRGV0YWlscyk6IEJsb2NraW5nUmVzcG9uc2UgfCB1bmRlZmluZWQgPT4ge1xyXG5cdFx0aWYgKCF0aGlzLmlzTW9uaXRvcmVkKGRldGFpbHMpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRnZXRMb2dnZXIoKS5kZWJ1ZyhcIldlYlJlcXVlc3Qub25CZWZvcmVTZW5kSGVhZGVyc1wiLCBkZXRhaWxzKTtcclxuXHJcblx0XHRjb25zdCBmcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKGRldGFpbHMpO1xyXG5cdFx0Ly8gU2tpcCB1bm1vbml0b3JlZCBmcmFtZXNcclxuXHRcdGlmIChmcmFtZVN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYXJrIGRvd24gdGhlIHRpbWVcclxuXHRcdGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMuZ2V0KGRldGFpbHMucmVxdWVzdElkKTtcclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXF1ZXN0U3RhdGUuc3RvcmVFdmVudFRpbWUoV2ViUmVxdWVzdEV2ZW50LkJlZm9yZVNlbmRIZWFkZXJzLCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmlsdGVyIGV2ZW50XHJcblx0XHRjb25zdCBtb25pdG9yZWRTdGF0ZSA9IHRoaXMuZ2V0TW9uaXRvcmVkU3RhdGUoZnJhbWVTdGF0ZSwgZGV0YWlscyk7XHJcblx0XHRpZiAoIWlzTW9uaXRvcmVkU3RhdGUobW9uaXRvcmVkU3RhdGUpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG1lc3NhZ2VcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiQmVmb3JlU2VuZEhlYWRlcnNcIiwgZGV0YWlscywgZnJhbWVTdGF0ZSk7XHJcblx0XHRjb25zdCBldmVudERhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0aWYgKGRldGFpbHMucmVxdWVzdEhlYWRlcnMgIT0gbnVsbCkge1xyXG5cdFx0XHRXZWJSZXF1ZXN0LnBvcHVsYXRlSGVhZGVycyhkZXRhaWxzLnJlcXVlc3RIZWFkZXJzLCBcInJlcXVlc3RIZWFkZXJzXCIsIGV2ZW50RGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuY29tbXVuaWNhdGlvbiAhPSBudWxsICYmIG1vbml0b3JlZFN0YXRlLm1vbml0b3JXZWJSZXF1ZXN0KSB7XHJcblx0XHRcdHRoaXMuY29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShtZXNzYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSByZWFkb25seSBvblNlbmRIZWFkZXJzID0gKGRldGFpbHM6IHdlYlJlcXVlc3QuV2ViUmVxdWVzdEhlYWRlcnNEZXRhaWxzKTogQmxvY2tpbmdSZXNwb25zZSB8IHVuZGVmaW5lZCA9PiB7XHJcblx0XHRpZiAoIXRoaXMuaXNNb25pdG9yZWQoZGV0YWlscykpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmRlYnVnKFwiV2ViUmVxdWVzdC5vblNlbmRIZWFkZXJzXCIsIGRldGFpbHMpO1xyXG5cclxuXHRcdGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLnRhYnNTdGF0ZXMuZ2V0RnJhbWUoZGV0YWlscyk7XHJcblx0XHQvLyBTa2lwIHVubW9uaXRvcmVkIGZyYW1lc1xyXG5cdFx0aWYgKGZyYW1lU3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMuZ2V0KGRldGFpbHMucmVxdWVzdElkKTtcclxuXHJcblx0XHQvLyBNYXJrIGRvd24gdGhlIHRpbWVcclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXF1ZXN0U3RhdGUuc3RvcmVFdmVudFRpbWUoV2ViUmVxdWVzdEV2ZW50LlNlbmRIZWFkZXJzLCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmlsdGVyIGV2ZW50XHJcblx0XHRjb25zdCBtb25pdG9yZWRTdGF0ZSA9IHRoaXMuZ2V0TW9uaXRvcmVkU3RhdGUoZnJhbWVTdGF0ZSwgZGV0YWlscyk7XHJcblx0XHRpZiAoIWlzTW9uaXRvcmVkU3RhdGUobW9uaXRvcmVkU3RhdGUpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG1lc3NhZ2VcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiU2VuZEhlYWRlcnNcIiwgZGV0YWlscywgZnJhbWVTdGF0ZSk7XHJcblx0XHRjb25zdCBldmVudERhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0aWYgKGRldGFpbHMucmVxdWVzdEhlYWRlcnMgIT0gbnVsbCkge1xyXG5cdFx0XHRXZWJSZXF1ZXN0LnBvcHVsYXRlSGVhZGVycyhkZXRhaWxzLnJlcXVlc3RIZWFkZXJzLCBcInJlcXVlc3RIZWFkZXJzXCIsIGV2ZW50RGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2VuZCB0aGUgbWVzc2FnZVxyXG5cdFx0aWYgKHRoaXMuY29tbXVuaWNhdGlvbiAhPSBudWxsICYmIG1vbml0b3JlZFN0YXRlLm1vbml0b3JXZWJSZXF1ZXN0KSB7XHJcblx0XHRcdHRoaXMuY29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShtZXNzYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayB3ZSBoYXZlIHJlcXVlc3RTdGF0ZVxyXG5cdFx0aWYgKHJlcXVlc3RTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdC8vIFNlbmQgV2ViUmVxdWVzdC5TdGFydCBldmVudFxyXG5cdFx0XHRpZiAoIXJlcXVlc3RTdGF0ZS5wb3N0ZWRTdGFydCkge1xyXG5cdFx0XHRcdC8vIFZhbGlkYXRlIHJlcXVlc3Qgc3RhdGVcclxuXHRcdFx0XHRpZiAocmVxdWVzdFN0YXRlLmJlZm9yZVJlcXVlc3RFdmVudCA9PSBudWxsIHx8XHJcblx0XHRcdFx0XHRyZXF1ZXN0U3RhdGUuc3RhcnRNZXNhZ2VPcmRlciA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIlJlcXVlc3Qgc3RhdGUgZGlkbid0IGluaXRpYWxpemUgYmVmb3JlUmVxdWVzdEV2ZW50IG9yIHN0YXJ0TWVzc2FnZU9yZGVyXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmIChtb25pdG9yZWRTdGF0ZS5tb25pdG9yV2ViUmVxdWVzdCkge1xyXG5cdFx0XHRcdFx0dGhpcy5wb3N0U3RhcnRNZXNzYWdlKFxyXG5cdFx0XHRcdFx0XHRkZXRhaWxzLnJlcXVlc3RIZWFkZXJzLFxyXG5cdFx0XHRcdFx0XHRyZXF1ZXN0U3RhdGUuYmVmb3JlUmVxdWVzdEV2ZW50LFxyXG5cdFx0XHRcdFx0XHRyZXF1ZXN0U3RhdGUuc3RhcnRNZXNhZ2VPcmRlcik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXF1ZXN0U3RhdGUucG9zdGVkU3RhcnQgPSB0cnVlO1xyXG5cdFx0XHRcdGRlbGV0ZSByZXF1ZXN0U3RhdGUuYmVmb3JlUmVxdWVzdEV2ZW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBZGQgb3V0Z29pbmcgYnl0ZXMgaWYgd2UgaGF2ZSB0aGVtXHJcblx0XHRcdGlmIChkZXRhaWxzLnJlcXVlc3RIZWFkZXJzICE9IG51bGwpIHtcclxuXHRcdFx0XHRyZXF1ZXN0U3RhdGUudG90YWxPdXRnb2luZ0J5dGVzICs9IFdlYlJlcXVlc3QuZ2V0Q29udGVudExlbmd0aChkZXRhaWxzLCBkZXRhaWxzLnJlcXVlc3RIZWFkZXJzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRpbWUgc28gd2UgY2FuIHN1YnRyYWN0IGl0IG9uY2UgdGhlIHNlcnZlciBnZXRzIGJhY2sgdG8gdXMuXHJcblx0XHRcdHJlcXVlc3RTdGF0ZS5sYXN0T25TZW5kSGVhZGVyc1RzID0gZGV0YWlscy50aW1lU3RhbXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25IZWFkZXJzUmVjZWl2ZWQgPSAoZGV0YWlsczogd2ViUmVxdWVzdC5XZWJSZXNwb25zZUhlYWRlcnNEZXRhaWxzKTogQmxvY2tpbmdSZXNwb25zZSB8IHVuZGVmaW5lZCA9PiB7XHJcblx0XHRpZiAoIXRoaXMuaXNNb25pdG9yZWQoZGV0YWlscykpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmRlYnVnKFwiV2ViUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZFwiLCBkZXRhaWxzKTtcclxuXHJcblx0XHRjb25zdCBmcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKGRldGFpbHMpO1xyXG5cdFx0Ly8gU2tpcCB1bm1vbml0b3JlZCBmcmFtZXNcclxuXHRcdGlmIChmcmFtZVN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByZXF1ZXN0U3RhdGUgPSB0aGlzLndlYlJlcXVlc3RzU3RhdGVzLmdldChkZXRhaWxzLnJlcXVlc3RJZCk7XHJcblx0XHQvLyBNYXJrIGRvd24gdGhlIHRpbWVcclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXF1ZXN0U3RhdGUuc3RvcmVFdmVudFRpbWUoV2ViUmVxdWVzdEV2ZW50LkhlYWRlcnNSZWNlaXZlZCwgZGV0YWlscy50aW1lU3RhbXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpbHRlciBldmVudFxyXG5cdFx0Y29uc3QgbW9uaXRvcmVkU3RhdGUgPSB0aGlzLmdldE1vbml0b3JlZFN0YXRlKGZyYW1lU3RhdGUsIGRldGFpbHMpO1xyXG5cdFx0aWYgKCFpc01vbml0b3JlZFN0YXRlKG1vbml0b3JlZFN0YXRlKSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiSGVhZGVyc1JlY2VpdmVkXCIsIGRldGFpbHMsIGZyYW1lU3RhdGUpO1xyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhWzBdO1xyXG5cclxuXHRcdGlmIChkZXRhaWxzLnJlc3BvbnNlSGVhZGVycyAhPSBudWxsKSB7XHJcblx0XHRcdFdlYlJlcXVlc3QucG9wdWxhdGVIZWFkZXJzKGRldGFpbHMucmVzcG9uc2VIZWFkZXJzLCBcInJlc3BvbnNlSGVhZGVyc1wiLCBldmVudERhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHN0YXR1c0NvZGUgPSBVdGlscy5nZXRTdGF0dXNDb2RlKGRldGFpbHMpO1xyXG5cdFx0aWYgKHN0YXR1c0NvZGUgIT0gbnVsbCkge1xyXG5cdFx0XHRmcmFtZVN0YXRlLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGZyYW1lU3RhdGUuc3RhdHVzQ29kZSAhPSBudWxsKSB7XHJcblx0XHRcdGV2ZW50RGF0YS5zdGF0dXNDb2RlID0gZnJhbWVTdGF0ZS5zdGF0dXNDb2RlO1xyXG5cdFx0fVxyXG5cdFx0ZXZlbnREYXRhLnN0YXR1c0xpbmUgPSBkZXRhaWxzLnN0YXR1c0xpbmU7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgd2UgaGF2ZSByZXF1ZXN0U3RhdGVcclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRpZiAoZGV0YWlscy5yZXNwb25zZUhlYWRlcnMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdC8vIFVwZGF0ZSBpbmNvbWluZyBieXRlc1xyXG5cdFx0XHRcdHJlcXVlc3RTdGF0ZS50b3RhbEluY29taW5nQnl0ZXMgKz0gV2ViUmVxdWVzdC5nZXRDb250ZW50TGVuZ3RoKGRldGFpbHMsIGRldGFpbHMucmVzcG9uc2VIZWFkZXJzKTtcclxuXHJcblx0XHRcdFx0Ly8gQ2hlY2sgQXBwSW50ZXJuYWxzIGhlYWRlclxyXG5cdFx0XHRcdGlmIChXZWJSZXF1ZXN0LldFQlJFUVVFU1RfQVBQSU5URVJOQUxTX1JFU1BPTlNFX0hFQURFUiBpbiBldmVudERhdGEpIHtcclxuXHRcdFx0XHRcdC8vIHByZWZpeCwgaGVhZGVyLm5hbWUudG9Mb3dlckNhc2UoKVxyXG5cdFx0XHRcdFx0cmVxdWVzdFN0YXRlLmFwcEludGVybmFsc01vbml0b3JpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIChub3cgLSBsYXN0IE9uIHNlbmQgaGVhZGVycykgdG8gZ2V0IHRoaXMgcmVxdWVzdCdzIHNlcnZlciB0aW1lXHJcblx0XHRcdHJlcXVlc3RTdGF0ZS50b3RhbFNlcnZlclRpbWUgKz0gZGV0YWlscy50aW1lU3RhbXAgLSByZXF1ZXN0U3RhdGUubGFzdE9uU2VuZEhlYWRlcnNUcztcclxuXHRcdFx0cmVxdWVzdFN0YXRlLmxhc3RPblNlbmRIZWFkZXJzVHMgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCAmJiBtb25pdG9yZWRTdGF0ZS5tb25pdG9yV2ViUmVxdWVzdCkge1xyXG5cdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25BdXRoUmVxdWlyZWQgPSAoZGV0YWlsczogd2ViUmVxdWVzdC5XZWJBdXRoZW50aWNhdGlvbkNoYWxsZW5nZURldGFpbHMpOiBCbG9ja2luZ1Jlc3BvbnNlIHwgdW5kZWZpbmVkID0+IHtcclxuXHRcdGlmICghdGhpcy5pc01vbml0b3JlZChkZXRhaWxzKSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJXZWJSZXF1ZXN0Lm9uQXV0aFJlcXVpcmVkXCIsIGRldGFpbHMpO1xyXG5cclxuXHRcdGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLnRhYnNTdGF0ZXMuZ2V0RnJhbWUoZGV0YWlscyk7XHJcblx0XHQvLyBTa2lwIHVubW9uaXRvcmVkIGZyYW1lc1xyXG5cdFx0aWYgKGZyYW1lU3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1hcmsgZG93biB0aGUgdGltZVxyXG5cdFx0Y29uc3QgcmVxdWVzdFN0YXRlID0gdGhpcy53ZWJSZXF1ZXN0c1N0YXRlcy5nZXQoZGV0YWlscy5yZXF1ZXN0SWQpO1xyXG5cdFx0aWYgKHJlcXVlc3RTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdHJlcXVlc3RTdGF0ZS5zdG9yZUV2ZW50VGltZShXZWJSZXF1ZXN0RXZlbnQuQXV0aFJlcXVpcmVkLCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmlsdGVyIGV2ZW50XHJcblx0XHRjb25zdCBtb25pdG9yZWRTdGF0ZSA9IHRoaXMuZ2V0TW9uaXRvcmVkU3RhdGUoZnJhbWVTdGF0ZSwgZGV0YWlscyk7XHJcblx0XHRpZiAoIWlzTW9uaXRvcmVkU3RhdGUobW9uaXRvcmVkU3RhdGUpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG1lc3NhZ2VcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiQXV0aFJlcXVpcmVkXCIsIGRldGFpbHMsIGZyYW1lU3RhdGUpO1xyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhWzBdO1xyXG5cclxuXHRcdGlmIChkZXRhaWxzLnJlc3BvbnNlSGVhZGVycyAhPSBudWxsKSB7XHJcblx0XHRcdFdlYlJlcXVlc3QucG9wdWxhdGVIZWFkZXJzKGRldGFpbHMucmVzcG9uc2VIZWFkZXJzLCBcInJlc3BvbnNlSGVhZGVyc1wiLCBldmVudERhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGV2ZW50RGF0YS5zdGF0dXNMaW5lID0gZGV0YWlscy5zdGF0dXNMaW5lO1xyXG5cdFx0ZXZlbnREYXRhLmlzUHJveHkgPSBkZXRhaWxzLmlzUHJveHk7XHJcblx0XHRpZiAoZGV0YWlscy5yZWFsbSAhPSBudWxsKSB7XHJcblx0XHRcdGV2ZW50RGF0YS5yZWFsbSA9IGRldGFpbHMucmVhbG07XHJcblx0XHR9XHJcblx0XHRldmVudERhdGEuc2NoZW1lID0gZGV0YWlscy5zY2hlbWU7XHJcblx0XHRldmVudERhdGEuY2hhbGxlbmdlckhvc3QgPSBkZXRhaWxzLmNoYWxsZW5nZXIuaG9zdDtcclxuXHRcdGV2ZW50RGF0YS5jaGFsbGVuZ2VyUG9ydCA9IGRldGFpbHMuY2hhbGxlbmdlci5wb3J0O1xyXG5cclxuXHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCAmJiBtb25pdG9yZWRTdGF0ZS5tb25pdG9yV2ViUmVxdWVzdCkge1xyXG5cdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25SZXNwb25zZVN0YXJ0ZWQgPSAoZGV0YWlsczogd2ViUmVxdWVzdC5XZWJSZXNwb25zZUNhY2hlRGV0YWlscyk6IEJsb2NraW5nUmVzcG9uc2UgfCB1bmRlZmluZWQgPT4ge1xyXG5cdFx0aWYgKCF0aGlzLmlzTW9uaXRvcmVkKGRldGFpbHMpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRnZXRMb2dnZXIoKS5kZWJ1ZyhcIldlYlJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWRcIiwgZGV0YWlscyk7XHJcblxyXG5cdFx0Y29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMudGFic1N0YXRlcy5nZXRGcmFtZShkZXRhaWxzKTtcclxuXHRcdC8vIFNraXAgdW5tb25pdG9yZWQgZnJhbWVzXHJcblx0XHRpZiAoZnJhbWVTdGF0ZSA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNGcmFtZVR5cGUoZGV0YWlscy50eXBlKSkge1xyXG5cdFx0XHRmcmFtZVN0YXRlLmNvbW1pdHRlZFVybCA9IGRldGFpbHMudXJsO1xyXG5cdFx0XHQvLyBDYWxjdWxhdGUgY29uZmlndXJhdGlvbiBhbmQgcHV0IGl0IGludG8gY2FjaGUgZm9yIGZhc3RlciBwYWdlIGxvYWQuXHJcblx0XHRcdC8vIERhdGEgVVJMcyBhcmUgaWdub3JlZC5cclxuXHRcdFx0aWYgKHRoaXMuY29uZmlndXJhdGlvbiAhPSBudWxsKSB7XHJcblx0XHRcdFx0Y29uc3QgbWFpbkZyYW1lU3RhdGUgPSB0aGlzLnRhYnNTdGF0ZXMuZ2V0VGFiKGRldGFpbHMudGFiSWQpO1xyXG5cclxuXHRcdFx0XHQvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBjaHJvbWUgc2hvcnRjdXRzXHJcblx0XHRcdFx0bGV0IG1haW5Db21taXR0ZWRVcmwgPSBtYWluRnJhbWVTdGF0ZSAhPSBudWxsID8gbWFpbkZyYW1lU3RhdGUuY29tbWl0dGVkVXJsIDogXCJcIjtcclxuXHRcdFx0XHRjb25zdCB0YWJSZWFkeSA9IG1haW5Db21taXR0ZWRVcmwgIT0gbnVsbCAmJiBtYWluQ29tbWl0dGVkVXJsICE9PSBcIlwiO1xyXG5cdFx0XHRcdGlmIChtYWluRnJhbWVTdGF0ZSAhPSBudWxsICYmICF0YWJSZWFkeSkge1xyXG5cdFx0XHRcdFx0Ly8gV2hlbiBydW5uaW5nIGNocm9tZSB3aXRoIHVybCBvbiB0aGUgY29tbWFuZCBsaW5lIG1haW5GcmFtZVN0YXRlIG1pZ2h0IHN0aWxsIGhhdmUgZW1wdHkgZG9jdW1lbnRDb21taXR0ZWRVcmwsXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGVtcHR5IGRvY3VtZW50VXJsLiBXZSBtdXN0IGZhbGwgYmFjayB0byBjdXJyZW50VXJsLCBzdHJpcHBlZCBvZiBwYXRoICh0byBzdXBwb3J0IFNQQXMpXHJcblx0XHRcdFx0XHRnZXRMb2dnZXIoKS53YXJuKFwiVGFiXCIsXHJcblx0XHRcdFx0XHRcdGRldGFpbHMudGFiSWQsXHJcblx0XHRcdFx0XHRcdFwiIGNvbW1pdHRlZFVybCBub3QgcmVhZHksIGZhbGxpbmcgYmFjayB0byBmcmFtZVwiLFxyXG5cdFx0XHRcdFx0XHRkZXRhaWxzLmZyYW1lSWQpO1xyXG5cdFx0XHRcdFx0aWYgKGRldGFpbHMudXJsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgdXJsOiBVUkwgPSBuZXcgVVJMKGRldGFpbHMudXJsKTtcclxuXHRcdFx0XHRcdFx0bWFpbkNvbW1pdHRlZFVybCA9IHVybC5wcm90b2NvbCArIFwiLy9cIiArIHVybC5ob3N0bmFtZTtcclxuXHRcdFx0XHRcdFx0Z2V0TG9nZ2VyKCkud2FybihcIlVzaW5nIHVybDpcIiwgbWFpbkNvbW1pdHRlZFVybCk7XHJcblx0XHRcdFx0XHRcdG1haW5GcmFtZVN0YXRlLmNvbW1pdHRlZFVybCA9IG1haW5Db21taXR0ZWRVcmw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobWFpbkZyYW1lU3RhdGUgIT0gbnVsbCAmJiBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jb25maWd1cmF0aW9uLmdldEV2ZW50c0ZvclBhZ2Uoe1xyXG5cdFx0XHRcdFx0XHRkb2N1bWVudFVybDogbWFpbkZyYW1lU3RhdGUuc3RhcnRVcmwsXHJcblx0XHRcdFx0XHRcdGRvY3VtZW50Q29tbWl0dGVkVXJsOiBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmxcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1hcmsgZG93biB0aGUgdGltZVxyXG5cdFx0Y29uc3QgcmVxdWVzdFN0YXRlID0gdGhpcy53ZWJSZXF1ZXN0c1N0YXRlcy5nZXQoZGV0YWlscy5yZXF1ZXN0SWQpO1xyXG5cdFx0aWYgKHJlcXVlc3RTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdHJlcXVlc3RTdGF0ZS5zdG9yZUV2ZW50VGltZShXZWJSZXF1ZXN0RXZlbnQuUmVzcG9uc2VTdGFydGVkLCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IFV0aWxzLmdldFN0YXR1c0NvZGUoZGV0YWlscyk7XHJcblx0XHRpZiAoc3RhdHVzQ29kZSAhPSBudWxsKSB7XHJcblx0XHRcdGZyYW1lU3RhdGUuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmlsdGVyIGV2ZW50XHJcblx0XHRjb25zdCBtb25pdG9yZWRTdGF0ZSA9IHRoaXMuZ2V0TW9uaXRvcmVkU3RhdGUoZnJhbWVTdGF0ZSwgZGV0YWlscyk7XHJcblx0XHRpZiAoIWlzTW9uaXRvcmVkU3RhdGUobW9uaXRvcmVkU3RhdGUpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG1lc3NhZ2VcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiUmVzcG9uc2VTdGFydGVkXCIsIGRldGFpbHMsIGZyYW1lU3RhdGUpO1xyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhWzBdO1xyXG5cclxuXHJcblx0XHRpZiAoZnJhbWVTdGF0ZS5zdGF0dXNDb2RlICE9IG51bGwpIHtcclxuXHRcdFx0ZXZlbnREYXRhLnN0YXR1c0NvZGUgPSBmcmFtZVN0YXRlLnN0YXR1c0NvZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRldGFpbHMucmVzcG9uc2VIZWFkZXJzICE9IG51bGwpIHtcclxuXHRcdFx0V2ViUmVxdWVzdC5wb3B1bGF0ZUhlYWRlcnMoZGV0YWlscy5yZXNwb25zZUhlYWRlcnMsIFwicmVzcG9uc2VIZWFkZXJzXCIsIGV2ZW50RGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRldGFpbHMuaXAgIT0gbnVsbCkge1xyXG5cdFx0XHRldmVudERhdGEuaXAgPSBkZXRhaWxzLmlwO1xyXG5cdFx0fVxyXG5cdFx0ZXZlbnREYXRhLnN0YXR1c0xpbmUgPSBkZXRhaWxzLnN0YXR1c0xpbmU7XHJcblx0XHRldmVudERhdGEuc3RhdHVzQ29kZSA9IGRldGFpbHMuc3RhdHVzQ29kZTtcclxuXHRcdGV2ZW50RGF0YS5mcm9tQ2FjaGUgPSBkZXRhaWxzLmZyb21DYWNoZTtcclxuXHJcblx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwgJiYgbW9uaXRvcmVkU3RhdGUubW9uaXRvcldlYlJlcXVlc3QpIHtcclxuXHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uQmVmb3JlUmVkaXJlY3QgPSAoZGV0YWlsczogd2ViUmVxdWVzdC5XZWJSZWRpcmVjdGlvblJlc3BvbnNlRGV0YWlscyk6IEJsb2NraW5nUmVzcG9uc2UgfCB1bmRlZmluZWQgPT4ge1xyXG5cdFx0aWYgKCF0aGlzLmlzTW9uaXRvcmVkKGRldGFpbHMpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRnZXRMb2dnZXIoKS5kZWJ1ZyhcIldlYlJlcXVlc3Qub25CZWZvcmVSZWRpcmVjdFwiLCBkZXRhaWxzKTtcclxuXHJcblx0XHRjb25zdCBmcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKGRldGFpbHMpO1xyXG5cdFx0Ly8gU2tpcCB1bm1vbml0b3JlZCBmcmFtZXNcclxuXHRcdGlmIChmcmFtZVN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYXJrIGRvd24gdGhlIHRpbWVcclxuXHRcdGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMuZ2V0KGRldGFpbHMucmVxdWVzdElkKTtcclxuXHRcdGlmIChyZXF1ZXN0U3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRyZXF1ZXN0U3RhdGUuc3RvcmVFdmVudFRpbWUoV2ViUmVxdWVzdEV2ZW50LkJlZm9yZVJlZGlyZWN0LCBkZXRhaWxzLnRpbWVTdGFtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmlsdGVyIGV2ZW50XHJcblx0XHRjb25zdCBtb25pdG9yZWRTdGF0ZSA9IHRoaXMuZ2V0TW9uaXRvcmVkU3RhdGUoZnJhbWVTdGF0ZSwgZGV0YWlscyk7XHJcblx0XHRpZiAoIWlzTW9uaXRvcmVkU3RhdGUobW9uaXRvcmVkU3RhdGUpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG1lc3NhZ2VcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiQmVmb3JlUmVkaXJlY3RcIiwgZGV0YWlscywgZnJhbWVTdGF0ZSk7XHJcblxyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhWzBdO1xyXG5cclxuXHRcdGlmIChkZXRhaWxzLnJlc3BvbnNlSGVhZGVycyAhPSBudWxsKSB7XHJcblx0XHRcdFdlYlJlcXVlc3QucG9wdWxhdGVIZWFkZXJzKGRldGFpbHMucmVzcG9uc2VIZWFkZXJzLCBcInJlc3BvbnNlSGVhZGVyc1wiLCBldmVudERhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkZXRhaWxzLmlwICE9IG51bGwpIHtcclxuXHRcdFx0ZXZlbnREYXRhLmlwID0gZGV0YWlscy5pcDtcclxuXHRcdH1cclxuXHRcdGV2ZW50RGF0YS5zdGF0dXNMaW5lID0gZGV0YWlscy5zdGF0dXNMaW5lO1xyXG5cdFx0ZXZlbnREYXRhLnN0YXR1c0NvZGUgPSBkZXRhaWxzLnN0YXR1c0NvZGU7XHJcblx0XHRldmVudERhdGEuZnJvbUNhY2hlID0gZGV0YWlscy5mcm9tQ2FjaGU7XHJcblx0XHRldmVudERhdGEucmVkaXJlY3RVcmwgPSBkZXRhaWxzLnJlZGlyZWN0VXJsO1xyXG5cclxuXHRcdC8vIERhdGEgVVJJIGlzIGEgc3BlY2lhbCBjYXNlLiBUaGVyZSBpcyBubyBmdXJ0aGVyIHJlcXVlc3RzLlxyXG5cdFx0aWYgKFV0aWxzLmlzRGF0YVVybChkZXRhaWxzLnJlZGlyZWN0VXJsKSkge1xyXG5cdFx0XHQvLyBSZW1vdmUgd2ViIHJlcXVlc3RcclxuXHRcdFx0dGhpcy53ZWJSZXF1ZXN0c1N0YXRlcy5yZW1vdmUoZGV0YWlscy5yZXF1ZXN0SWQpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIGNvbW1pdHRlZCB1cmxcclxuXHRcdFx0ZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgPSBkZXRhaWxzLnVybDtcclxuXHJcblx0XHRcdC8vIEFkZCBtb3JlIG1ldGEgZGF0YSBmb3IgZnVydGhlciBhbmFseXNpcyBieSB0aGUgYWdlbnRcclxuXHRcdFx0V2ViUmVxdWVzdC5wb3B1bGF0ZU5ldHdvcmsocmVxdWVzdFN0YXRlLCBkZXRhaWxzLnRpbWVTdGFtcCwgZXZlbnREYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwgJiYgbW9uaXRvcmVkU3RhdGUubW9uaXRvcldlYlJlcXVlc3QpIHtcclxuXHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uQ29tcGxldGVkID0gKGRldGFpbHM6IHdlYlJlcXVlc3QuV2ViUmVzcG9uc2VDYWNoZURldGFpbHMpOiBCbG9ja2luZ1Jlc3BvbnNlIHwgdW5kZWZpbmVkID0+IHtcclxuXHRcdGlmICghdGhpcy5pc01vbml0b3JlZChkZXRhaWxzKSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJXZWJSZXF1ZXN0Lm9uQ29tcGxldGVkXCIsIGRldGFpbHMpO1xyXG5cclxuXHRcdC8vIEZpbmQgdGhlIHJlcXVlc3RcclxuXHRcdGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMuZ2V0KGRldGFpbHMucmVxdWVzdElkKTtcclxuXHJcblx0XHQvLyBSZW1vdmUgd2ViIHJlcXVlc3RcclxuXHRcdHRoaXMud2ViUmVxdWVzdHNTdGF0ZXMucmVtb3ZlKGRldGFpbHMucmVxdWVzdElkKTtcclxuXHJcblx0XHRjb25zdCBmcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKGRldGFpbHMpO1xyXG5cdFx0Ly8gU2tpcCB1bm1vbml0b3JlZCBmcmFtZXNcclxuXHRcdGlmIChmcmFtZVN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaWx0ZXIgZXZlbnRcclxuXHRcdGNvbnN0IG1vbml0b3JlZFN0YXRlID0gdGhpcy5nZXRNb25pdG9yZWRTdGF0ZShmcmFtZVN0YXRlLCBkZXRhaWxzKTtcclxuXHRcdGlmICghaXNNb25pdG9yZWRTdGF0ZShtb25pdG9yZWRTdGF0ZSkpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgYWRkaXRpb25hbCBkYXRhXHJcblx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5jcmVhdGVEYXRhTWVzc2FnZShcIkNvbXBsZXRlZFwiLCBkZXRhaWxzLCBmcmFtZVN0YXRlKTtcclxuXHJcblx0XHRjb25zdCBldmVudERhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0aWYgKGRldGFpbHMucmVzcG9uc2VIZWFkZXJzICE9IG51bGwpIHtcclxuXHRcdFx0V2ViUmVxdWVzdC5wb3B1bGF0ZUhlYWRlcnMoZGV0YWlscy5yZXNwb25zZUhlYWRlcnMsIFwicmVzcG9uc2VIZWFkZXJzXCIsIGV2ZW50RGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRldGFpbHMuaXAgIT0gbnVsbCkge1xyXG5cdFx0XHRldmVudERhdGEuaXAgPSBkZXRhaWxzLmlwO1xyXG5cdFx0fVxyXG5cdFx0ZXZlbnREYXRhLnN0YXR1c0xpbmUgPSBkZXRhaWxzLnN0YXR1c0xpbmU7XHJcblx0XHRldmVudERhdGEuc3RhdHVzQ29kZSA9IGRldGFpbHMuc3RhdHVzQ29kZTtcclxuXHRcdGV2ZW50RGF0YS5mcm9tQ2FjaGUgPSBkZXRhaWxzLmZyb21DYWNoZTtcclxuXHJcblx0XHRsZXQgZm9yY2VQb3N0ID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gTWFyayBkb3duIHRoZSB0aW1lXHJcblx0XHRpZiAocmVxdWVzdFN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0cmVxdWVzdFN0YXRlLnN0b3JlRXZlbnRUaW1lKFdlYlJlcXVlc3RFdmVudC5Db21wbGV0ZWQsIGRldGFpbHMudGltZVN0YW1wKTtcclxuXHJcblx0XHRcdC8vIEFsd2F5cyBwb3N0IGlmIEFwcEludGVybmFscyBoZWFkZXIgcHJlc2VudC5cclxuXHRcdFx0Zm9yY2VQb3N0ID0gcmVxdWVzdFN0YXRlLmFwcEludGVybmFsc01vbml0b3Jpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIG1vcmUgbWV0YSBkYXRhIGZvciBmdXJ0aGVyIGFuYWx5c2lzIGJ5IHRoZSBhZ2VudFxyXG5cdFx0V2ViUmVxdWVzdC5wb3B1bGF0ZU5ldHdvcmsocmVxdWVzdFN0YXRlLCBkZXRhaWxzLnRpbWVTdGFtcCwgZXZlbnREYXRhKTtcclxuXHJcblx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwpIHtcclxuXHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UsIHsgZm9yY2VQb3N0IH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uRXJyb3JPY2N1cnJlZCA9IChkZXRhaWxzOiB3ZWJSZXF1ZXN0LldlYlJlc3BvbnNlRXJyb3JEZXRhaWxzKTogQmxvY2tpbmdSZXNwb25zZSB8IHVuZGVmaW5lZCA9PiB7XHJcblx0XHRpZiAoIXRoaXMuaXNNb25pdG9yZWQoZGV0YWlscykpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmRlYnVnKFwiV2ViUmVxdWVzdC5vbkVycm9yT2NjdXJyZWRcIiwgZGV0YWlscyk7XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgcmVxdWVzdFxyXG5cdFx0Y29uc3QgcmVxdWVzdFN0YXRlID0gdGhpcy53ZWJSZXF1ZXN0c1N0YXRlcy5nZXQoZGV0YWlscy5yZXF1ZXN0SWQpO1xyXG5cclxuXHRcdC8vIFJlbW92ZSB3ZWIgcmVxdWVzdFxyXG5cdFx0dGhpcy53ZWJSZXF1ZXN0c1N0YXRlcy5yZW1vdmUoZGV0YWlscy5yZXF1ZXN0SWQpO1xyXG5cclxuXHRcdGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLnRhYnNTdGF0ZXMuZ2V0RnJhbWUoZGV0YWlscyk7XHJcblx0XHQvLyBTa2lwIHVubW9uaXRvcmVkIGZyYW1lc1xyXG5cdFx0aWYgKGZyYW1lU3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpbHRlciBldmVudFxyXG5cdFx0Y29uc3QgbW9uaXRvcmVkU3RhdGUgPSB0aGlzLmdldE1vbml0b3JlZFN0YXRlKGZyYW1lU3RhdGUsIGRldGFpbHMpO1xyXG5cdFx0aWYgKCFpc01vbml0b3JlZFN0YXRlKG1vbml0b3JlZFN0YXRlKSkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1hcmsgZG93biB0aGUgdGltZVxyXG5cdFx0aWYgKHJlcXVlc3RTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdHJlcXVlc3RTdGF0ZS5zdG9yZUV2ZW50VGltZShXZWJSZXF1ZXN0RXZlbnQuRXJyb3JPY2N1cnJlZCwgZGV0YWlscy50aW1lU3RhbXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENyZWF0ZSBtZXNzYWdlXHJcblx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5jcmVhdGVEYXRhTWVzc2FnZShcIkVycm9yT2NjdXJyZWRcIiwgZGV0YWlscywgZnJhbWVTdGF0ZSk7XHJcblx0XHRjb25zdCBldmVudERhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0aWYgKGRldGFpbHMuaXAgIT0gbnVsbCkge1xyXG5cdFx0XHRldmVudERhdGEuaXAgPSBkZXRhaWxzLmlwO1xyXG5cdFx0fVxyXG5cdFx0ZXZlbnREYXRhLmVycm9yID0gZGV0YWlscy5lcnJvcjtcclxuXHRcdGV2ZW50RGF0YS5mcm9tQ2FjaGUgPSBkZXRhaWxzLmZyb21DYWNoZTtcclxuXHJcblx0XHQvLyBBZGQgbW9yZSBtZXRhIGRhdGEgZm9yIGZ1cnRoZXIgYW5hbHlzaXMgYnkgdGhlIGFnZW50XHJcblx0XHRXZWJSZXF1ZXN0LnBvcHVsYXRlTmV0d29yayhyZXF1ZXN0U3RhdGUsIGRldGFpbHMudGltZVN0YW1wLCBldmVudERhdGEpO1xyXG5cclxuXHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCAmJiBtb25pdG9yZWRTdGF0ZS5tb25pdG9yV2ViUmVxdWVzdCkge1xyXG5cdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWVzc2FnZSBoYW5kbGVyIHRvIHBhc3MgY29uZmlndXJhdGlvbiB0byBjb250ZW50IHNjcmlwdC5cclxuXHQgKiBUaGUgcmVhc29uIGZvciBoYW5kbGluZyBtZXNzYWdlIGluIFdlYlJlcXVlc3QgaXMgdG8gcHJvdmlkZSBwYWdlIGluZm9ybWF0aW9uIHByb3BlcnRpZXNcclxuXHQgKiB3aXRoIHN0YXR1cyBjb2RlIGFuZCBmcmFtZSBpZHMuXHJcblx0ICovXHJcblx0cHJpdmF0ZSByZWFkb25seSBvbk1lc3NhZ2UgPSAoXHJcblx0XHRtZXNzYWdlOiBPdXRnb2luZ1BhZ2VOYXRpdmVNZXNzYWdlLFxyXG5cdFx0c2VuZGVyOiBjaHJvbWUucnVudGltZS5NZXNzYWdlU2VuZGVyLFxyXG5cdFx0c2VuZFJlc3BvbnNlOiAocmVzcG9uc2U6IHVua25vd24pID0+IHZvaWQpOiBib29sZWFuIHwgdm9pZCA9PiB7XHJcblxyXG5cdFx0c3dpdGNoIChtZXNzYWdlLm1lc3NhZ2VUeXBlKSB7XHJcblx0XHRcdGNhc2UgTWVzc2FnZVR5cGUuQ09OVEVOVF9TQ1JJUFRfTE9BRDpcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vbkNvbnRlbnRTY3JpcHRMb2FkKG1lc3NhZ2UsIHNlbmRlciwgc2VuZFJlc3BvbnNlKTtcclxuXHRcdFx0Y2FzZSBNZXNzYWdlVHlwZS5HRVRfU1RBVFVTX0NPREU6XHJcblx0XHRcdFx0dGhpcy5vbkdldFN0YXR1c0NvZGUoc2VuZGVyLCBzZW5kUmVzcG9uc2UpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG9uQ29udGVudFNjcmlwdExvYWQoXHJcblx0XHRtZXNzYWdlOiBPdXRnb2luZ1BhZ2VOYXRpdmVNZXNzYWdlLFxyXG5cdFx0c2VuZGVyOiBjaHJvbWUucnVudGltZS5NZXNzYWdlU2VuZGVyLFxyXG5cdFx0c2VuZFJlc3BvbnNlOiAocmVzcG9uc2U6IENvbnRlbnRTY3JpcHRQYXJhbWV0ZXJzKSA9PiB2b2lkKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5jb25maWd1cmF0aW9uID09IG51bGwpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiTm8gY29uZmlndXJhdGlvbiwgbm8gcmVwbHlcIik7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2VuZGVyLnRhYiA9PSBudWxsIHx8IHNlbmRlci50YWIuaWQgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgdGhlIGNvbnRlbnQgc2NyaXB0IHdhcyBsb2FkZWQgYnkgdGhlIG1haW4gZnJhbWUgb2YgdGhlIHBhZ2UsIG9yIGJ5IHNvbWVcclxuXHRcdC8vIHN1YiBmcmFtZS5cclxuXHRcdGNvbnN0IGZyYW1lSWQgPSBzZW5kZXIuZnJhbWVJZCAhPSBudWxsID8gc2VuZGVyLmZyYW1lSWQgOiAtMTtcclxuXHRcdGNvbnN0IGlzTWFpbkZyYW1lID0gKGZyYW1lSWQgPT09IDApO1xyXG5cdFx0Y29uc3QgdGFiSWQgPSBzZW5kZXIudGFiLmlkO1xyXG5cdFx0Y29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbjtcclxuXHRcdGNvbnN0IG1haW5GcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldFRhYih0YWJJZCk7XHJcblxyXG5cdFx0Ly8gU3BlY2lhbCBoYW5kbGluZyBmb3IgQ2hyb21lIHNob3J0Y3V0c1xyXG5cdFx0bGV0IGNvbW1pdHRlZFVybCA9IG1haW5GcmFtZVN0YXRlICE9IG51bGwgPyBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgOiBcIlwiO1xyXG5cdFx0Y29uc3QgdGFiUmVhZHkgPSBjb21taXR0ZWRVcmwgIT0gbnVsbCAmJiBjb21taXR0ZWRVcmwgIT09IFwiXCI7XHJcblx0XHRpZiAobWFpbkZyYW1lU3RhdGUgIT0gbnVsbCAmJiAhdGFiUmVhZHkpIHtcclxuXHRcdFx0Ly8gV2hlbiBydW5uaW5nIGNocm9tZSB3aXRoIHVybCBvbiB0aGUgY29tbWFuZCBsaW5lIG1haW5GcmFtZVN0YXRlIG1pZ2h0IHN0aWxsIGhhdmUgZW1wdHkgZG9jdW1lbnRDb21taXR0ZWRVcmwsXHJcblx0XHRcdC8vIG9yIGV2ZW4gZW1wdHkgZG9jdW1lbnRVcmwuIFdlIG11c3QgZmFsbCBiYWNrIHRvIGN1cnJlbnRVcmwsIHN0cmlwcGVkIG9mIHBhdGggKHRvIHN1cHBvcnQgU1BBcylcclxuXHRcdFx0Z2V0TG9nZ2VyKCkud2FybihgVGFiJHt0YWJJZH0gY29tbWl0dGVkVXJsIG5vdCByZWFkeSwgZmFsbGluZyBiYWNrIHRvIGN1cnJlbnRVcmwgaG9zdGApO1xyXG5cdFx0XHRpZiAoc2VuZGVyLnRhYi51cmwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbnN0IHVybDogVVJMID0gbmV3IFVSTChzZW5kZXIudGFiLnVybCk7XHJcblx0XHRcdFx0Y29tbWl0dGVkVXJsID0gdXJsLnByb3RvY29sICsgXCIvL1wiICsgdXJsLmhvc3RuYW1lO1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLmxvZyhgVXNpbmcgdXJsOiAke2NvbW1pdHRlZFVybH1gKTtcclxuXHRcdFx0XHRtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgPSBjb21taXR0ZWRVcmw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZW5kIHRoZSByZXNwb25zZSBhc3luY2hyb25vdXNseSwgc28gdGhhdCB3ZSBkb24ndCBibG9jayBjb250ZW50LlxyXG5cdFx0c2V0VGltZW91dChcclxuXHRcdFx0KCkgPT4geyB0aGlzLm9uQ29udGVudFNjcmlwdExvYWRJbXBsKHRhYklkLCBmcmFtZUlkLCBpc01haW5GcmFtZSwgY29uZmlndXJhdGlvbiwgc2VuZFJlc3BvbnNlKTsgfSxcclxuXHRcdFx0MCk7XHJcblxyXG5cdFx0Ly8gS2VlcCBjb25uZWN0aW9uIHdpdGggY29udGVudCBzY3JpcHQgb3BlbmVkLlxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG9uQ29udGVudFNjcmlwdExvYWRJbXBsKFxyXG5cdFx0dGFiSWQ6IG51bWJlcixcclxuXHRcdGZyYW1lSWQ6IG51bWJlcixcclxuXHRcdGlzTWFpbkZyYW1lOiBib29sZWFuLFxyXG5cdFx0Y29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbixcclxuXHRcdHNlbmRSZXNwb25zZTogKHJlc3BvbnNlOiBDb250ZW50U2NyaXB0UGFyYW1ldGVycykgPT4gdm9pZCk6IHZvaWQge1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IG1haW5GcmFtZVN0YXRlID0gdGhpcy50YWJzU3RhdGVzLmdldFRhYih0YWJJZCk7XHJcblxyXG5cdFx0XHQvLyBGcmFtZSBub3QgcHJlc2VudCBtZWFucyB0aGF0IGV4dGVuc2lvbiByYW4gYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdFx0XHRjb25zdCBjdXJyZW50RnJhbWVTdGF0ZSA9XHJcblx0XHRcdFx0ZnJhbWVJZCAhPT0gLTFcclxuXHRcdFx0XHRcdD8gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKHsgdGFiSWQ6IHRhYklkLCBmcmFtZUlkOiBmcmFtZUlkIH0pXHJcblx0XHRcdFx0XHQ6IG51bGw7XHJcblx0XHRcdGNvbnN0IHdwbVBhcmFtZXRlcnM6IFdwbVBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdFx0d3BtOiBmYWxzZSxcclxuXHRcdFx0XHRodHRwV2ViUGFnZUxvYWQ6IGZhbHNlXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAobWFpbkZyYW1lU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmIChpc01haW5GcmFtZSkge1xyXG5cdFx0XHRcdFx0d3BtUGFyYW1ldGVycy53cG0gPVxyXG5cdFx0XHRcdFx0XHRjb25maWd1cmF0aW9uLmlzTWF0Y2hGb3JXcG1VcmxzKG1haW5GcmFtZVN0YXRlLnN0YXJ0VXJsLCBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR3cG1QYXJhbWV0ZXJzLmh0dHBXZWJQYWdlTG9hZCA9IGNvbmZpZ3VyYXRpb24uaXNNYXRjaEZvckh0dHBXZWJQYWdlTG9hZFVybChtYWluRnJhbWVTdGF0ZS5zdGFydFVybCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGRvY3VtZW50VXJsID0gbWFpbkZyYW1lU3RhdGUgIT0gbnVsbCA/IG1haW5GcmFtZVN0YXRlLnN0YXJ0VXJsIDogXCJcIjtcclxuXHRcdFx0Y29uc3QgZG9jdW1lbnRDb21taXR0ZWRVcmwgPSAobWFpbkZyYW1lU3RhdGUgIT0gbnVsbCAmJiBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgIT0gbnVsbCkgPyBtYWluRnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgOiBcIlwiO1xyXG5cdFx0XHRsZXQgZG9jdW1lbnRUaXRsZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRpZiAodGhpcy50YWJzTW9uaXRvcmluZyAhPSBudWxsKSB7XHJcblx0XHRcdFx0Y29uc3QgdGFiU3RhdGUgPSB0aGlzLnRhYnNNb25pdG9yaW5nLmdldFRhYlN0YXRlKHRhYklkKTtcclxuXHRcdFx0XHRpZiAodGFiU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0ZG9jdW1lbnRUaXRsZSA9IHRhYlN0YXRlLmRvY3VtZW50VGl0bGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCByZXNwb25zZTogQ29udGVudFNjcmlwdFBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdFx0Y29uZmlndXJhdGlvbkRhdGE6IGNvbmZpZ3VyYXRpb24uZ2V0RXZlbnRzRm9yUGFnZSh7XHJcblx0XHRcdFx0XHRkb2N1bWVudFVybCxcclxuXHRcdFx0XHRcdGRvY3VtZW50Q29tbWl0dGVkVXJsXHJcblx0XHRcdFx0fSksXHJcblx0XHRcdFx0cGFnZUluZm9ybWF0aW9uOiB7XHJcblx0XHRcdFx0XHRkb2N1bWVudFVybDogZG9jdW1lbnRVcmwsXHJcblx0XHRcdFx0XHRkb2N1bWVudENvbW1pdHRlZFVybDogZG9jdW1lbnRDb21taXR0ZWRVcmwsXHJcblx0XHRcdFx0XHRmcmFtZVVybDogY3VycmVudEZyYW1lU3RhdGUgIT0gbnVsbCA/IGN1cnJlbnRGcmFtZVN0YXRlLnN0YXJ0VXJsIDogXCJcIixcclxuXHRcdFx0XHRcdGZyYW1lQ29tbWl0dGVkVXJsOlxyXG5cdFx0XHRcdFx0XHRjdXJyZW50RnJhbWVTdGF0ZSAhPSBudWxsXHJcblx0XHRcdFx0XHRcdD8gY3VycmVudEZyYW1lU3RhdGUuY29tbWl0dGVkVXJsICE9IG51bGxcclxuXHRcdFx0XHRcdFx0PyBjdXJyZW50RnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgOiBcIlwiIDogXCJcIixcclxuXHRcdFx0XHRcdHRhYklkOiB0YWJJZCxcclxuXHRcdFx0XHRcdGZyYW1lSWQ6IGZyYW1lSWQsXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRzdGF0dXNDb2RlOiBjdXJyZW50RnJhbWVTdGF0ZSAhPSBudWxsID8gY3VycmVudEZyYW1lU3RhdGUuc3RhdHVzQ29kZSA6IDAsXHJcblx0XHRcdFx0d3BtUGFyYW1ldGVyczogd3BtUGFyYW1ldGVycyxcclxuXHRcdFx0XHRkb2N1bWVudFRpdGxlOiBkb2N1bWVudFRpdGxlLFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0c2VuZFJlc3BvbnNlKHJlc3BvbnNlKTtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuaW5mbyhcIlNlbnQgY29uZmlndXJhdGlvbiB0byBjb250ZW50XCIsIHJlc3BvbnNlKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkud2FybihgQ291bGRuJ3Qgc2VuZCBjb25maWd1cmF0aW9uIHRvIHRhYjogJHt0YWJJZH0sIGZyYW1lOiAke2ZyYW1lSWR9LCBlcnJvcjogYCwgZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG9uR2V0U3RhdHVzQ29kZShcclxuXHRcdHNlbmRlcjogY2hyb21lLnJ1bnRpbWUuTWVzc2FnZVNlbmRlcixcclxuXHRcdHNlbmRSZXNwb25zZTogKHJlc3BvbnNlOiBDb250ZW50UGFyYW1ldGVycykgPT4gdm9pZCk6IHZvaWQge1xyXG5cclxuXHRcdGNvbnN0IHRhYklkID1cclxuXHRcdFx0c2VuZGVyLnRhYiAhPSBudWxsICYmIHNlbmRlci50YWIuaWQgIT0gbnVsbFxyXG5cdFx0XHRcdD8gc2VuZGVyLnRhYi5pZFxyXG5cdFx0XHRcdDogLTE7XHJcblxyXG5cdFx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBBc3NpZ25lZFZhbHVlSXNOZXZlclVzZWRcclxuXHRcdGxldCBzdGF0dXNDb2RlID0gLTE7XHJcblxyXG5cdFx0Y29uc3QgY3VycmVudEZyYW1lID1cclxuXHRcdFx0c2VuZGVyLmZyYW1lSWQgIT0gbnVsbFxyXG5cdFx0XHRcdD8gdGhpcy50YWJzU3RhdGVzLmdldEZyYW1lKHsgdGFiSWQ6IHRhYklkLCBmcmFtZUlkOiBzZW5kZXIuZnJhbWVJZCB9KVxyXG5cdFx0XHRcdDogbnVsbDtcclxuXHRcdGlmIChjdXJyZW50RnJhbWUgPT0gbnVsbCkge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkRpZCBub3QgcmVjZWl2ZSBmcmFtZUlkIGZyb20gc2VuZGVyLiBQcm9iYWJseSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgQ2hyb21lIHZlcnNpb24uXCIpO1xyXG5cdFx0XHRzdGF0dXNDb2RlID0gLTE7XHJcblx0XHR9IGVsc2UgaWYgKGN1cnJlbnRGcmFtZS5zdGF0dXNDb2RlID09IG51bGwpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJEaWQgbm90IHJlY2VpdmUgc3RhdHVzQ29kZS5cIik7XHJcblx0XHRcdHN0YXR1c0NvZGUgPSAtMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0YXR1c0NvZGUgPSBjdXJyZW50RnJhbWUuc3RhdHVzQ29kZTtcclxuXHRcdH1cclxuXHJcblx0XHRzZW5kUmVzcG9uc2UoeyBzdGF0dXNDb2RlIH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG5cclxuXHRwdWJsaWMgaW5pdFdlYlJlcXVlc3QoXHJcblx0XHRtYW5hZ2VyOiBJQmFja2dyb3VuZE1hbmFnZXIsXHJcblx0XHRjb21tdW5pY2F0aW9uOiBJQWdlbnRDb21tdW5pY2F0aW9uLFxyXG5cdFx0dGFic01vbml0b3Jpbmc6IElUYWJzTW9uaXRvcmluZyxcclxuXHRcdGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb24pOiB2b2lkIHtcclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cdFx0dGhpcy5jb21tdW5pY2F0aW9uID0gY29tbXVuaWNhdGlvbjtcclxuXHRcdHRoaXMudGFic01vbml0b3JpbmcgPSB0YWJzTW9uaXRvcmluZztcclxuXHRcdHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XHJcblx0XHRjb25zdCBmaWx0ZXI6IFJlcXVlc3RGaWx0ZXIgPSB7IHVybHM6IFtcIjxhbGxfdXJscz5cIl0gfTtcclxuXHJcblx0XHR3ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdC5hZGRMaXN0ZW5lcih0aGlzLm9uQmVmb3JlUmVxdWVzdCwgZmlsdGVyLCBbXCJyZXF1ZXN0Qm9keVwiXSk7XHJcblx0XHR3ZWJSZXF1ZXN0Lm9uQmVmb3JlU2VuZEhlYWRlcnMuYWRkTGlzdGVuZXIodGhpcy5vbkJlZm9yZVNlbmRIZWFkZXJzLCBmaWx0ZXIsIFtcInJlcXVlc3RIZWFkZXJzXCJdKTtcclxuXHRcdHdlYlJlcXVlc3Qub25TZW5kSGVhZGVycy5hZGRMaXN0ZW5lcih0aGlzLm9uU2VuZEhlYWRlcnMsIGZpbHRlciwgW1wicmVxdWVzdEhlYWRlcnNcIl0pO1xyXG5cdFx0d2ViUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZC5hZGRMaXN0ZW5lcih0aGlzLm9uSGVhZGVyc1JlY2VpdmVkLCBmaWx0ZXIsIFtcInJlc3BvbnNlSGVhZGVyc1wiXSk7XHJcblx0XHR3ZWJSZXF1ZXN0Lm9uQXV0aFJlcXVpcmVkLmFkZExpc3RlbmVyKHRoaXMub25BdXRoUmVxdWlyZWQsIGZpbHRlciwgW1wicmVzcG9uc2VIZWFkZXJzXCJdKTtcclxuXHRcdHdlYlJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWQuYWRkTGlzdGVuZXIodGhpcy5vblJlc3BvbnNlU3RhcnRlZCwgZmlsdGVyLCBbXCJyZXNwb25zZUhlYWRlcnNcIl0pO1xyXG5cdFx0d2ViUmVxdWVzdC5vbkJlZm9yZVJlZGlyZWN0LmFkZExpc3RlbmVyKHRoaXMub25CZWZvcmVSZWRpcmVjdCwgZmlsdGVyLCBbXCJyZXNwb25zZUhlYWRlcnNcIl0pO1xyXG5cdFx0d2ViUmVxdWVzdC5vbkNvbXBsZXRlZC5hZGRMaXN0ZW5lcih0aGlzLm9uQ29tcGxldGVkLCBmaWx0ZXIsIFtcInJlc3BvbnNlSGVhZGVyc1wiXSk7XHJcblx0XHR3ZWJSZXF1ZXN0Lm9uRXJyb3JPY2N1cnJlZC5hZGRMaXN0ZW5lcih0aGlzLm9uRXJyb3JPY2N1cnJlZCwgZmlsdGVyKTtcclxuXHJcblx0XHRjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIodGhpcy5vbk1lc3NhZ2UpO1xyXG5cclxuXHRcdHRoaXMudGFic1N0YXRlcy52YWxpZGF0ZUFsbFRhYnMoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1bmluaXRXZWJSZXF1ZXN0KCk6IHZvaWQge1xyXG5cclxuXHRcdHdlYlJlcXVlc3Qub25CZWZvcmVSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKHRoaXMub25CZWZvcmVSZXF1ZXN0KTtcclxuXHRcdHdlYlJlcXVlc3Qub25CZWZvcmVTZW5kSGVhZGVycy5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uQmVmb3JlU2VuZEhlYWRlcnMpO1xyXG5cdFx0d2ViUmVxdWVzdC5vblNlbmRIZWFkZXJzLnJlbW92ZUxpc3RlbmVyKHRoaXMub25TZW5kSGVhZGVycyk7XHJcblx0XHR3ZWJSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkLnJlbW92ZUxpc3RlbmVyKHRoaXMub25IZWFkZXJzUmVjZWl2ZWQpO1xyXG5cdFx0d2ViUmVxdWVzdC5vbkF1dGhSZXF1aXJlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uQXV0aFJlcXVpcmVkKTtcclxuXHRcdHdlYlJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vblJlc3BvbnNlU3RhcnRlZCk7XHJcblx0XHR3ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVkaXJlY3QucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkJlZm9yZVJlZGlyZWN0KTtcclxuXHRcdHdlYlJlcXVlc3Qub25Db21wbGV0ZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkNvbXBsZXRlZCk7XHJcblx0XHR3ZWJSZXF1ZXN0Lm9uRXJyb3JPY2N1cnJlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uRXJyb3JPY2N1cnJlZCk7XHJcblxyXG5cdFx0Y2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKHRoaXMub25NZXNzYWdlKTtcclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNvbW11bmljYXRpb24gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNvbmZpZ3VyYXRpb24gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnRhYnNNb25pdG9yaW5nID0gdW5kZWZpbmVkO1xyXG5cdH1cclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFJlU2hhcnBlciBkaXNhYmxlIEluY29uc2lzdGVudE5hbWluZ1xyXG5cclxuLyoqXHJcbiAqIFdlYlJlcXVlc3QgZXZlbnRzLlxyXG4gKiBUaGlzIG11c3QgYmUgc3luY2hyb25pemVkIHdpdGggdGhlIEFnZW50LlxyXG4gKi9cclxuZXhwb3J0IGVudW0gV2ViUmVxdWVzdEV2ZW50IHtcclxuXHRCZWZvcmVSZXF1ZXN0LFxyXG5cdEJlZm9yZVNlbmRIZWFkZXJzLFxyXG5cdFNlbmRIZWFkZXJzLFxyXG5cdEhlYWRlcnNSZWNlaXZlZCxcclxuXHRBdXRoUmVxdWlyZWQsXHJcblx0UmVzcG9uc2VTdGFydGVkLFxyXG5cdEJlZm9yZVJlZGlyZWN0LFxyXG5cdENvbXBsZXRlZCxcclxuXHRFcnJvck9jY3VycmVkLFxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxzL2xvZ1wiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcclxuaW1wb3J0IHsgSUJhY2tncm91bmRNYW5hZ2VyIH0gZnJvbSBcIi4vSUJhY2tncm91bmRNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IElBZ2VudENvbW11bmljYXRpb24gfSBmcm9tIFwiLi9JQWdlbnRDb21tdW5pY2F0aW9uXCI7XHJcbmltcG9ydCB7IHRpbWVQcm92aWRlciB9IGZyb20gXCIuLi91dGlscy90aW1lUHJvdmlkZXJcIjtcclxuaW1wb3J0IHsgVVhEYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi9VWERhdGFcIjtcclxuaW1wb3J0IHsgT3V0Z29pbmdFdmVudE1lc3NhZ2UgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NhZ2luZ01vZGVsXCI7XHJcbmltcG9ydCB7IElJZGxlTW9uaXRvcmluZyB9IGZyb20gXCIuL0lJZGxlTW9uaXRvcmluZ1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IElETEVfRVZFTlRfTkFNRVNQQUNFID0gXCJ1aTpjaHJvbWU6SWRsZVwiO1xyXG5cclxuZnVuY3Rpb24gbWFrZUV2ZW50TmFtZShldmVudDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gSURMRV9FVkVOVF9OQU1FU1BBQ0UgKyBcIi5cIiArIGV2ZW50O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGJhc2UgdGFiIG1lc3NhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVEYXRhTWVzc2FnZShldmVudDogc3RyaW5nKTogT3V0Z29pbmdFdmVudE1lc3NhZ2U8VVhEYXRhPiB7XHJcblx0Y29uc3QgbWVzc2FnZSA9IG5ldyBPdXRnb2luZ0V2ZW50TWVzc2FnZTxVWERhdGE+KG1ha2VFdmVudE5hbWUoZXZlbnQpLCB0aW1lUHJvdmlkZXIubm93KCkpO1xyXG5cdHJldHVybiBtZXNzYWdlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgSWRsZU1vbml0b3JpbmcgaW1wbGVtZW50cyBJSWRsZU1vbml0b3Jpbmcge1xyXG5cdHByaXZhdGUgbWFuYWdlcj86IElCYWNrZ3JvdW5kTWFuYWdlcjtcclxuXHRwcml2YXRlIGNvbW11bmljYXRpb24/OiBJQWdlbnRDb21tdW5pY2F0aW9uO1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uU3RhdGVDaGFuZ2VkID0gKG5ld1N0YXRlOiBzdHJpbmcpID0+IHtcclxuXHRcdGlmICh0aGlzLm1hbmFnZXIgPT0gbnVsbCB8fCAhdGhpcy5tYW5hZ2VyLmFjdGl2ZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJJZGxlIG9uU3RhdGVDaGFuZ2VkXCIsIG5ld1N0YXRlKTtcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVEYXRhTWVzc2FnZShVdGlscy5jYXBpdGFsaXplKG5ld1N0YXRlKSk7XHJcblx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwpIHtcclxuXHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHByaXZhdGUgaWRsZU1vbml0b3JpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdHB1YmxpYyBpbml0SWRsZU1vbml0b3JpbmcobWFuYWdlcjogSUJhY2tncm91bmRNYW5hZ2VyLCBjb21tdW5pY2F0aW9uOiBJQWdlbnRDb21tdW5pY2F0aW9uKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5pZGxlTW9uaXRvcmluZ0VuYWJsZWQpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJZb3UgY2FuJ3QgaW5pdCBpZGxlIG1vbml0b3JpbmcgdHdpY2UgaW4gYSByb3cgKHdpdGhvdXQgdW5pbml0KVwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XHJcblx0XHR0aGlzLmNvbW11bmljYXRpb24gPSBjb21tdW5pY2F0aW9uO1xyXG5cclxuXHRcdHRoaXMuaWRsZU1vbml0b3JpbmdFbmFibGVkID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoY2hyb21lLmlkbGUub25TdGF0ZUNoYW5nZWQgIT0gbnVsbCkge1xyXG5cdFx0XHRjaHJvbWUuaWRsZS5vblN0YXRlQ2hhbmdlZC5hZGRMaXN0ZW5lcih0aGlzLm9uU3RhdGVDaGFuZ2VkKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1bmluaXRJZGxlTW9uaXRvcmluZygpOiB2b2lkIHtcclxuXHRcdHRoaXMuaWRsZU1vbml0b3JpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKGNocm9tZS5pZGxlLm9uU3RhdGVDaGFuZ2VkICE9IG51bGwpIHtcclxuXHRcdFx0Y2hyb21lLmlkbGUub25TdGF0ZUNoYW5nZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vblN0YXRlQ2hhbmdlZCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxzL2xvZ1wiO1xyXG5pbXBvcnQgeyBJQmFja2dyb3VuZE1hbmFnZXIgfSBmcm9tIFwiLi9JQmFja2dyb3VuZE1hbmFnZXJcIjtcclxuaW1wb3J0IHsgSUFnZW50Q29tbXVuaWNhdGlvbiB9IGZyb20gXCIuL0lBZ2VudENvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IHsgdGltZVByb3ZpZGVyIH0gZnJvbSBcIi4uL3V0aWxzL3RpbWVQcm92aWRlclwiO1xyXG5pbXBvcnQgeyBPdXRnb2luZ0V2ZW50TWVzc2FnZSB9IGZyb20gXCIuLi9jb21tb24vTWVzc2FnaW5nTW9kZWxcIjtcclxuaW1wb3J0IHsgVVhEYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi9VWERhdGFcIjtcclxuaW1wb3J0IHsgSVdpbmRvd3NNb25pdG9yaW5nIH0gZnJvbSBcIi4vSVdpbmRvd3NNb25pdG9yaW5nXCI7XHJcblxyXG4vLyAjcmVnaW9uIFV0aWxpdHlcclxuXHJcbmV4cG9ydCBjb25zdCBXSU5ET1dfRVZFTlRfTkFNRVNQQUNFID0gXCJ1aTpjaHJvbWU6V2luZG93XCI7XHJcblxyXG5mdW5jdGlvbiBtYWtlRXZlbnROYW1lKGV2ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdHJldHVybiBXSU5ET1dfRVZFTlRfTkFNRVNQQUNFICsgXCIuXCIgKyBldmVudDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFdpbmRvd0V2ZW50RGF0YSBleHRlbmRzIFVYRGF0YSB7XHJcblx0dGFiSWQ/OiBudW1iZXI7XHJcblx0d2luZG93SWQ/OiBudW1iZXI7XHJcblx0dXJsPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGJhc2UgdGFiIG1lc3NhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVEYXRhTWVzc2FnZShcclxuXHRldmVudDogc3RyaW5nLFxyXG5cdHRpbWVzdGFtcDogbnVtYmVyID0gdGltZVByb3ZpZGVyLm5vdygpLFxyXG5cdHRhYj86IGNocm9tZS50YWJzLlRhYik6IE91dGdvaW5nRXZlbnRNZXNzYWdlPFdpbmRvd0V2ZW50RGF0YT4ge1xyXG5cdGNvbnN0IG1lc3NhZ2UgPSBuZXcgT3V0Z29pbmdFdmVudE1lc3NhZ2U8V2luZG93RXZlbnREYXRhPihtYWtlRXZlbnROYW1lKGV2ZW50KSwgdGltZXN0YW1wKTtcclxuXHJcblx0Y29uc3QgbWVzc2FnZURhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdGlmICh0YWIgIT0gbnVsbCkge1xyXG5cdFx0bWVzc2FnZURhdGEud2luZG93SWQgPSB0YWIud2luZG93SWQ7XHJcblx0XHRtZXNzYWdlRGF0YS50YWJJZCA9IHRhYi5pZDtcclxuXHRcdG1lc3NhZ2VEYXRhLnVybCA9IHRhYi51cmw7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWVzc2FnZTtcclxufVxyXG5cclxuLy8gI2VuZHJlZ2lvblxyXG5cclxuZXhwb3J0IGNsYXNzIFdpbmRvd3NNb25pdG9yaW5nIGltcGxlbWVudHMgSVdpbmRvd3NNb25pdG9yaW5nIHtcclxuXHRwcml2YXRlIG1hbmFnZXI/OiBJQmFja2dyb3VuZE1hbmFnZXI7XHJcblx0cHJpdmF0ZSBjb21tdW5pY2F0aW9uPzogSUFnZW50Q29tbXVuaWNhdGlvbjtcclxuXHJcblx0cHJpdmF0ZSByZWFkb25seSBvbkZvY3VzQ2hhbmdlZCA9ICh3aW5kb3dJZDogbnVtYmVyKSA9PiB7XHJcblx0XHRpZiAodGhpcy5tYW5hZ2VyID09IG51bGwgfHwgIXRoaXMubWFuYWdlci5hY3RpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgY29tbXVuaWNhdGlvbiA9IHRoaXMuY29tbXVuaWNhdGlvbjtcclxuXHRcdGlmIChjb21tdW5pY2F0aW9uID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3aW5kb3dJZCAhPT0gY2hyb21lLndpbmRvd3MuV0lORE9XX0lEX05PTkUpIHtcclxuXHRcdFx0Y29uc3Qgbm93ID0gdGltZVByb3ZpZGVyLm5vdygpO1xyXG5cclxuXHRcdFx0Y2hyb21lLnRhYnMucXVlcnkoeyBhY3RpdmU6IHRydWUsIHdpbmRvd0lkOiB3aW5kb3dJZCB9LFxyXG5cdFx0XHRcdHJlc3VsdCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB0YWIgPSAocmVzdWx0ICE9IG51bGwgJiYgcmVzdWx0Lmxlbmd0aCA+PSAwID8gcmVzdWx0WzBdIDogdW5kZWZpbmVkKTtcclxuXHRcdFx0XHRcdGdldExvZ2dlcigpLmRlYnVnKFwiV2luZG93IG9uRm9jdXNDaGFuZ2VkXCIsIHRhYik7XHJcblx0XHRcdFx0XHRjb25zdCBtZXNzYWdlID0gY3JlYXRlRGF0YU1lc3NhZ2UoXCJGb2N1c0NoYW5nZWRcIiwgbm93LCB0YWIpO1xyXG5cdFx0XHRcdFx0Y29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShtZXNzYWdlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmRlYnVnKFwiV2luZG93IExvc3RGb2N1c1wiKTtcclxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGNyZWF0ZURhdGFNZXNzYWdlKFwiTG9zdEZvY3VzXCIpO1xyXG5cdFx0XHRjb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHByaXZhdGUgd2luZG93TW9uaXRvcmluZ0VuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0cHVibGljIGluaXRXaW5kb3dzTW9uaXRvcmluZyhtYW5hZ2VyOiBJQmFja2dyb3VuZE1hbmFnZXIsIGNvbW11bmljYXRpb246IElBZ2VudENvbW11bmljYXRpb24pOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLndpbmRvd01vbml0b3JpbmdFbmFibGVkKSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiWW91IGNhbid0IGluaXQgd2luZG93cyBtb25pdG9yaW5nIHR3aWNlIGluIGEgcm93ICh3aXRob3V0IHVuaW5pdClcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cdFx0dGhpcy5jb21tdW5pY2F0aW9uID0gY29tbXVuaWNhdGlvbjtcclxuXHJcblx0XHR0aGlzLndpbmRvd01vbml0b3JpbmdFbmFibGVkID0gdHJ1ZTtcclxuXHRcdGNocm9tZS53aW5kb3dzLm9uRm9jdXNDaGFuZ2VkLmFkZExpc3RlbmVyKHRoaXMub25Gb2N1c0NoYW5nZWQpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHVuaW5pdFdpbmRvd3NNb25pdG9yaW5nKCk6IHZvaWQge1xyXG5cdFx0dGhpcy53aW5kb3dNb25pdG9yaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGNocm9tZS53aW5kb3dzLm9uRm9jdXNDaGFuZ2VkLnJlbW92ZUxpc3RlbmVyKHRoaXMub25Gb2N1c0NoYW5nZWQpO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IHN0YXJ0c1dpdGggfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcclxuaW1wb3J0IFRhYiA9IGNocm9tZS50YWJzLlRhYjtcclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlIHNjcmlwdCB3aXRoIGVycm9yIGhhbmRsaW5nIGluIGEgc3BlY2lmaWVkIHRhYi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlRnVuY3Rpb25JblRhYih0YWI6IFRhYiwgZjogKCkgPT4gdm9pZCwgbWV0aG9kOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRpZiAodHlwZW9mIHRhYi5pZCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xyXG5cdGlmICh0YWIudXJsID09IG51bGwpIHJldHVybjtcclxuXHRpZiAoIXN0YXJ0c1dpdGgodGFiLnVybCwgXCJodHRwXCIpKSByZXR1cm47XHJcblxyXG5cdGNocm9tZS5zY3JpcHRpbmcuZXhlY3V0ZVNjcmlwdChcclxuXHRcdHtcclxuXHRcdFx0dGFyZ2V0OiB7dGFiSWQ6IHRhYi5pZCwgYWxsRnJhbWVzOiB0cnVlfSwgZnVuYzogZiwgYXJnczogW11cclxuXHRcdH1cclxuXHQpLnRoZW4oKHZhbHVlKSA9PiB7XHJcblx0XHRpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yICE9IG51bGwpIHtcclxuXHRcdFx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBUc1Jlc29sdmVkRnJvbUluYWNjZXNzaWJsZU1vZHVsZVxyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihgQ291bGQgbm90IGV4ZWN1dGUgJHttZXRob2R9IGluIHRhYmAsIHRhYi5pZCwgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH0pLmNhdGNoKChyZWFzb24pID0+IHtcclxuXHRcdC8vIFJlU2hhcnBlciBkaXNhYmxlIG9uY2UgVHNSZXNvbHZlZEZyb21JbmFjY2Vzc2libGVNb2R1bGVcclxuXHRcdGdldExvZ2dlcigpLmVycm9yKGBDb3VsZCBub3QgZXhlY3V0ZSAke21ldGhvZH0gaW4gdGFiYCwgdGFiLmlkLCByZWFzb24pO1xyXG5cdH0pO1xyXG5cclxuXHJcblx0Ly8gY2hyb21lLnRhYnMuZXhlY3V0ZVNjcmlwdCh0YWIuaWQsXHJcblx0Ly8gXHR7XHJcblx0Ly8gXHRcdGNvZGU6IG1ha2VGdW5jdGlvbkNhbGwoZiksXHJcblx0Ly8gXHRcdGFsbEZyYW1lczogdHJ1ZVxyXG5cdC8vIFx0fSxcclxuXHQvLyBcdCgpID0+IHtcclxuXHQvLyBcdFx0aWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvciAhPSBudWxsKSB7XHJcblx0Ly8gXHRcdFx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBUc1Jlc29sdmVkRnJvbUluYWNjZXNzaWJsZU1vZHVsZVxyXG5cdC8vIFx0XHRcdGdldExvZ2dlcigpLmVycm9yKGBDb3VsZCBub3QgZXhlY3V0ZSAke21ldGhvZH0gaW4gdGFiYCwgdGFiLmlkLCBjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSk7XHJcblx0Ly8gXHRcdH1cclxuXHQvLyBcdH1cclxuXHQvLyApO1xyXG59XHJcblxyXG4vKipcclxuICogU2VuZCBtZXNzYWdlIHdpdGggZXJyb3IgaGFuZGxpbmcgdG8gYSBzcGVjaWZpZWQgdGFiLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNZXNzYWdlVG9UYWI8VD4oXHJcblx0dGFiOiBUYWIsXHJcblx0ZnJhbWVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLFxyXG5cdG1lc3NhZ2U6IFQsXHJcblx0c3VjY2Vzcz86ICgocmVzcG9uc2U6IHVua25vd24pID0+IHZvaWQpIHwgdW5kZWZpbmVkLFxyXG5cdGZhaWx1cmU/OiAobGFzdEVycm9yOiBjaHJvbWUucnVudGltZS5MYXN0RXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0YWIuaWQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuXHRpZiAodGFiLnVybCA9PSBudWxsKSByZXR1cm47XHJcblx0aWYgKCFzdGFydHNXaXRoKHRhYi51cmwsIFwiaHR0cFwiKSkgcmV0dXJuO1xyXG5cclxuXHRjaHJvbWUudGFicy5zZW5kTWVzc2FnZShcclxuXHRcdHRhYi5pZCxcclxuXHRcdG1lc3NhZ2UsXHJcblx0XHR7IGZyYW1lSWQ6IGZyYW1lSWQgfSxcclxuXHRcdChyZXNwb25zZTogdW5rbm93bikgPT4ge1xyXG5cdFx0XHRpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yID09IG51bGwpIHtcclxuXHRcdFx0XHRpZiAoc3VjY2VzcyAhPSBudWxsKSBzdWNjZXNzKHJlc3BvbnNlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoc3VjY2VzcyA9PT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdFx0XHRjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSA9PT0gXCJUaGUgbWVzc2FnZSBwb3J0IGNsb3NlZCBiZWZvcmUgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWQuXCIpIHtcclxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgZXhwZWN0ZWQgYW5kIGNvdWxkIGJlIGF2b2lkZWQgYnkgc2VuZE1lc3NhZ2Ugd2l0aG91dCBhIHJlc3BvbnNlIGNhbGxiYWNrLlxyXG5cdFx0XHRcdFx0Ly8gV2Ugc3RpbGwgY2FsbCBzZW5kTWVzc2FnZSB0aGlzIHdheSB0byBsb2cgYW55IG90aGVyIGVycm9ycy5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChmYWlsdXJlICE9IG51bGwpIGZhaWx1cmUoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIG1lc3NhZ2Ugd2l0aCBlcnJvciBoYW5kbGluZyB0byBhIHNwZWNpZmllZCB0YWIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VuZE1lc3NhZ2VUb1RhYldpdGhMb2c8VD4odGFiOiBUYWIsIG1lc3NhZ2U6IFQpOiB2b2lkIHtcclxuXHRzZW5kTWVzc2FnZVRvVGFiKFxyXG5cdFx0dGFiLFxyXG5cdFx0dW5kZWZpbmVkLFxyXG5cdFx0bWVzc2FnZSxcclxuXHRcdHVuZGVmaW5lZCxcclxuXHRcdChsYXN0RXJyb3IpID0+IHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJDb3VsZCBub3Qgc2VuZCBtZXNzYWdlIHRvIHRhYlwiLCB0YWIuaWQsIFwiZXJyb3I6XCIsIGxhc3RFcnJvci5tZXNzYWdlLCBcIm1lc3NhZ2UgdG8gYmUgc2VudDpcIiwgbWVzc2FnZSk7XHJcblx0XHR9KTtcclxufVxyXG4iLCIvLyBNYWtlIGxvZ2dpbmcgZ2xvYmFsbHkgdmlzaWJsZVxyXG5leHBvcnQgeyBlbmFibGVMb2dzLCBkaXNhYmxlTG9ncyB9IGZyb20gXCIuLi91dGlscy9sb2dcIjtcclxuXHJcbmltcG9ydCB7IEFnZW50Q29tbXVuaWNhdGlvbiB9IGZyb20gXCIuL0FnZW50Q29tbXVuaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBCYWNrZ3JvdW5kTWFuYWdlciB9IGZyb20gXCIuL0JhY2tncm91bmRNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFdlYlJlcXVlc3QgfSBmcm9tIFwiLi9XZWJSZXF1ZXN0XCI7XHJcbmltcG9ydCB7IFdlYk5hdmlnYXRpb24gfSBmcm9tIFwiLi9XZWJOYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IFRhYnNNb25pdG9yaW5nIH0gZnJvbSBcIi4vVGFic01vbml0b3JpbmdcIjtcclxuaW1wb3J0IHsgV2luZG93c01vbml0b3JpbmcgfSBmcm9tIFwiLi9XaW5kb3dzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyBJZGxlTW9uaXRvcmluZyB9IGZyb20gXCIuL0lkbGVNb25pdG9yaW5nXCI7XHJcbmltcG9ydCB7IEh0bWxFdmVudHNNb25pdG9yaW5nIH0gZnJvbSBcIi4vSHRtbEV2ZW50c01vbml0b3JpbmdcIjtcclxuaW1wb3J0IHsgV2FjQ29tbXVuaWNhdGlvbiB9IGZyb20gXCIuL1dhY0NvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IHsgQ29uZmlndXJhdGlvbk1hbmFnZXIgfSBmcm9tIFwiLi9Db25maWd1cmF0aW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBXYWNFdmVudFJlcG9ydGVyIH0gZnJvbSBcIi4vV2FjRXZlbnRSZXBvcnRlclwiO1xyXG5pbXBvcnQgeyBEb3dubG9hZHNNb25pdG9yaW5nIH0gZnJvbSBcIi4vRG93bmxvYWRzTW9uaXRvcmluZ1wiO1xyXG5cclxuY29uc3QgY29uZmlndXJhdGlvbk1hbmFnZXIgPSBuZXcgQ29uZmlndXJhdGlvbk1hbmFnZXIoKTtcclxuXHJcbmNvbnN0IHdhY0NvbW11bmljYXRpb24gPSBuZXcgV2FjQ29tbXVuaWNhdGlvbigpO1xyXG5jb25zdCB3YWNFdmVudFJlcG9ydGVyID0gbmV3IFdhY0V2ZW50UmVwb3J0ZXIod2FjQ29tbXVuaWNhdGlvbik7XHJcbmNvbnN0IGNvbW11bmljYXRpb24gPSBuZXcgQWdlbnRDb21tdW5pY2F0aW9uKHdhY0NvbW11bmljYXRpb24sIGNvbmZpZ3VyYXRpb25NYW5hZ2VyLCB3YWNDb21tdW5pY2F0aW9uLCB3YWNFdmVudFJlcG9ydGVyKTtcclxuY29uc3Qgd2ViTmF2aWdhdGlvbiA9IG5ldyBXZWJOYXZpZ2F0aW9uKCk7XHJcbmNvbnN0IHdlYlJlcXVlc3QgPSBuZXcgV2ViUmVxdWVzdCh3ZWJOYXZpZ2F0aW9uLndlYk5hdmlnYXRpb25UYWJzU3RhdGVzKTtcclxuY29uc3QgdGFic01vbml0b3JpbmcgPSBuZXcgVGFic01vbml0b3JpbmcoKTtcclxuY29uc3Qgd2luZG93c01vbml0b3JpbmcgPSBuZXcgV2luZG93c01vbml0b3JpbmcoKTtcclxuY29uc3QgaWRsZU1vbml0b3JpbmcgPSBuZXcgSWRsZU1vbml0b3JpbmcoKTtcclxuY29uc3QgaHRtbEV2ZW50c01vbml0b3JpbmcgPSBuZXcgSHRtbEV2ZW50c01vbml0b3JpbmcoKTtcclxuY29uc3QgZG93bmxvYWRzTW9uaXRvcmluZyA9IG5ldyBEb3dubG9hZHNNb25pdG9yaW5nKCk7XHJcblxyXG5leHBvcnQgY29uc3QgbWFuYWdlciA9IG5ldyBCYWNrZ3JvdW5kTWFuYWdlcihcclxuXHRjb21tdW5pY2F0aW9uLFxyXG5cdGNvbmZpZ3VyYXRpb25NYW5hZ2VyLFxyXG5cdHRhYnNNb25pdG9yaW5nLFxyXG5cdHdlYlJlcXVlc3QsXHJcblx0d2ViTmF2aWdhdGlvbixcclxuXHR3aW5kb3dzTW9uaXRvcmluZyxcclxuXHRpZGxlTW9uaXRvcmluZyxcclxuXHRodG1sRXZlbnRzTW9uaXRvcmluZyxcclxuXHR3YWNDb21tdW5pY2F0aW9uLFxyXG5cdGRvd25sb2Fkc01vbml0b3JpbmcpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xyXG5pbXBvcnQgKiBhcyBQYWtvIGZyb20gXCJwYWtvXCI7XHJcbmltcG9ydCAqIGFzIENvbnN0cyBmcm9tIFwiLi4vY29tbW9uL2NvbnN0c1wiO1xyXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IGlzU2VyaWFsaXphYmxlUHJpbWl0aXZlLCBzZXRJZk5vdEV4aXN0IH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XHJcbmltcG9ydCB7IGdldEZyYW1lVHlwZSB9IGZyb20gXCIuLi9jb21tb24vRnJhbWVUeXBlXCI7XHJcbmltcG9ydCB7IGdldE5hdGl2ZU1lc3NhZ2VPcmRlciB9IGZyb20gXCIuL01lc3NhZ2VPcmRlclwiO1xyXG5pbXBvcnQgKiBhcyBOYXRpdmVNZXNzYWdpbmcgZnJvbSBcIi4vTmF0aXZlTWVzc2FnaW5nXCI7XHJcbmltcG9ydCB7IEluY29taW5nQWN0aW9uLCBJbmNvbWluZ05hdGl2ZU1lc3NhZ2UsIE5hdGl2ZUNvbmZpZ3VyYXRpb25NZXNzYWdlIH0gZnJvbSBcIi4vTmF0aXZlTWVzc2FnaW5nXCI7XHJcbmltcG9ydCB7IElBZ2VudENvbW11bmljYXRpb24sIFBvc3ROYXRpdmVNZXNzYWdlT3B0aW9ucyB9IGZyb20gXCIuL0lBZ2VudENvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IHsgSUJhY2tncm91bmRNYW5hZ2VyQ29udHJvbGxlciB9IGZyb20gXCIuL0lCYWNrZ3JvdW5kTWFuYWdlckNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IHsgSVdlYk5hdmlnYXRpb24gfSBmcm9tIFwiLi9JV2ViTmF2aWdhdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdENPTlRFTlRfTUVTU0FHRVMsXHJcblx0TWVzc2FnZVR5cGUsXHJcblx0V1BNX1BBR0VfRVJST1JfVVgsXHJcblx0TlZfQ0hST01FX1dPUktUSU1FX1ZJT0xBVElPTixcclxuXHRPdXRnb2luZ0Jhc2VOYXRpdmVNZXNzYWdlLFxyXG5cdE91dGdvaW5nRXZlbnRNZXNzYWdlLFxyXG5cdE91dGdvaW5nRXZlbnRNZXNzYWdlRGF0YSxcclxuXHRPdXRnb2luZ0xvZ01lc3NhZ2UsXHJcblx0T3V0Z29pbmdQYWdlTmF0aXZlTWVzc2FnZVxyXG59IGZyb20gXCIuLi9jb21tb24vTWVzc2FnaW5nTW9kZWxcIjtcclxuXHJcbmltcG9ydCB7IFVYRGF0YSB9IGZyb20gXCIuLi9jb21tb24vVVhEYXRhXCI7XHJcbmltcG9ydCB7IENvbnRlbnRQYWdlSW5mb3JtYXRpb24gfSBmcm9tIFwiLi4vY29tbW9uL1BhZ2VJbmZvcm1hdGlvblwiO1xyXG5pbXBvcnQgeyBJV2FjTmF0aXZlQ29tbXVuaWNhdGlvbiB9IGZyb20gXCIuL0lXYWNOYXRpdmVDb21tdW5pY2F0aW9uXCI7XHJcbmltcG9ydCB7IENvbmZpZ3VyYXRpb25NYW5hZ2VyIH0gZnJvbSBcIi4vQ29uZmlndXJhdGlvbk1hbmFnZXJcIjtcclxuaW1wb3J0IHsgV2FjRXZlbnRSZXBvcnRlciB9IGZyb20gXCIuL1dhY0V2ZW50UmVwb3J0ZXJcIjtcclxuaW1wb3J0IE1lc3NhZ2VTZW5kZXIgPSBjaHJvbWUucnVudGltZS5NZXNzYWdlU2VuZGVyO1xyXG5pbXBvcnQgeyBXYWNDb21tdW5pY2F0aW9uIH0gZnJvbSBcIi4vV2FjQ29tbXVuaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBET1dOTE9BRFNfRVZFTlRfTkFNRVNQQUNFIH0gZnJvbSBcIi4vRG93bmxvYWRzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyBicm93c2VySW5mbyB9IGZyb20gXCIuLi91dGlscy9icm93c2VySW5mb1wiO1xyXG5pbXBvcnQgeyBCcm93c2VyVHlwZSB9IGZyb20gXCIuL1dhY0FQSVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFnZW50Q29tbXVuaWNhdGlvbiBpbXBsZW1lbnRzIElBZ2VudENvbW11bmljYXRpb24ge1xyXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgd2FjTmF0aXZlQ29tbXVuaWNhdGlvbjogSVdhY05hdGl2ZUNvbW11bmljYXRpb24sXHJcblx0XHRcdFx0cHJpdmF0ZSByZWFkb25seSBjb25maWd1cmF0aW9uTWFuYWdlcjogQ29uZmlndXJhdGlvbk1hbmFnZXIsXHJcblx0XHRcdFx0cHJpdmF0ZSByZWFkb25seSB3YWNDb21tdW5pY2F0aW9uOiBXYWNDb21tdW5pY2F0aW9uLFxyXG5cdFx0XHRcdHByaXZhdGUgcmVhZG9ubHkgd2FjRXZlbnRSZXBvcnRlcjogV2FjRXZlbnRSZXBvcnRlcikge1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBuYXRpdmVNZXNzYWdpbmdQb3J0PzogY2hyb21lLnJ1bnRpbWUuUG9ydDtcclxuXHRwcml2YXRlIGRpc2Nvbm5lY3RDYWxsYmFjaz86ICgoKSA9PiB2b2lkKTtcclxuXHJcblx0cHJpdmF0ZSBtYW5hZ2VyPzogSUJhY2tncm91bmRNYW5hZ2VyQ29udHJvbGxlcjtcclxuXHRwcml2YXRlIHdlYk5hdmlnYXRpb24/OiBJV2ViTmF2aWdhdGlvbjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgSE9TVF9OQU1FID0gXCJjb20uYXRlcm5pdHkuZnBpXCI7XHJcblxyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1hbnlcclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uTmF0aXZlTWVzc2FnZSA9IChtZXNzYWdlPzogYW55KSA9PiB7XHJcblx0XHRnZXRMb2dnZXIoKS5sb2coXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzXHJcblx0XHRpZiAobWVzc2FnZSA9PSBudWxsKSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiSW52YWxpZCByZXF1ZXN0LCBubyBwYXJhbWV0ZXJzXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGluY29taW5nTWVzc2FnZTogUGFydGlhbDxJbmNvbWluZ05hdGl2ZU1lc3NhZ2U+ID0ge307XHJcblx0XHRpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QsIG5vdCBvYmplY3QgdHlwZVwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aW5jb21pbmdNZXNzYWdlID0gbWVzc2FnZSBhcyBQYXJ0aWFsPEluY29taW5nTmF0aXZlTWVzc2FnZT47XHJcblx0XHRpZiAoaW5jb21pbmdNZXNzYWdlLnZlcnNpb24gIT09IE5hdGl2ZU1lc3NhZ2luZy5JTkNPTUlOR19WRVJTSU9OKSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiSW5jb21pbmcgbWVzc2FnZSB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWRcIiwgaW5jb21pbmdNZXNzYWdlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAoaW5jb21pbmdNZXNzYWdlLnR5cGUpIHtcclxuXHRcdFx0Y2FzZSBJbmNvbWluZ0FjdGlvbi5Db25maWd1cmF0aW9uOlxyXG5cdFx0XHRcdC8qIHRzbGludDpkaXNhYmxlIG5vLXVuc2FmZS1hbnkgKi9cclxuXHRcdFx0XHRjb25zdCBlbmNvZGVkID0gSlNPTi5wYXJzZSgoaW5jb21pbmdNZXNzYWdlIGFzIE5hdGl2ZUNvbmZpZ3VyYXRpb25NZXNzYWdlKS5kYXRhKS5Db25maWd1cmF0aW9uO1xyXG5cdFx0XHRcdGNvbnN0IGRlY29kZWQgPSBhdG9iKGVuY29kZWQpO1xyXG5cdFx0XHRcdC8vIFVuemlwIGRhdGFcclxuXHRcdFx0XHQvLyBSZVNoYXJwZXIgYnVnOiBUaGUgY2FzdCBpcyBtdXN0IHRvIGdldCBzdHJpbmcgcmV0dXJuIHR5cGUuXHJcblx0XHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLW9iamVjdC1saXRlcmFsLXR5cGUtYXNzZXJ0aW9uXHJcblx0XHRcdFx0Y29uc3QgdW56aXBwZWRKc29uID0gUGFrby5pbmZsYXRlKFV0aWxzLmJpbnN0cmluZzJCdWYoZGVjb2RlZCksIHt0bzogXCJzdHJpbmdcIn0gYXMgeyB0bzogXCJzdHJpbmdcIjsgfSk7XHJcblx0XHRcdFx0dGhpcy5jb25maWd1cmF0aW9uTWFuYWdlci5zZXRBZ2VudENvbmZpZ3VyYXRpb24odW56aXBwZWRKc29uKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBJbmNvbWluZ0FjdGlvbi5EZWFjdGl2YXRlOlxyXG5cdFx0XHRcdHRoaXMubWFuYWdlci5kZWFjdGl2YXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEluY29taW5nQWN0aW9uLldhY01lc3NhZ2U6XHJcblx0XHRcdFx0aWYgKG1lc3NhZ2UubWVzc2FnZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRnZXRMb2dnZXIoKS5sb2coXCJJbmNvbWluZyBXQUMgbWVzc2FnZSBoYXMgbnVsbCBkYXRhXCIsIGluY29taW5nTWVzc2FnZSk7XHJcblx0XHRcdFx0XHQvLyByZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgbWVzc2FnZS5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0XHRcdG1lc3NhZ2UubWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZS5tZXNzYWdlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMud2FjTmF0aXZlQ29tbXVuaWNhdGlvbi5pbmNvbWluZ01lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJVbnN1cHBvcnRlZCBtZXNzYWdlXCIsIG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKiBGb3J3YXJkIG1lc3NhZ2UgZnJvbSBjb250ZW50IHRvIG5hdGl2ZSAqL1xyXG5cclxuXHRcdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1hbnlcclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uUnVudGltZU1lc3NhZ2UgPSAobWVzc2FnZTogYW55LCBzZW5kZXI6IE1lc3NhZ2VTZW5kZXIsIHNlbmRSZXNwb25zZTogRnVuY3Rpb24pID0+IHtcclxuXHRcdGlmIChtZXNzYWdlLm1lc3NhZ2VUeXBlID09IG51bGwgfHwgQ09OVEVOVF9NRVNTQUdFUy5pbmRleE9mKG1lc3NhZ2UubWVzc2FnZVR5cGUpICE9PSAtMSkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIEVucmljaCBpdCB3aXRoIHRhYklkIGFuZCBmcmFtZUlkXHJcblx0XHRpZiAoc2VuZGVyICE9IG51bGwpIHtcclxuXHRcdFx0aWYgKHNlbmRlci50YWIgIT0gbnVsbCkge1xyXG5cdFx0XHRcdG1lc3NhZ2UudGFiSWQgPSBzZW5kZXIudGFiLmlkO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YgKHNlbmRlci5mcmFtZUlkKSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdG1lc3NhZ2UuZnJhbWVJZCA9IHNlbmRlci5mcmFtZUlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMudmFsaWRhdGVNZXNzYWdlU3RydWN0dXJlKG1lc3NhZ2UpKSB7XHJcblx0XHRcdHRoaXMucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIk1lc3NhZ2Ugc3RydWN0dXJlIGlzIG5vdCBhY2NvcmRpbmcgdG8gcHJvdG9jb2wuXCIsIG1lc3NhZ2UpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLWFueVxyXG5cdHB1YmxpYyB2YWxpZGF0ZU1lc3NhZ2VTdHJ1Y3R1cmUobWVzc2FnZTogYW55KTogbWVzc2FnZSBpcyBPdXRnb2luZ1BhZ2VOYXRpdmVNZXNzYWdlIHtcclxuXHRcdGlmICh0eXBlb2YgbWVzc2FnZS5tZXNzYWdlVHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlLnRpbWVTdGFtcCAhPT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbWVzc2FnZURhdGEgZWl0aGVyIGFic2VudCBvciBhcnJheVxyXG5cdFx0Ly8gU2VlIERhdGEuT3V0Z29pbmdFdmVudE1lc3NhZ2UgYW5kIERhdGEuT3V0Z29pbmdXcG1QYWdlTG9hZEV2ZW50TWVzc2FnZSBmb3IgaW5zdGFuY2UuXHJcblx0XHRjb25zdCBtZXNzYWdlRGF0YSA9IG1lc3NhZ2UubWVzc2FnZURhdGE7XHJcblx0XHRpZiAobWVzc2FnZURhdGEgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGE7XHJcblxyXG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1hbnlcclxuXHRcdFx0cmV0dXJuICFkYXRhLnNvbWUoKGQ6IGFueSkgPT4gIXRoaXMudmFsaWRhdGVNZXNzYWdlRGF0YVN0cnVjdHVyZShkKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55IG5vLXVuc2FmZS1hbnkgKi9cclxuXHRwcml2YXRlIHZhbGlkYXRlTWVzc2FnZURhdGFTdHJ1Y3R1cmUobWVzc2FnZURhdGE6IGFueSk6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4gbWVzc2FnZURhdGEpIHtcclxuXHRcdFx0aWYgKCFtZXNzYWdlRGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSBjb250aW51ZTtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBtZXNzYWdlRGF0YVtwcm9wZXJ0eU5hbWVdO1xyXG5cdFx0XHRpZiAoaXNTZXJpYWxpemFibGVQcmltaXRpdmUodmFsdWUpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tYW55XHJcblx0XHRcdFx0aWYgKHZhbHVlLnNvbWUoKGVsZW1lbnQ6IGFueSkgPT4gIWlzU2VyaWFsaXphYmxlUHJpbWl0aXZlKGVsZW1lbnQpKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgb25EaXNjb25uZWN0KHVuc3Vic2NyaWJlUnVudGltZU1lc3NhZ2U6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGdldExvZ2dlcigpLmluZm8oXCJOTUggZGlzY29ubmVjdGVkXCIpO1xyXG5cclxuXHRcdGlmICh1bnN1YnNjcmliZVJ1bnRpbWVNZXNzYWdlKSB7XHJcblx0XHRcdGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uUnVudGltZU1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKHRoaXMub25OYXRpdmVNZXNzYWdlKTtcclxuXHRcdFx0aWYgKHRoaXMuZGlzY29ubmVjdENhbGxiYWNrICE9IG51bGwpIHtcclxuXHRcdFx0XHR0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQub25EaXNjb25uZWN0LnJlbW92ZUxpc3RlbmVyKHRoaXMuZGlzY29ubmVjdENhbGxiYWNrKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGlzY29ubmVjdENhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5uYXRpdmVNZXNzYWdpbmdQb3J0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdC8vIFJlc2V0IGNvbmZpZ3VyYXRpb25cclxuXHRcdHRoaXMuY29uZmlndXJhdGlvbk1hbmFnZXIucmVzZXRDb25maWd1cmF0aW9uKCk7XHJcblxyXG5cdFx0Ly8gQXNrIHRoZSBtYW5hZ2VyIHRvIHRyeSB0byBjb25uZWN0IGFnYWluLi4uXHJcblx0XHRpZiAodGhpcy5tYW5hZ2VyICE9IG51bGwpIHtcclxuXHRcdFx0dGhpcy5tYW5hZ2VyLnNjaGVkdWxlQ29ubmVjdEF0dGVtcHQoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhcnQob25saW5lQ29uZmlndXJhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBjaHJvbWUucnVudGltZS5Qb3J0IHwgdW5kZWZpbmVkIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGxldCBwb3J0OiBjaHJvbWUucnVudGltZS5Qb3J0IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRpZiAob25saW5lQ29uZmlndXJhdGlvbikge1xyXG5cdFx0XHRcdGNvbnNvbGUudHJhY2UoXCJTdGFydGluZyBhbmQgY29ubmVjdGluZyBOTUhcIik7XHJcblx0XHRcdFx0cG9ydCA9IGNocm9tZS5ydW50aW1lLmNvbm5lY3ROYXRpdmUoQWdlbnRDb21tdW5pY2F0aW9uLkhPU1RfTkFNRSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uUnVudGltZU1lc3NhZ2UpO1xyXG5cdFx0XHRjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIodGhpcy5vblJ1bnRpbWVNZXNzYWdlKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmRpc2Nvbm5lY3RDYWxsYmFjayAhPSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMubmF0aXZlTWVzc2FnaW5nUG9ydCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQub25EaXNjb25uZWN0LnJlbW92ZUxpc3RlbmVyKHRoaXMuZGlzY29ubmVjdENhbGxiYWNrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvbmxpbmVDb25maWd1cmF0aW9uICYmIHBvcnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKHRoaXMub25OYXRpdmVNZXNzYWdlKTtcclxuXHJcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0Q2FsbGJhY2sgPSAoKSA9PiB0aGlzLm9uRGlzY29ubmVjdChvbmxpbmVDb25maWd1cmF0aW9uKTtcclxuXHRcdFx0XHRpZiAodGhpcy5kaXNjb25uZWN0Q2FsbGJhY2sgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cG9ydC5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIodGhpcy5kaXNjb25uZWN0Q2FsbGJhY2spO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5pbmZvKFwiQ29ubmVjdFwiKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IFwiQ29ubmVjdGVkIGV4dGVuc2lvbiB3aXRoIGlkIFwiICsgY2hyb21lLnJ1bnRpbWUuaWQ7XHJcblx0XHRcdFx0cG9ydC5wb3N0TWVzc2FnZShuZXcgT3V0Z29pbmdMb2dNZXNzYWdlKENvbnN0cy5Mb2dMZXZlbC5JTkZPLCBtZXNzYWdlKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwb3J0O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkNhbm5vdCBjb25uZWN0IHRvIG5hdGl2ZSBtZXNzYWdpbmcuIFBhZ2VzIGFyZSBub3QgbW9uaXRvcmVkLiBcIiwgZSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdG9wKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubmF0aXZlTWVzc2FnaW5nUG9ydCAhPSBudWxsKSB7XHJcblx0XHRcdGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uUnVudGltZU1lc3NhZ2UpO1xyXG5cclxuXHRcdFx0dGhpcy5uYXRpdmVNZXNzYWdpbmdQb3J0Lm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uTmF0aXZlTWVzc2FnZSk7XHJcblx0XHRcdGlmICh0aGlzLmRpc2Nvbm5lY3RDYWxsYmFjayAhPSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy5uYXRpdmVNZXNzYWdpbmdQb3J0Lm9uRGlzY29ubmVjdC5yZW1vdmVMaXN0ZW5lcih0aGlzLmRpc2Nvbm5lY3RDYWxsYmFjayk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZGlzY29ubmVjdENhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyB0b2RvOiBJZGVhLCBNb3ZlIHRvIGNsYXNzIFJlcG9ydGVyXHJcblx0LyoqXHJcblx0ICogUG9zdCBtZXNzYWdlIHRvIHRoZSBuYXRpdmUgbWVzc2FnaW5nIGhvc3QuXHJcblx0ICogV0FSTklORzogVGhpcyBwcml2YXRlIGNoYW5nZXMgdGhlIG9iamVjdC5cclxuXHQgKi9cclxuXHRwdWJsaWMgcG9zdE5hdGl2ZU1lc3NhZ2UoXHJcblx0XHRtZXNzYWdlOiBPdXRnb2luZ0Jhc2VOYXRpdmVNZXNzYWdlLFxyXG5cdFx0b3B0aW9uczogUG9zdE5hdGl2ZU1lc3NhZ2VPcHRpb25zID0ge2ZvcmNlUG9zdDogZmFsc2V9KTogdm9pZCB7XHJcblxyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtZXNzYWdlUHJvY2Vzc29yID0gdGhpcy5tYW5hZ2VyLmdldE1lc3NhZ2VQcm9jZXNzb3IoKTtcclxuXHRcdGlmIChtZXNzYWdlUHJvY2Vzc29yID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERvIG5vdCBzZW5kIG1lc3NhZ2VzIGlmIG5vdCBhY3RpdmF0ZWQuIExvZyBpcyBleGNlcHRpb24uXHJcblx0XHRpZiAoIXRoaXMubWFuYWdlci5hY3RpdmUgJiYgbWVzc2FnZS5tZXNzYWdlVHlwZSAhPT0gTWVzc2FnZVR5cGUuTE9HKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgZGF0YSBmb3IgZXZlbnQgbWVzc2FnZVxyXG5cdFx0aWYgKG1lc3NhZ2UubWVzc2FnZVR5cGUgPT09IE1lc3NhZ2VUeXBlLkVWRU5UKSB7XHJcblx0XHRcdGNvbnN0IG1lc3NhZ2VEYXRhID0gKG1lc3NhZ2UgYXMgT3V0Z29pbmdFdmVudE1lc3NhZ2U8VVhEYXRhPikubWVzc2FnZURhdGE7XHJcblx0XHRcdGlmIChtZXNzYWdlRGF0YSA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBOZWdhdGl2ZSB2YWx1ZSBtZXNzYWdlcyBhcmUgYWx3YXlzIHNlbnRcclxuXHRcdFx0aWYgKG1lc3NhZ2VEYXRhLkV2ZW50VHlwZSA9PT0gTlZfQ0hST01FX1dPUktUSU1FX1ZJT0xBVElPTikge1xyXG5cdFx0XHRcdG9wdGlvbnMuZm9yY2VQb3N0ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRG93bmxvYWRzIGV2ZW50cyBhcmUgb25seSByZXBvcnRlZCBpZiB0aGV5IGFyZSBjb25maWd1cmVkXHJcblx0XHRcdGlmIChVdGlscy5zdGFydHNXaXRoKG1lc3NhZ2VEYXRhLkV2ZW50VHlwZSwgRE9XTkxPQURTX0VWRU5UX05BTUVTUEFDRSkpIHtcclxuXHRcdFx0XHRvcHRpb25zLmZvcmNlUG9zdCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZpbHRlciBvdXQgdW5tb25pdG9yZWQgZXZlbnRzXHJcblx0XHRcdGlmICghb3B0aW9ucy5mb3JjZVBvc3QgJiYgIW1lc3NhZ2VQcm9jZXNzb3IuaXNFdmVudE1vbml0b3JlZChtZXNzYWdlRGF0YSkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEhhbmRsZSBvcHRpb25hbCBBcHBJbnRlcm5hbHMgaW5mb3JtYXRpb25cclxuXHRcdFx0Y29uc3QgcGFnZU1lc3NhZ2UgPSBtZXNzYWdlIGFzIFBhcnRpYWw8T3V0Z29pbmdQYWdlTmF0aXZlTWVzc2FnZT47XHJcblx0XHRcdGNvbnN0IHRhYklkID0gcGFnZU1lc3NhZ2UudGFiSWQgIT0gbnVsbCA/IHBhZ2VNZXNzYWdlLnRhYklkIDogKG1lc3NhZ2VEYXRhLkRhdGFbMF1bXCJ0YWJJZFwiXSBhcyBudW1iZXIpO1xyXG5cdFx0XHRjb25zdCBmcmFtZUlkID0gcGFnZU1lc3NhZ2UuZnJhbWVJZCAhPSBudWxsID8gcGFnZU1lc3NhZ2UuZnJhbWVJZCA6IChtZXNzYWdlRGF0YS5EYXRhWzBdW1wiZnJhbWVJZFwiXSBhcyBudW1iZXIpO1xyXG5cdFx0XHRpZiAodGFiSWQgIT0gbnVsbCAmJiBmcmFtZUlkICE9IG51bGwpIHtcclxuXHRcdFx0XHR0aGlzLmFkZFBhZ2VJbmZvcm1hdGlvblByb3BlcnRpZXModGFiSWQsIGZyYW1lSWQsIG1lc3NhZ2VEYXRhKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gV0FDIG1vZGVcclxuXHRcdFx0aWYgKHRoaXMud2FjRXZlbnRSZXBvcnRlci53YWNNb2RlKCkpIHtcclxuXHRcdFx0XHR0aGlzLndhY0V2ZW50UmVwb3J0ZXIucmVwb3J0VG9XYWMocGFnZU1lc3NhZ2UpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRqdXN0IHRoZSB0aW1lc3RhbXAgb2YgdGhlIFdQTSBwYWdlIGVycm9yIG1lc3NhZ2UsIHNpbmNlIGl0IGNhbiBiZSB0aW1lc3RhbXBlZCBlYXJsaWVyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY29tbWl0dGVkIGV2ZW50XHJcblx0XHRcdGlmIChtZXNzYWdlRGF0YS5FdmVudFR5cGUgPT09IFdQTV9QQUdFX0VSUk9SX1VYKSB7XHJcblx0XHRcdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKS52YWx1ZU9mKCk7XHJcblx0XHRcdFx0aWYgKG1lc3NhZ2UudGltZVN0YW1wIDwgbm93KSB7XHJcblx0XHRcdFx0XHRtZXNzYWdlLnRpbWVTdGFtcCA9IG5vdztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1lc3NhZ2VQcm9jZXNzb3IucHJvY2Vzc01lc3NhZ2VEYXRhKG1lc3NhZ2VEYXRhLCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5hZGRBZGRpdGlvbmFsRGF0YShtZXNzYWdlRGF0YSk7XHJcblx0XHRcdGdldExvZ2dlcigpLmxvZyhcIlNlbmRpbmcgZXZlbnQgdG8gbmF0aXZlXCIsIG1lc3NhZ2UudGltZVN0YW1wLCBtZXNzYWdlRGF0YSk7XHJcblx0XHR9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZVR5cGUgPT09IE1lc3NhZ2VUeXBlLldQTV9QQUdFTE9BRF9FVkVOVCB8fFxyXG5cdFx0XHRtZXNzYWdlLm1lc3NhZ2VUeXBlID09PSBNZXNzYWdlVHlwZS5XUE1fRVJST1JfRVZFTlQpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2VuZGluZyB3cG0gdG8gbmF0aXZlXCIsIG1lc3NhZ2UpO1xyXG5cdFx0fSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2VUeXBlID09PSBNZXNzYWdlVHlwZS5MT0cpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiTG9nZ2luZ1wiLCAobWVzc2FnZSBhcyBPdXRnb2luZ0xvZ01lc3NhZ2UpLm1lc3NhZ2UpO1xyXG5cdFx0fSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2VUeXBlID09PSBNZXNzYWdlVHlwZS5XQUNfVE9fSUUpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2VuZGluZyBXQUN0b0lFIHRvIG5hdGl2ZVwiLCBtZXNzYWdlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdldExvZ2dlcigpLndhcm4oXCJVbmtub3duIG1lc3NhZ2UgdHlwZVwiLCBtZXNzYWdlLm1lc3NhZ2VUeXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5uYXRpdmVNZXNzYWdpbmdQb3J0ICE9IG51bGwpIHtcclxuXHRcdFx0Ly8gU2V0IG9yZGVyIG9ubHkgaWYgd2Fzbid0IHNldCBtYW51YWxseVxyXG5cdFx0XHRpZiAodHlwZW9mIG1lc3NhZ2Uub3JkZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0XHRtZXNzYWdlLm9yZGVyID0gZ2V0TmF0aXZlTWVzc2FnZU9yZGVyKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5uYXRpdmVNZXNzYWdpbmdQb3J0LnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGluaXRDb21tdW5pY2F0aW9uKFxyXG5cdFx0bWFuYWdlcjogSUJhY2tncm91bmRNYW5hZ2VyQ29udHJvbGxlcixcclxuXHRcdHdlYk5hdmlnYXRpb246IElXZWJOYXZpZ2F0aW9uLFxyXG5cdFx0b25saW5lQ29uZmlndXJhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBib29sZWFuIHtcclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cdFx0dGhpcy53ZWJOYXZpZ2F0aW9uID0gd2ViTmF2aWdhdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5uYXRpdmVNZXNzYWdpbmdQb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y29uc29sZS50cmFjZShcIkV4aXN0aW5nIE5NSCBmb3VuZCwgZGlzY29ubmVjdGluZyBmcm9tIHByZXZpb3VzIE5NSC5cIik7XHJcblx0XHRcdHRoaXMubmF0aXZlTWVzc2FnaW5nUG9ydC5kaXNjb25uZWN0KCk7XHJcblx0XHRcdHRoaXMubmF0aXZlTWVzc2FnaW5nUG9ydCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQgPSB0aGlzLnN0YXJ0KG9ubGluZUNvbmZpZ3VyYXRpb24pO1xyXG5cdFx0dGhpcy5jb25maWd1cmF0aW9uTWFuYWdlci5pbml0Q29uZmlndXJhdGlvbk1hbmFnZXIodGhpcy5tYW5hZ2VyKTtcclxuXHRcdGlmICh0aGlzLndhY0NvbW11bmljYXRpb24uaXNCcm93c2VyQ2hyb21pdW1CYXNlZChicm93c2VySW5mby5uYW1lKSkgeyAvLyBzZWUgREUyMzQwOFxyXG5cdFx0XHR0aGlzLndhY0NvbW11bmljYXRpb24uYWN0aXZhdGUodGhpcywgdGhpcy5tYW5hZ2VyLmdldFRhYnNNb25pdG9yaW5nKCksIHRoaXMuY29uZmlndXJhdGlvbk1hbmFnZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwid2FjQ29tbXVuaWNhdGlvbiB3YXMgbm90IGFjdGl2YXRlZC4gQnJvd3NlciBuYW1lIGluIHVzZTogXCIsIGJyb3dzZXJJbmZvLm5hbWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm5hdGl2ZU1lc3NhZ2luZ1BvcnQgPT0gbnVsbCAmJiBvbmxpbmVDb25maWd1cmF0aW9uKSB7XHJcblx0XHRcdGNvbnNvbGUudHJhY2UoXCJGYWlsZWQgY29ubmVjdGluZyB0byBuYXRpdmUgbWVzc2FnaW5nIHBvcnRcIik7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmluZm8oXCJTdWNjZWVkZWQgY29ubmVjdGluZyB0byBuYXRpdmUgbWVzc2FnaW5nIHBvcnRcIik7XHJcblx0XHRcdGNvbnNvbGUudHJhY2UoXCJTdWNjZWVkZWQgY29ubmVjdGluZyB0byBuYXRpdmUgbWVzc2FnaW5nIHBvcnRcIik7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHVuaW5pdENvbW11bmljYXRpb24oKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0b3AoKTtcclxuXHRcdHRoaXMud2FjQ29tbXVuaWNhdGlvbi5kZWFjdGl2YXRlKCk7XHJcblx0fVxyXG5cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGFkZGl0aW9uYWwgZGF0YSB0byB0aGUgbWVzc2FnZSBsaWtlIGV4dGVuc2lvbiB2ZXJzaW9uIGFuZCBhbnkgb3RoZXIgaW5mb3JtYXRpb24uXHJcblx0ICogVGhpcyBzaG91bGQgbmV2ZXIgYmUgdHJpbW1lZCBzaW5jZSBpdCBpcyBlc3NlbnRpYWwuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBhZGRBZGRpdGlvbmFsRGF0YShtZXNzYWdlRGF0YTogT3V0Z29pbmdFdmVudE1lc3NhZ2VEYXRhPHt9Pik6IHZvaWQge1xyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZURhdGEuRGF0YVswXSBhcyB7IGV4dGVuc2lvblZlcnNpb246IHN0cmluZzsgfTtcclxuXHRcdGV2ZW50RGF0YS5leHRlbnNpb25WZXJzaW9uID0gQ29uc3RzLkVYVEVOU0lPTl9WRVJTSU9OLmdldFZhbHVlKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFkZFBhZ2VJbmZvcm1hdGlvblByb3BlcnRpZXMoXHJcblx0XHR0YWJJZDogbnVtYmVyLFxyXG5cdFx0ZnJhbWVJZDogbnVtYmVyLFxyXG5cdFx0bWVzc2FnZURhdGE6IE91dGdvaW5nRXZlbnRNZXNzYWdlRGF0YTxVWERhdGE+KTogdm9pZCB7XHJcblxyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsIHx8IHRoaXMud2ViTmF2aWdhdGlvbiA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YWJTdGF0ZSA9IHRoaXMubWFuYWdlci5nZXRUYWJzTW9uaXRvcmluZygpLmdldFRhYlN0YXRlKHRhYklkKTtcclxuXHRcdGNvbnN0IGZyYW1lU3RhdGUgPSBmcmFtZUlkID09PSAwID8gbnVsbCA6IHRoaXMud2ViTmF2aWdhdGlvbi5nZXRGcmFtZSh0YWJJZCwgZnJhbWVJZCk7XHJcblx0XHRjb25zdCBtYWluRnJhbWVTdGF0ZSA9IHRoaXMud2ViTmF2aWdhdGlvbi5nZXRGcmFtZSh0YWJJZCwgMCk7XHJcblxyXG5cdFx0Y29uc3QgZGF0YTogUGFydGlhbDxDb250ZW50UGFnZUluZm9ybWF0aW9uPiA9IG1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0Ly8gSWRzXHJcblx0XHRzZXRJZk5vdEV4aXN0KGRhdGEsIFwidGFiSWRcIiwgdGFiSWQpO1xyXG5cdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImZyYW1lSWRcIiwgZnJhbWVJZCk7XHJcblx0XHRzZXRJZk5vdEV4aXN0KGRhdGEsIFwidHlwZVwiLCBnZXRGcmFtZVR5cGUoZnJhbWVJZCkpO1xyXG5cclxuXHJcblx0XHQvLyBQcm9wZXJ0aWVzIGZyb20gbWFpbiBmcmFtZSBzdGF0ZVxyXG5cdFx0aWYgKG1haW5GcmFtZVN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImRvY3VtZW50VXJsXCIsIG1haW5GcmFtZVN0YXRlLnN0YXJ0VXJsKTtcclxuXHRcdFx0aWYgKG1haW5GcmFtZVN0YXRlLmNvbW1pdHRlZFVybCAhPSBudWxsKSB7XHJcblx0XHRcdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImRvY3VtZW50Q29tbWl0dGVkVXJsXCIsIG1haW5GcmFtZVN0YXRlLmNvbW1pdHRlZFVybCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChmcmFtZUlkID09PSAwKSB7XHJcblx0XHRcdFx0Ly8gRnJhbWUgcHJvcGVydGllc1xyXG5cdFx0XHRcdHNldElmTm90RXhpc3QoZGF0YSwgXCJmcmFtZVVybFwiLCBtYWluRnJhbWVTdGF0ZS5zdGFydFVybCk7XHJcblx0XHRcdFx0aWYgKG1haW5GcmFtZVN0YXRlLmNvbW1pdHRlZFVybCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRzZXRJZk5vdEV4aXN0KGRhdGEsIFwiZnJhbWVDb21taXR0ZWRVcmxcIiwgbWFpbkZyYW1lU3RhdGUuY29tbWl0dGVkVXJsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBQcm9wZXJ0aWVzIGZyb20gdGFiXHJcblx0XHRpZiAodGFiU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRzZXRJZk5vdEV4aXN0KGRhdGEsIFwiZG9jdW1lbnRUaXRsZVwiLCB0YWJTdGF0ZS50aXRsZSk7XHJcblx0XHRcdHNldElmTm90RXhpc3QoZGF0YSwgXCJkb2N1bWVudEN1cnJlbnRVcmxcIiwgdGFiU3RhdGUuY3VycmVudFVybCk7XHJcblxyXG5cdFx0XHRpZiAoZnJhbWVJZCA9PT0gMCkge1xyXG5cdFx0XHRcdC8vIENvbnRleHQgZGVwZW5kZW50IHByb3BlcnRpZXNcclxuXHRcdFx0XHRzZXRJZk5vdEV4aXN0KGRhdGEsIFwidGl0bGVcIiwgdGFiU3RhdGUudGl0bGUpO1xyXG5cclxuXHRcdFx0XHQvLyBGcmFtZSBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImZyYW1lVGl0bGVcIiwgdGFiU3RhdGUudGl0bGUpO1xyXG5cdFx0XHRcdHNldElmTm90RXhpc3QoZGF0YSwgXCJmcmFtZUN1cnJlbnRVcmxcIiwgdGFiU3RhdGUuY3VycmVudFVybCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBQcm9wZXJ0aWVzIGZyb20gZnJhbWUgc3RhdGUsIG9ubHkgYXBwbGljYWJsZSB0byBmcmFtZXNcclxuXHRcdGlmIChmcmFtZVN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImZyYW1lVXJsXCIsIGZyYW1lU3RhdGUuc3RhcnRVcmwpO1xyXG5cdFx0XHRpZiAoZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHNldElmTm90RXhpc3QoZGF0YSwgXCJmcmFtZUNvbW1pdHRlZFVybFwiLCBmcmFtZVN0YXRlLmNvbW1pdHRlZFVybCk7XHJcblx0XHRcdH1cclxuXHRcdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImZyYW1lQ3VycmVudFVybFwiLCBmcmFtZVN0YXRlLmN1cnJlbnRVcmwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCBkb2N1bWVudEN1cnJlbnRVcmwgaWYgd2Fzbid0IHNldFxyXG5cdFx0aWYgKG1haW5GcmFtZVN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0c2V0SWZOb3RFeGlzdChkYXRhLCBcImRvY3VtZW50Q3VycmVudFVybFwiLCBtYWluRnJhbWVTdGF0ZS5jdXJyZW50VXJsKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiXG4vKiEgcGFrbyAyLjAuMyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28gQGxpY2Vuc2UgKE1JVCBBTkQgWmxpYikgKi9cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL2NvbnN0IFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG5jb25zdCBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuY29uc3QgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG5jb25zdCBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIICAgID0gMztcbmNvbnN0IE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxuY29uc3QgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxuY29uc3QgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG5jb25zdCBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxuY29uc3Qgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbmNvbnN0IF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxuY29uc3QgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxuY29uc3QgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICBjb25zdCB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICBjb25zdCBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICBjb25zdCBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICBjb25zdCBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICBsZXQgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgbGV0IG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIGxldCB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICBsZXQgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICBsZXQgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5jb25zdCBnZW5fY29kZXMgPSAodHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KSA9PlxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICBjb25zdCBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgbGV0IGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGxldCBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5jb25zdCB0cl9zdGF0aWNfaW5pdCA9ICgpID0+IHtcblxuICBsZXQgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIGxldCBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIGxldCBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICBsZXQgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIGNvbnN0IGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmNvbnN0IGluaXRfYmxvY2sgPSAocykgPT4ge1xuXG4gIGxldCBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuY29uc3QgYmlfd2luZHVwID0gKHMpID0+XG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmNvbnN0IGNvcHlfYmxvY2sgPSAocywgYnVmLCBsZW4sIGhlYWRlcikgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHMucGVuZGluZ19idWYuc2V0KHMud2luZG93LnN1YmFycmF5KGJ1ZiwgYnVmICsgbGVuKSwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5jb25zdCBzbWFsbGVyID0gKHRyZWUsIG4sIG0sIGRlcHRoKSA9PiB7XG5cbiAgY29uc3QgX24yID0gbiAqIDI7XG4gIGNvbnN0IF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuY29uc3QgcHFkb3duaGVhcCA9IChzLCB0cmVlLCBrKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICBjb25zdCB2ID0gcy5oZWFwW2tdO1xuICBsZXQgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59O1xuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIGNvbnN0IFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuY29uc3QgY29tcHJlc3NfYmxvY2sgPSAocywgbHRyZWUsIGR0cmVlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIGxldCBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgbGV0IGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIGxldCBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICBsZXQgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIGNvbnN0IHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3Qgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgY29uc3QgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICBjb25zdCBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICBsZXQgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgbGV0IG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICBsZXQgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5jb25zdCBzZW5kX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIGxldCBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICBsZXQgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgbGV0IGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgbGV0IG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICBsZXQgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5jb25zdCBidWlsZF9ibF90cmVlID0gKHMpID0+IHtcblxuICBsZXQgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5jb25zdCBzZW5kX2FsbF90cmVlcyA9IChzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIGxldCByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmNvbnN0IGRldGVjdF9kYXRhX3R5cGUgPSAocykgPT4ge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIGxldCBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgbGV0IG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn07XG5cblxubGV0IHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmNvbnN0IF90cl9pbml0ID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5jb25zdCBfdHJfYWxpZ24gPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuY29uc3QgX3RyX2ZsdXNoX2Jsb2NrID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIGxldCBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIGxldCBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkgPSAocywgZGlzdCwgbGMpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy9sZXQgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59O1xuXG52YXIgX3RyX2luaXRfMSAgPSBfdHJfaW5pdDtcbnZhciBfdHJfc3RvcmVkX2Jsb2NrXzEgPSBfdHJfc3RvcmVkX2Jsb2NrO1xudmFyIF90cl9mbHVzaF9ibG9ja18xICA9IF90cl9mbHVzaF9ibG9jaztcbnZhciBfdHJfdGFsbHlfMSA9IF90cl90YWxseTtcbnZhciBfdHJfYWxpZ25fMSA9IF90cl9hbGlnbjtcblxudmFyIHRyZWVzID0ge1xuXHRfdHJfaW5pdDogX3RyX2luaXRfMSxcblx0X3RyX3N0b3JlZF9ibG9jazogX3RyX3N0b3JlZF9ibG9ja18xLFxuXHRfdHJfZmx1c2hfYmxvY2s6IF90cl9mbHVzaF9ibG9ja18xLFxuXHRfdHJfdGFsbHk6IF90cl90YWxseV8xLFxuXHRfdHJfYWxpZ246IF90cl9hbGlnbl8xXG59O1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBhZGxlcjMyID0gKGFkbGVyLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGxldCBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59O1xuXG5cbnZhciBhZGxlcjMyXzEgPSBhZGxlcjMyO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmNvbnN0IG1ha2VUYWJsZSA9ICgpID0+IHtcbiAgbGV0IGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59O1xuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxuY29uc3QgY3JjVGFibGUgPSBuZXcgVWludDMyQXJyYXkobWFrZVRhYmxlKCkpO1xuXG5cbmNvbnN0IGNyYzMyID0gKGNyYywgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBjb25zdCB0ID0gY3JjVGFibGU7XG4gIGNvbnN0IGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn07XG5cblxudmFyIGNyYzMyXzEgPSBjcmMzMjtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgbWVzc2FnZXMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciBjb25zdGFudHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgWl9NRU1fRVJST1I6ICAgICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IHsgX3RyX2luaXQ6IF90cl9pbml0JDEsIF90cl9zdG9yZWRfYmxvY2s6IF90cl9zdG9yZWRfYmxvY2skMSwgX3RyX2ZsdXNoX2Jsb2NrOiBfdHJfZmx1c2hfYmxvY2skMSwgX3RyX3RhbGx5OiBfdHJfdGFsbHkkMSwgX3RyX2FsaWduOiBfdHJfYWxpZ24kMSB9ID0gdHJlZXM7XG5cblxuXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0gsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNILCBaX0ZJTklTSCwgWl9CTE9DSyxcbiAgWl9PSywgWl9TVFJFQU1fRU5ELCBaX1NUUkVBTV9FUlJPUiwgWl9EQVRBX0VSUk9SLCBaX0JVRl9FUlJPUixcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICBaX0ZJTFRFUkVELCBaX0hVRkZNQU5fT05MWSwgWl9STEUsIFpfRklYRUQ6IFpfRklYRUQkMSwgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX1VOS05PV046IFpfVU5LTk9XTiQxLFxuICBaX0RFRkxBVEVEXG59ID0gY29uc3RhbnRzO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmNvbnN0IE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX01FTV9MRVZFTCA9IDg7XG5cblxuY29uc3QgTEVOR1RIX0NPREVTJDEgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbmNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuY29uc3QgTF9DT0RFUyQxICAgICAgID0gTElURVJBTFMkMSArIDEgKyBMRU5HVEhfQ09ERVMkMTtcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuY29uc3QgRF9DT0RFUyQxICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbmNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5jb25zdCBIRUFQX1NJWkUkMSAgICAgPSAyICogTF9DT0RFUyQxICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5jb25zdCBNQVhfQklUUyQxICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IE1JTl9NQVRDSCQxID0gMztcbmNvbnN0IE1BWF9NQVRDSCQxID0gMjU4O1xuY29uc3QgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0gkMSArIE1JTl9NQVRDSCQxICsgMSk7XG5cbmNvbnN0IFBSRVNFVF9ESUNUID0gMHgyMDtcblxuY29uc3QgSU5JVF9TVEFURSA9IDQyO1xuY29uc3QgRVhUUkFfU1RBVEUgPSA2OTtcbmNvbnN0IE5BTUVfU1RBVEUgPSA3MztcbmNvbnN0IENPTU1FTlRfU1RBVEUgPSA5MTtcbmNvbnN0IEhDUkNfU1RBVEUgPSAxMDM7XG5jb25zdCBCVVNZX1NUQVRFID0gMTEzO1xuY29uc3QgRklOSVNIX1NUQVRFID0gNjY2O1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn07XG5cbmNvbnN0IHplcm8kMSA9IChidWYpID0+IHtcbiAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfVxufTtcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5sZXQgSEFTSF9aTElCID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCBzLmhhc2hfc2hpZnQpIF4gZGF0YSkgJiBzLmhhc2hfbWFzaztcbi8vIFRoaXMgaGFzaCBjYXVzZXMgbGVzcyBjb2xsaXNpb25zLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vaXNzdWVzLzEzNVxuLy8gQnV0IGJyZWFrcyBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy9sZXQgSEFTSF9GQVNUID0gKHMsIHByZXYsIGRhdGEpID0+ICgocHJldiA8PCA4KSArIChwcmV2ID4+IDgpICsgKGRhdGEgPDwgNCkpICYgcy5oYXNoX21hc2s7XG5sZXQgSEFTSCA9IEhBU0hfWkxJQjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuY29uc3QgZmx1c2hfcGVuZGluZyA9IChzdHJtKSA9PiB7XG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIGxldCBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgc3RybS5vdXRwdXQuc2V0KHMucGVuZGluZ19idWYuc3ViYXJyYXkocy5wZW5kaW5nX291dCwgcy5wZW5kaW5nX291dCArIGxlbiksIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn07XG5cblxuY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7XG4gIF90cl9mbHVzaF9ibG9jayQxKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59O1xuXG5cbmNvbnN0IHB1dF9ieXRlID0gKHMsIGIpID0+IHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IHB1dFNob3J0TVNCID0gKHMsIGIpID0+IHtcblxuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuY29uc3QgcmVhZF9idWYgPSAoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgPT4ge1xuXG4gIGxldCBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICBidWYuc2V0KHN0cm0uaW5wdXQuc3ViYXJyYXkoc3RybS5uZXh0X2luLCBzdHJtLm5leHRfaW4gKyBsZW4pLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5jb25zdCBsb25nZXN0X21hdGNoID0gKHMsIGN1cl9tYXRjaCkgPT4ge1xuXG4gIGxldCBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIGxldCBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgbGV0IG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICBsZXQgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIGxldCBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIGNvbnN0IGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIGNvbnN0IHdtYXNrID0gcy53X21hc2s7XG4gIGNvbnN0IHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIGNvbnN0IHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0gkMTtcbiAgbGV0IHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICBsZXQgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCQxIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0gkMTtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmNvbnN0IGZpbGxfd2luZG93ID0gKHMpID0+IHtcblxuICBjb25zdCBfd19zaXplID0gcy53X3NpemU7XG4gIGxldCBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShfd19zaXplLCBfd19zaXplICsgX3dfc2l6ZSksIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCQxIC0gMV0pO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIJDEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICBjb25zdCBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgbGV0IGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBkZWZsYXRlX3N0b3JlZCA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgbGV0IG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICBjb25zdCBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuY29uc3QgZGVmbGF0ZV9mYXN0ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCQxKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIJDEpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIJDEpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseSQxKHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIJDEgLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIJDEgLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5jb25zdCBkZWZsYXRlX3Nsb3cgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGxldCBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0gkMSAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gkMSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIJDEgJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSCQxO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseSQxKHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIJDEpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCQxIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIJDEgLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0gkMSAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIJDEgLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5jb25zdCBkZWZsYXRlX3JsZSA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIGxldCBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgbGV0IHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIJDEpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCQxICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIJDEgJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0gkMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCQxIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCQxKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5JDEocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkkMShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcblxuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxuY29uc3QgY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5jb25zdCBsbV9pbml0ID0gKHMpID0+IHtcblxuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvJDEocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn07XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFJDEgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KCgyICogRF9DT0RFUyQxICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IFVpbnQxNkFycmF5KCgyICogQkxfQ09ERVMkMSArIDEpICogMik7XG4gIHplcm8kMSh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8kMSh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8kMSh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTJDEgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyQxICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyQxKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyQxICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyQxKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmNvbnN0IGRlZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV04kMTtcblxuICBjb25zdCBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICBfdHJfaW5pdCQxKHMpO1xuICByZXR1cm4gWl9PSztcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBjb25zdCByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVJbml0MiA9IChzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCQxKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIGNvbnN0IHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCQxIC0gMSkgLyBNSU5fTUFUQ0gkMSk7XG5cbiAgcy53aW5kb3cgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgVWludDE2QXJyYXkocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgVWludDE2QXJyYXkocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufTtcblxuY29uc3QgZGVmbGF0ZUluaXQgPSAoc3RybSwgbGV2ZWwpID0+IHtcblxuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGUgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBsZXQgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgY29uc3Qgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgbGV0IGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgbGV0IGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIGxldCBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIF90cl9hbGlnbiQxKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyQxKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplcyB0aGUgY29tcHJlc3Npb24gZGljdGlvbmFyeSBmcm9tIHRoZSBnaXZlbiBieXRlXG4gKiBzZXF1ZW5jZSB3aXRob3V0IHByb2R1Y2luZyBhbnkgY29tcHJlc3NlZCBvdXRwdXQuXG4gKi9cbmNvbnN0IGRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gKHN0cm0sIGRpY3Rpb25hcnkpID0+IHtcblxuICBsZXQgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGNvbnN0IHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvJDEocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgbGV0IHRtcERpY3QgPSBuZXcgVWludDhBcnJheShzLndfc2l6ZSk7XG4gICAgdG1wRGljdC5zZXQoZGljdGlvbmFyeS5zdWJhcnJheShkaWN0TGVuZ3RoIC0gcy53X3NpemUsIGRpY3RMZW5ndGgpLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgY29uc3QgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBjb25zdCBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBjb25zdCBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gkMSkge1xuICAgIGxldCBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIGxldCBuID0gcy5sb29rYWhlYWQgLSAoTUlOX01BVENIJDEgLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gkMSAtIDFdKTtcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIJDEgLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCQxIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0s7XG59O1xuXG5cbnZhciBkZWZsYXRlSW5pdF8xID0gZGVmbGF0ZUluaXQ7XG52YXIgZGVmbGF0ZUluaXQyXzEgPSBkZWZsYXRlSW5pdDI7XG52YXIgZGVmbGF0ZVJlc2V0XzEgPSBkZWZsYXRlUmVzZXQ7XG52YXIgZGVmbGF0ZVJlc2V0S2VlcF8xID0gZGVmbGF0ZVJlc2V0S2VlcDtcbnZhciBkZWZsYXRlU2V0SGVhZGVyXzEgPSBkZWZsYXRlU2V0SGVhZGVyO1xudmFyIGRlZmxhdGVfMiA9IGRlZmxhdGU7XG52YXIgZGVmbGF0ZUVuZF8xID0gZGVmbGF0ZUVuZDtcbnZhciBkZWZsYXRlU2V0RGljdGlvbmFyeV8xID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuXG52YXIgZGVmbGF0ZV8xID0ge1xuXHRkZWZsYXRlSW5pdDogZGVmbGF0ZUluaXRfMSxcblx0ZGVmbGF0ZUluaXQyOiBkZWZsYXRlSW5pdDJfMSxcblx0ZGVmbGF0ZVJlc2V0OiBkZWZsYXRlUmVzZXRfMSxcblx0ZGVmbGF0ZVJlc2V0S2VlcDogZGVmbGF0ZVJlc2V0S2VlcF8xLFxuXHRkZWZsYXRlU2V0SGVhZGVyOiBkZWZsYXRlU2V0SGVhZGVyXzEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMixcblx0ZGVmbGF0ZUVuZDogZGVmbGF0ZUVuZF8xLFxuXHRkZWZsYXRlU2V0RGljdGlvbmFyeTogZGVmbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0ZGVmbGF0ZUluZm86IGRlZmxhdGVJbmZvXG59O1xuXG5jb25zdCBfaGFzID0gKG9iaiwga2V5KSA9PiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbnZhciBmbGF0dGVuQ2h1bmtzID0gKGNodW5rcykgPT4ge1xuICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgbGV0IGxlbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gIH1cblxuICAvLyBqb2luIGNodW5rc1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNvbW1vbiA9IHtcblx0YXNzaWduOiBhc3NpZ24sXG5cdGZsYXR0ZW5DaHVua3M6IGZsYXR0ZW5DaHVua3Ncbn07XG5cbi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG5sZXQgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbmNvbnN0IF91dGY4bGVuID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAobGV0IHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IChzdHIpID0+IHtcbiAgbGV0IGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXJcbmNvbnN0IGJ1ZjJiaW5zdHJpbmcgPSAoYnVmLCBsZW4pID0+IHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zi5sZW5ndGggPT09IGxlbiA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG52YXIgYnVmMnN0cmluZyA9IChidWYsIG1heCkgPT4ge1xuICBsZXQgaSwgb3V0O1xuICBjb25zdCBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICBjb25zdCB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgbGV0IGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbnZhciBzdHJpbmdzID0ge1xuXHRzdHJpbmcyYnVmOiBzdHJpbmcyYnVmLFxuXHRidWYyc3RyaW5nOiBidWYyc3RyaW5nLFxuXHR1dGY4Ym9yZGVyOiB1dGY4Ym9yZGVyXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbnZhciB6c3RyZWFtID0gWlN0cmVhbTtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDEsIFpfU1lOQ19GTFVTSCwgWl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gkMSwgWl9GSU5JU0g6IFpfRklOSVNIJDEsXG4gIFpfT0s6IFpfT0skMSwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1kkMSxcbiAgWl9ERUZMQVRFRDogWl9ERUZMQVRFRCQxXG59ID0gY29uc3RhbnRzO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSxcbiAgICBtZXRob2Q6IFpfREVGTEFURUQkMSxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1kkMVxuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICBsZXQgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgPSBkZWZsYXRlXzEuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSyQxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICBkZWZsYXRlXzEuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgbGV0IGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSyQxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdFxuICogaGF2ZSBgZmx1c2hfbW9kZWAgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nXG4gKiBidWZmZXJzIGFuZCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIJDEgOiBaX05PX0ZMVVNIJDE7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXZhaWxfb3V0ID4gNiB0byBhdm9pZCByZXBlYXRpbmcgbWFya2Vyc1xuICAgIGlmICgoX2ZsdXNoX21vZGUgPT09IFpfU1lOQ19GTFVTSCB8fCBfZmx1c2hfbW9kZSA9PT0gWl9GVUxMX0ZMVVNIJDEpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcblxuICAgIC8vIEVuZGVkID0+IGZsdXNoIGFuZCBmaW5pc2hcbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMSkge1xuICAgICAgaWYgKHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cyA9IGRlZmxhdGVfMS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0skMTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiBvdXQgYnVmZmVyIGZ1bGxcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIHJlcXVlc3RlZCBhbmQgaGFzIGRhdGFcbiAgICBpZiAoX2ZsdXNoX21vZGUgPiAwICYmIHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheSk6IG91dHB1dCBkYXRhLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSyQxKSB7XG4gICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheVxuICogLSBkYXRhIChVaW50OEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxudmFyIERlZmxhdGVfMSA9IERlZmxhdGU7XG52YXIgZGVmbGF0ZV8yJDEgPSBkZWZsYXRlJDE7XG52YXIgZGVmbGF0ZVJhd18xID0gZGVmbGF0ZVJhdztcbnZhciBnemlwXzEgPSBnemlwO1xudmFyIGNvbnN0YW50cyQxID0gY29uc3RhbnRzO1xuXG52YXIgZGVmbGF0ZV8xJDEgPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8yJDEsXG5cdGRlZmxhdGVSYXc6IGRlZmxhdGVSYXdfMSxcblx0Z3ppcDogZ3ppcF8xLFxuXHRjb25zdGFudHM6IGNvbnN0YW50cyQxXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0IFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbnZhciBpbmZmYXN0ID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIGxldCBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIGxldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgbGV0IF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGxldCBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIGxldCB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgbGV0IHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgbGV0IHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICBsZXQgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICBsZXQgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIGxldCBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIGxldCBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgbGV0IGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIGxldCBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgbGV0IG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIGxldCBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcblxuXG4gIGxldCBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgTUFYQklUUyA9IDE1O1xuY29uc3QgRU5PVUdIX0xFTlMgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXSk7XG5cbmNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXSk7XG5cbmNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXSk7XG5cbmNvbnN0IGRleHQgPSBuZXcgVWludDhBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXSk7XG5cbmNvbnN0IGluZmxhdGVfdGFibGUgPSAodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgPT5cbntcbiAgY29uc3QgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgbGV0IGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIGxldCBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICBsZXQgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICBsZXQgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIGxldCBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgbGV0IGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIGxldCBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIGxldCBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICBsZXQgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIGxldCBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIGxldCBiYXNlX2luZGV4ID0gMDtcbi8vICBsZXQgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICBjb25zdCBjb3VudCA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICBjb25zdCBvZmZzID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIGxldCBleHRyYSA9IG51bGw7XG4gIGxldCBleHRyYV9pbmRleCA9IDA7XG5cbiAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbnZhciBpbmZ0cmVlcyA9IGluZmxhdGVfdGFibGU7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuXG5cblxuXG5cbmNvbnN0IENPREVTJDEgPSAwO1xuY29uc3QgTEVOUyQxID0gMTtcbmNvbnN0IERJU1RTJDEgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX0ZJTklTSDogWl9GSU5JU0gkMiwgWl9CTE9DSzogWl9CTE9DSyQxLCBaX1RSRUVTLFxuICBaX09LOiBaX09LJDIsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDIsIFpfTkVFRF9ESUNULCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMSwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMSwgWl9NRU1fRVJST1IsIFpfQlVGX0VSUk9SOiBaX0JVRl9FUlJPUiQxLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDJcbn0gPSBjb25zdGFudHM7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuY29uc3QgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG5jb25zdCAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG5jb25zdCAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xuY29uc3QgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG5jb25zdCAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbmNvbnN0ICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG5jb25zdCAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG5jb25zdCAgICAgICAgVFlQRSQxID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQkMSA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbmNvbnN0IEVOT1VHSF9MRU5TJDEgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMkMSA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMkMSA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfV0JJVFMgPSBNQVhfV0JJVFMkMTtcblxuXG5jb25zdCB6c3dhcDMyID0gKHEpID0+IHtcblxuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn07XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IFVpbnQxNkFycmF5KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0xFTlMkMSk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9ESVNUUyQxKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIGNvbnN0IHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0skMikge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdCA9IChzdHJtKSA9PiB7XG5cbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufTtcblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG5sZXQgdmlyZ2luID0gdHJ1ZTtcblxubGV0IGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuXG5jb25zdCBmaXhlZHRhYmxlcyA9IChzdGF0ZSkgPT4ge1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICBsZW5maXggPSBuZXcgSW50MzJBcnJheSg1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgSW50MzJBcnJheSgzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIGxldCBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZ0cmVlcyhMRU5TJDEsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mdHJlZXMoRElTVFMkMSwgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn07XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmNvbnN0IHVwZGF0ZXdpbmRvdyA9IChzdHJtLCBzcmMsIGVuZCwgY29weSkgPT4ge1xuXG4gIGxldCBkaXN0O1xuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgVWludDhBcnJheShzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBzdGF0ZS53c2l6ZSwgZW5kKSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCAtIGNvcHkgKyBkaXN0KSwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kKSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgaW5mbGF0ZSA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSQxKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0skMjtcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEJDIpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAhISEgcGFrbyBwYXRjaC4gRm9yY2UgdXNlIGBvcHRpb25zLndpbmRvd0JpdHNgIGlmIHBhc3NlZC5cbiAgICAgICAgLy8gUmVxdWlyZWQgdG8gYWx3YXlzIHVzZSBtYXggd2luZG93IHNpemUgYnkgZGVmYXVsdC5cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgICAgIC8vc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEUkMTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEJDIpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYS5zZXQoXG4gICAgICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICAgIG5leHQgKyBjb3B5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFJDE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRSQxOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0skMSB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhDT0RFUyQxLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQkMSkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKExFTlMkMSwgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKERJU1RTJDEsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSQxKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EJDI7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEJDE6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEJDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQyKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSQxID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIJDIpICYmIHJldCA9PT0gWl9PSyQyKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1IkMTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlRW5kID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LJDI7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuICBjb25zdCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgZGljdGlkO1xuICBsZXQgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMl8xKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1IkMTtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMjtcbn07XG5cblxudmFyIGluZmxhdGVSZXNldF8xID0gaW5mbGF0ZVJlc2V0O1xudmFyIGluZmxhdGVSZXNldDJfMSA9IGluZmxhdGVSZXNldDI7XG52YXIgaW5mbGF0ZVJlc2V0S2VlcF8xID0gaW5mbGF0ZVJlc2V0S2VlcDtcbnZhciBpbmZsYXRlSW5pdF8xID0gaW5mbGF0ZUluaXQ7XG52YXIgaW5mbGF0ZUluaXQyXzEgPSBpbmZsYXRlSW5pdDI7XG52YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZTtcbnZhciBpbmZsYXRlRW5kXzEgPSBpbmZsYXRlRW5kO1xudmFyIGluZmxhdGVHZXRIZWFkZXJfMSA9IGluZmxhdGVHZXRIZWFkZXI7XG52YXIgaW5mbGF0ZVNldERpY3Rpb25hcnlfMSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xudmFyIGluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cblxudmFyIGluZmxhdGVfMSA9IHtcblx0aW5mbGF0ZVJlc2V0OiBpbmZsYXRlUmVzZXRfMSxcblx0aW5mbGF0ZVJlc2V0MjogaW5mbGF0ZVJlc2V0Ml8xLFxuXHRpbmZsYXRlUmVzZXRLZWVwOiBpbmZsYXRlUmVzZXRLZWVwXzEsXG5cdGluZmxhdGVJbml0OiBpbmZsYXRlSW5pdF8xLFxuXHRpbmZsYXRlSW5pdDI6IGluZmxhdGVJbml0Ml8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIsXG5cdGluZmxhdGVFbmQ6IGluZmxhdGVFbmRfMSxcblx0aW5mbGF0ZUdldEhlYWRlcjogaW5mbGF0ZUdldEhlYWRlcl8xLFxuXHRpbmZsYXRlU2V0RGljdGlvbmFyeTogaW5mbGF0ZVNldERpY3Rpb25hcnlfMSxcblx0aW5mbGF0ZUluZm86IGluZmxhdGVJbmZvXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG52YXIgZ3poZWFkZXIgPSBHWmhlYWRlcjtcblxuY29uc3QgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMiwgWl9GSU5JU0g6IFpfRklOSVNIJDMsXG4gIFpfT0s6IFpfT0skMywgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMywgWl9ORUVEX0RJQ1Q6IFpfTkVFRF9ESUNUJDEsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQyLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQyLCBaX01FTV9FUlJPUjogWl9NRU1fRVJST1IkMVxufSA9IGNvbnN0YW50cztcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogY29uc3QgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqIGNvbnN0IGNodW5rMiA9IG5ldyBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIGNvbnN0IGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxMDI0ICogNjQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgID0gaW5mbGF0ZV8xLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LJDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpO1xuXG4gIGluZmxhdGVfMS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gWl9PSyQzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUVcbiAqICAgZmx1c2ggbW9kZXMuIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILFxuICogICBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBJZiBlbmQgb2Ygc3RyZWFtIGRldGVjdGVkLFxuICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuXG4gKlxuICogYGZsdXNoX21vZGVgIGlzIG5vdCBuZWVkZWQgZm9yIG5vcm1hbCBvcGVyYXRpb24sIGJlY2F1c2UgZW5kIG9mIHN0cmVhbVxuICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dFxuICogdGhpcyBmdW5jdGlvbmFsaXR5IHdhcyBub3QgdGVzdGVkLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgY29uc3QgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZSwgbGFzdF9hdmFpbF9vdXQ7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHJldHVybiBmYWxzZTtcblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0gkMyA6IFpfTk9fRkxVU0gkMjtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0b1N0cmluZyQxLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBpbmZsYXRlXzEuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICBpZiAoc3RhdHVzID09PSBaX05FRURfRElDVCQxICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KTtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gWl9PSyQzKSB7XG4gICAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBaX0RBVEFfRVJST1IkMikge1xuICAgICAgICAvLyBSZXBsYWNlIGNvZGUgd2l0aCBtb3JlIHZlcmJvc2VcbiAgICAgICAgc3RhdHVzID0gWl9ORUVEX0RJQ1QkMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlXG4gICAgd2hpbGUgKHN0cm0uYXZhaWxfaW4gPiAwICYmXG4gICAgICAgICAgIHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EJDMgJiZcbiAgICAgICAgICAgc3RybS5zdGF0ZS53cmFwID4gMCAmJlxuICAgICAgICAgICBkYXRhW3N0cm0ubmV4dF9pbl0gIT09IDApXG4gICAge1xuICAgICAgaW5mbGF0ZV8xLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlKHN0cm0sIF9mbHVzaF9tb2RlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBaX1NUUkVBTV9FUlJPUiQyOlxuICAgICAgY2FzZSBaX0RBVEFfRVJST1IkMjpcbiAgICAgIGNhc2UgWl9ORUVEX0RJQ1QkMTpcbiAgICAgIGNhc2UgWl9NRU1fRVJST1IkMTpcbiAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHJlYWwgYGF2YWlsX291dGAgdmFsdWUsIGJlY2F1c2Ugd2UgbWF5IHBhdGNoIG91dCBidWZmZXIgY29udGVudFxuICAgIC8vIHRvIGFsaWduIHV0Zjggc3RyaW5ncyBib3VuZGFyaWVzLlxuICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EJDMpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbGV0IG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgbGV0IHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICBsZXQgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWwgJiByZWFsaWduIGNvdW50ZXJzXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSBzdHJtLm91dHB1dC5zZXQoc3RybS5vdXRwdXQuc3ViYXJyYXkobmV4dF9vdXRfdXRmOCwgbmV4dF9vdXRfdXRmOCArIHRhaWwpLCAwKTtcblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQubGVuZ3RoID09PSBzdHJtLm5leHRfb3V0ID8gc3RybS5vdXRwdXQgOiBzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNdXN0IHJlcGVhdCBpdGVyYXRpb24gaWYgb3V0IGJ1ZmZlciBpcyBmdWxsXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9PSyQzICYmIGxhc3RfYXZhaWxfb3V0ID09PSAwKSBjb250aW51ZTtcblxuICAgIC8vIEZpbmFsaXplIGlmIGVuZCBvZiBzdHJlYW0gcmVhY2hlZC5cbiAgICBpZiAoc3RhdHVzID09PSBaX1NUUkVBTV9FTkQkMykge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGVhY2ggY2h1bmsgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0skMykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XG4gKiBjb25zdCBpbnB1dCA9IHBha28uZGVmbGF0ZShuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKSk7XG4gKiBsZXQgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHRocm93IGluZmxhdG9yLm1zZyB8fCBtZXNzYWdlc1tpbmZsYXRvci5lcnJdO1xuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbnZhciBJbmZsYXRlXzEgPSBJbmZsYXRlO1xudmFyIGluZmxhdGVfMiQxID0gaW5mbGF0ZSQxO1xudmFyIGluZmxhdGVSYXdfMSA9IGluZmxhdGVSYXc7XG52YXIgdW5nemlwID0gaW5mbGF0ZSQxO1xudmFyIGNvbnN0YW50cyQyID0gY29uc3RhbnRzO1xuXG52YXIgaW5mbGF0ZV8xJDEgPSB7XG5cdEluZmxhdGU6IEluZmxhdGVfMSxcblx0aW5mbGF0ZTogaW5mbGF0ZV8yJDEsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSxcblx0dW5nemlwOiB1bmd6aXAsXG5cdGNvbnN0YW50czogY29uc3RhbnRzJDJcbn07XG5cbmNvbnN0IHsgRGVmbGF0ZTogRGVmbGF0ZSQxLCBkZWZsYXRlOiBkZWZsYXRlJDIsIGRlZmxhdGVSYXc6IGRlZmxhdGVSYXckMSwgZ3ppcDogZ3ppcCQxIH0gPSBkZWZsYXRlXzEkMTtcblxuY29uc3QgeyBJbmZsYXRlOiBJbmZsYXRlJDEsIGluZmxhdGU6IGluZmxhdGUkMiwgaW5mbGF0ZVJhdzogaW5mbGF0ZVJhdyQxLCB1bmd6aXA6IHVuZ3ppcCQxIH0gPSBpbmZsYXRlXzEkMTtcblxuXG5cbnZhciBEZWZsYXRlXzEkMSA9IERlZmxhdGUkMTtcbnZhciBkZWZsYXRlXzEkMiA9IGRlZmxhdGUkMjtcbnZhciBkZWZsYXRlUmF3XzEkMSA9IGRlZmxhdGVSYXckMTtcbnZhciBnemlwXzEkMSA9IGd6aXAkMTtcbnZhciBJbmZsYXRlXzEkMSA9IEluZmxhdGUkMTtcbnZhciBpbmZsYXRlXzEkMiA9IGluZmxhdGUkMjtcbnZhciBpbmZsYXRlUmF3XzEkMSA9IGluZmxhdGVSYXckMTtcbnZhciB1bmd6aXBfMSA9IHVuZ3ppcCQxO1xudmFyIGNvbnN0YW50c18xID0gY29uc3RhbnRzO1xuXG52YXIgcGFrbyA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xJDEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMSQyLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3XzEkMSxcblx0Z3ppcDogZ3ppcF8xJDEsXG5cdEluZmxhdGU6IEluZmxhdGVfMSQxLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzEkMixcblx0aW5mbGF0ZVJhdzogaW5mbGF0ZVJhd18xJDEsXG5cdHVuZ3ppcDogdW5nemlwXzEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzXzFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBha287XG5leHBvcnQgeyBEZWZsYXRlXzEkMSBhcyBEZWZsYXRlLCBJbmZsYXRlXzEkMSBhcyBJbmZsYXRlLCBjb25zdGFudHNfMSBhcyBjb25zdGFudHMsIGRlZmxhdGVfMSQyIGFzIGRlZmxhdGUsIGRlZmxhdGVSYXdfMSQxIGFzIGRlZmxhdGVSYXcsIGd6aXBfMSQxIGFzIGd6aXAsIGluZmxhdGVfMSQyIGFzIGluZmxhdGUsIGluZmxhdGVSYXdfMSQxIGFzIGluZmxhdGVSYXcsIHVuZ3ppcF8xIGFzIHVuZ3ppcCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IGVuYWJsZUxvZ3MgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCAqIGFzIEV2ZW50TmFtZXMgZnJvbSBcIi4uL0h0bWxNb25pdG9yaW5nL0V2ZW50TmFtZXNcIjtcclxuaW1wb3J0IHsgSUJhY2tncm91bmRNYW5hZ2VyIH0gZnJvbSBcIi4vSUJhY2tncm91bmRNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IElBZ2VudENvbW11bmljYXRpb24gfSBmcm9tIFwiLi9JQWdlbnRDb21tdW5pY2F0aW9uXCI7XHJcbmltcG9ydCB7IElUYWJzTW9uaXRvcmluZyB9IGZyb20gXCIuL0lUYWJzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyBJV2ViUmVxdWVzdCB9IGZyb20gXCIuL0lXZWJSZXF1ZXN0XCI7XHJcbmltcG9ydCB7IElXZWJOYXZpZ2F0aW9uIH0gZnJvbSBcIi4vSVdlYk5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgV0VCX1JFUVVFU1RfRVZFTlRfTkFNRVNQQUNFIH0gZnJvbSBcIi4vV2ViUmVxdWVzdFwiO1xyXG5pbXBvcnQgKiBhcyBJZGxlTW9uaXRvcmluZyBmcm9tIFwiLi9JZGxlTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgKiBhcyBXaW5kb3dzTW9uaXRvcmluZyBmcm9tIFwiLi9XaW5kb3dzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgKiBhcyBEb3dubG9hZHNNb25pdG9yaW5nIGZyb20gXCIuL0Rvd25sb2Fkc01vbml0b3JpbmdcIjtcclxuaW1wb3J0IHsgdGltZVByb3ZpZGVyIH0gZnJvbSBcIi4uL3V0aWxzL3RpbWVQcm92aWRlclwiO1xyXG5pbXBvcnQgeyBSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhLCBSRVBPUlRfRVZFUllUSElOR19DT05GSUdVUkFUSU9OLCBSRVBPUlRfV1BNX0NPTkZJR1VSQVRJT04gfSBmcm9tIFwiLi4vY29tbW9uL0NvbmZpZ3VyYXRpb25EYXRhXCI7XHJcbmltcG9ydCB7IElJZGxlTW9uaXRvcmluZyB9IGZyb20gXCIuL0lJZGxlTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyBJV2luZG93c01vbml0b3JpbmcgfSBmcm9tIFwiLi9JV2luZG93c01vbml0b3JpbmdcIjtcclxuaW1wb3J0IHsgSUh0bWxFdmVudHNNb25pdG9yaW5nIH0gZnJvbSBcIi4vSUh0bWxFdmVudHNNb25pdG9yaW5nXCI7XHJcbmltcG9ydCB7IElXYWNDb21tdW5pY2F0aW9uIH0gZnJvbSBcIi4vSVdhY0NvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IHsgSURvd25sb2Fkc01vbml0b3JpbmcgfSBmcm9tIFwiLi9JRG93bmxvYWRzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyBXZWJOYXZpZ2F0aW9uUmVwb3J0ZXIgfSBmcm9tIFwiLi9XZWJOYXZpZ2F0aW9uUmVwb3J0ZXJcIjtcclxuaW1wb3J0IHsgQ29uZmlndXJhdGlvbk1hbmFnZXIgfSBmcm9tIFwiLi9Db25maWd1cmF0aW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbW1vbi9jb25maWd1cmF0aW9uL0NvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHsgTWVzc2FnZVByb2Nlc3NvciB9IGZyb20gXCIuL01lc3NhZ2VQcm9jZXNzb3JcIjtcclxuXHJcbi8vIEhhY2sgdG8gaW1pdGF0ZSBnZXR0ZXJzIHdoaWNoIGRvbid0IGV4aXN0IGluIG9sZCBJRVxyXG50eXBlIEJhY2tncm91bmRNdXRhYmxlTWFuYWdlciA9IHsgYWN0aXZlOiBib29sZWFuOyB9O1xyXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgYWxsIHN1YnNjcmlwdGlvbnNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kTWFuYWdlciBpbXBsZW1lbnRzIElCYWNrZ3JvdW5kTWFuYWdlciB7XHJcblx0cHVibGljIHJlYWRvbmx5IGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgaXNDb25uZWN0aW9uVGltZW91dEFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgdGltZW91dElkOiBOb2RlSlMuVGltZXIgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIG1lc3NhZ2VQcm9jZXNzb3I/OiBNZXNzYWdlUHJvY2Vzc29yO1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IHdlYk5hdmlnYXRpb25SZXBvcnRlcjogV2ViTmF2aWdhdGlvblJlcG9ydGVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY29tbXVuaWNhdGlvbjogSUFnZW50Q29tbXVuaWNhdGlvbixcclxuXHRcdHByaXZhdGUgcmVhZG9ubHkgY29uZmlndXJhdGlvbk1hbmFnZXI6IENvbmZpZ3VyYXRpb25NYW5hZ2VyLFxyXG5cdFx0cHJpdmF0ZSByZWFkb25seSB0YWJzTW9uaXRvcmluZzogSVRhYnNNb25pdG9yaW5nLFxyXG5cdFx0cHJpdmF0ZSByZWFkb25seSB3ZWJSZXF1ZXN0OiBJV2ViUmVxdWVzdCxcclxuXHRcdHByaXZhdGUgcmVhZG9ubHkgd2ViTmF2aWdhdGlvbjogSVdlYk5hdmlnYXRpb24sXHJcblx0XHRwcml2YXRlIHJlYWRvbmx5IHdpbmRvd3NNb25pdG9yaW5nOiBJV2luZG93c01vbml0b3JpbmcsXHJcblx0XHRwcml2YXRlIHJlYWRvbmx5IGlkbGVNb25pdG9yaW5nOiBJSWRsZU1vbml0b3JpbmcsXHJcblx0XHRwcml2YXRlIHJlYWRvbmx5IGh0bWxFdmVudHNNb25pdG9yaW5nOiBJSHRtbEV2ZW50c01vbml0b3JpbmcsXHJcblx0XHRwcml2YXRlIHJlYWRvbmx5IHdhY0NvbW11bmljYXRpb246IElXYWNDb21tdW5pY2F0aW9uLFxyXG5cdFx0cHJpdmF0ZSByZWFkb25seSBkb3dubG9hZHNNb25pdG9yaW5nOiBJRG93bmxvYWRzTW9uaXRvcmluZykge1xyXG5cclxuXHRcdHRoaXMud2ViTmF2aWdhdGlvblJlcG9ydGVyID0gbmV3IFdlYk5hdmlnYXRpb25SZXBvcnRlcihjb21tdW5pY2F0aW9uKTtcclxuXHRcdGVuYWJsZUxvZ3MoKTtcclxuXHJcblx0XHR0aGlzLmNvbm5lY3RUb1BvcnQoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRUYWJzTW9uaXRvcmluZygpOiBJVGFic01vbml0b3Jpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMudGFic01vbml0b3Jpbmc7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0TWVzc2FnZVByb2Nlc3NvcigpOiBNZXNzYWdlUHJvY2Vzc29yIHwgdW5kZWZpbmVkIHtcclxuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VQcm9jZXNzb3I7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2NoZWR1bGVDb25uZWN0QXR0ZW1wdCgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLmlzQ29ubmVjdGlvblRpbWVvdXRBY3RpdmUpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJUaGVyZSBpcyBhbHJlYWR5IGEgY29ubmVjdGlvbiBhdHRlbXB0LlwiKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuaXNDb25uZWN0aW9uVGltZW91dEFjdGl2ZSA9IHRydWU7XHJcblx0XHRcdGNvbnN0IHJldHJ5Q29ubmVjdE1zID0gNjAgKiAxMDAwO1xyXG5cdFx0XHRjb25zdCBkYXRlT2JqV2l0aE9mZnNldCA9IG5ldyBEYXRlKHRpbWVQcm92aWRlci5ub3coKSArIHJldHJ5Q29ubmVjdE1zKTtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuaW5mbyhgU2NoZWR1bGluZyBhbm90aGVyIGNvbm5lY3Rpb24gYXR0ZW1wdCBvbiAke2RhdGVPYmpXaXRoT2Zmc2V0fS5gKTtcclxuXHRcdFx0aWYgKHRoaXMudGltZW91dElkID09PSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRcdFx0dGhpcy5pc0Nvbm5lY3Rpb25UaW1lb3V0QWN0aXZlID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdHRoaXMuY29ubmVjdFRvUG9ydCgpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRpbWVvdXRJZCA9IG51bGw7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0cmV0cnlDb25uZWN0TXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY29ubmVjdFRvUG9ydCgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLmlzQ29ubmVjdGlvblRpbWVvdXRBY3RpdmUpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJpdCBpc24ndCBhbGxvd2VkIHRvIHRyeSB0byBjb25uZWN0XCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuaW5mbyhcIlRyeWluZyB0byBjb25uZWN0Li4uLlwiKTtcclxuXHRcdFx0aWYgKCF0aGlzLmNvbW11bmljYXRpb24uaW5pdENvbW11bmljYXRpb24odGhpcywgdGhpcy53ZWJOYXZpZ2F0aW9uKSkge1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLndhcm4oXCJGYWlsZWRcIik7XHJcblx0XHRcdFx0dGhpcy5zY2hlZHVsZUNvbm5lY3RBdHRlbXB0KCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Z2V0TG9nZ2VyKCkuaW5mbyhcIlN1Y2Nlc3NcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhY3RpdmF0ZShjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5hY3RpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIkFjdGl2YXRpbmdcIik7XHJcblxyXG5cdFx0KHRoaXMgYXMgQmFja2dyb3VuZE11dGFibGVNYW5hZ2VyKS5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubWVzc2FnZVByb2Nlc3NvciA9IG5ldyBNZXNzYWdlUHJvY2Vzc29yKGNvbmZpZ3VyYXRpb24pO1xyXG5cclxuXHRcdHRoaXMud2ViTmF2aWdhdGlvbi5zdWJzY3JpYmUodGhpcy53ZWJOYXZpZ2F0aW9uUmVwb3J0ZXIub25XZWJOYXZpZ2F0aW9uKTtcclxuXHRcdHRoaXMud2ViTmF2aWdhdGlvbi5zdWJzY3JpYmUodGhpcy53YWNDb21tdW5pY2F0aW9uLm9uV2ViTmF2aWdhdGlvbik7XHJcblxyXG5cdFx0Ly8gSFRNTCBldmVudHMgbW9uaXRvcmluZ1xyXG5cdFx0Y29uc3QgaGFzSHRtbEV2ZW50c01vbml0b3JpbmcgPVxyXG5cdFx0XHRjb25maWd1cmF0aW9uLmlzTW9uaXRvcmluZyhFdmVudE5hbWVzLkhUTUxfREVTSUdORVJfRVZFTlRfTkFNRVNQQUNFKSB8fFxyXG5cdFx0XHRjb25maWd1cmF0aW9uLmlzTW9uaXRvcmluZyhFdmVudE5hbWVzLkhUTUxfT05BUFBfRVZFTlRfTkFNRVNQQUNFKSB8fFxyXG5cdFx0XHRjb25maWd1cmF0aW9uLmlzTW9uaXRvcmluZyhFdmVudE5hbWVzLkRPTV9FVkVOVF9OQU1FU1BBQ0UpO1xyXG5cclxuXHRcdGNvbnN0IGhhc1dlYlJlcXVlc3RNb25pdG9yaW5nID1cclxuXHRcdFx0aGFzSHRtbEV2ZW50c01vbml0b3JpbmcgfHxcclxuXHRcdFx0Y29uZmlndXJhdGlvbi5oYXNXcG1GaWx0ZXIoKSB8fFxyXG5cdFx0XHRjb25maWd1cmF0aW9uLmlzTW9uaXRvcmluZyhXRUJfUkVRVUVTVF9FVkVOVF9OQU1FU1BBQ0UpO1xyXG5cclxuXHRcdHRoaXMudGFic01vbml0b3JpbmcuaW5pdFRhYnNNb25pdG9yaW5nKHRoaXMsIHRoaXMuY29tbXVuaWNhdGlvbiwgdGhpcy53ZWJSZXF1ZXN0LCB0aGlzLndlYk5hdmlnYXRpb24pO1xyXG5cclxuXHRcdGlmIChoYXNXZWJSZXF1ZXN0TW9uaXRvcmluZykge1xyXG5cdFx0XHR0aGlzLndlYlJlcXVlc3QuaW5pdFdlYlJlcXVlc3QodGhpcywgdGhpcy5jb21tdW5pY2F0aW9uLCB0aGlzLnRhYnNNb25pdG9yaW5nLCB0aGlzLmNvbmZpZ3VyYXRpb25NYW5hZ2VyLmdldENvbmZpZ3VyYXRpb24oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZ3VyYXRpb24uaXNNb25pdG9yaW5nKFdpbmRvd3NNb25pdG9yaW5nLldJTkRPV19FVkVOVF9OQU1FU1BBQ0UpKSB7XHJcblx0XHRcdHRoaXMud2luZG93c01vbml0b3JpbmcuaW5pdFdpbmRvd3NNb25pdG9yaW5nKHRoaXMsIHRoaXMuY29tbXVuaWNhdGlvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZ3VyYXRpb24uaXNNb25pdG9yaW5nKElkbGVNb25pdG9yaW5nLklETEVfRVZFTlRfTkFNRVNQQUNFKSkge1xyXG5cdFx0XHR0aGlzLmlkbGVNb25pdG9yaW5nLmluaXRJZGxlTW9uaXRvcmluZyh0aGlzLCB0aGlzLmNvbW11bmljYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWd1cmF0aW9uLmlzTW9uaXRvcmluZyhEb3dubG9hZHNNb25pdG9yaW5nLkRPV05MT0FEU19FVkVOVF9OQU1FU1BBQ0UpKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgY2hyb21lLmRvd25sb2FkcyA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRcdHRoaXMuZG93bmxvYWRzTW9uaXRvcmluZy5pbml0RG93bmxvYWRzTW9uaXRvcmluZyh0aGlzLCB0aGlzLmNvbW11bmljYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhhc0h0bWxFdmVudHNNb25pdG9yaW5nKSB7XHJcblx0XHRcdHRoaXMuaHRtbEV2ZW50c01vbml0b3JpbmcuaW5pdEV2ZW50c01vbml0b3JpbmcodGhpcy50YWJzTW9uaXRvcmluZyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVhY3RpdmF0ZSgpOiB2b2lkIHtcclxuXHRcdGlmICghdGhpcy5hY3RpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIkRlYWN0aXZhdGluZ1wiKTtcclxuXHJcblx0XHR0aGlzLndlYk5hdmlnYXRpb24udW5zdWJzY3JpYmUodGhpcy53ZWJOYXZpZ2F0aW9uUmVwb3J0ZXIub25XZWJOYXZpZ2F0aW9uKTtcclxuXHJcblx0XHQodGhpcyBhcyBCYWNrZ3JvdW5kTXV0YWJsZU1hbmFnZXIpLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIERlYWN0aXZhdGUgYWxsXHJcblx0XHR0aGlzLnRhYnNNb25pdG9yaW5nLnVuaW5pdFRhYnNNb25pdG9yaW5nKCk7XHJcblx0XHR0aGlzLndlYlJlcXVlc3QudW5pbml0V2ViUmVxdWVzdCgpO1xyXG5cdFx0dGhpcy53aW5kb3dzTW9uaXRvcmluZy51bmluaXRXaW5kb3dzTW9uaXRvcmluZygpO1xyXG5cdFx0dGhpcy5pZGxlTW9uaXRvcmluZy51bmluaXRJZGxlTW9uaXRvcmluZygpO1xyXG5cdFx0dGhpcy5odG1sRXZlbnRzTW9uaXRvcmluZy51bmluaXRFdmVudHNNb25pdG9yaW5nKCk7XHJcblx0XHR0aGlzLmRvd25sb2Fkc01vbml0b3JpbmcudW5pbml0RG93bmxvYWRzTW9uaXRvcmluZygpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlcG9ydEV2ZXJ5dGhpbmcoKTogdm9pZCB7XHJcblx0XHR0aGlzLmNoYW5nZUNvbmZpZ3VyYXRpb24oUkVQT1JUX0VWRVJZVEhJTkdfQ09ORklHVVJBVElPTik7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVwb3J0QWxsV3BtKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5jaGFuZ2VDb25maWd1cmF0aW9uKFJFUE9SVF9XUE1fQ09ORklHVVJBVElPTik7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVwb3J0Tm90aGluZygpOiB2b2lkIHtcclxuXHRcdHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBjaGFuZ2VDb25maWd1cmF0aW9uKGNvbmZpZ0RhdGE6IFJlYWRvbmx5Q29uZmlndXJhdGlvbkRhdGEpOiB2b2lkIHtcclxuXHJcblx0XHR0aGlzLmRlYWN0aXZhdGUoKTtcclxuXHRcdHRoaXMuaXNDb25uZWN0aW9uVGltZW91dEFjdGl2ZSA9IGZhbHNlO1xyXG5cdFx0aWYgKHRoaXMudGltZW91dElkICE9PSBudWxsKSB7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XHJcblx0XHRcdHRoaXMudGltZW91dElkID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnRGF0YSk7XHJcblx0XHR0aGlzLmFjdGl2YXRlKGNvbmZpZ3VyYXRpb24pO1xyXG5cdFx0dGhpcy5jb21tdW5pY2F0aW9uLmluaXRDb21tdW5pY2F0aW9uKHRoaXMsIHRoaXMud2ViTmF2aWdhdGlvbiwgZmFsc2UpO1xyXG5cdH1cclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCIuLi91dGlscy9sb2dcIjtcclxuaW1wb3J0IHsgV2ViUmVxdWVzdEV2ZW50IH0gZnJvbSBcIi4vV2ViUmVxdWVzdEV2ZW50XCI7XHJcbmltcG9ydCB7IElXZWJSZXF1ZXN0RXZlbnREYXRhIH0gZnJvbSBcIi4vV2ViUmVxdWVzdFwiO1xyXG5pbXBvcnQgeyBPdXRnb2luZ0V2ZW50TWVzc2FnZSB9IGZyb20gXCIuLi9jb21tb24vTWVzc2FnaW5nTW9kZWxcIjtcclxuXHJcbi8qKlxyXG4gKiBFdmVudCBuYW1lIC0+IER1cmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFdlYlJlcXVlc3REdXJhdGlvbnMge1xyXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSByZWFkb25seS1hcnJheVxyXG5cdFtldmVudE5hbWU6IHN0cmluZ106IG51bWJlcltdO1xyXG59XHJcblxyXG4vLyBIYWNrIHRvIGltaXRhdGUgZ2V0dGVycyB3aGljaCBkb24ndCBleGlzdCBpbiBvbGQgSUVcclxudHlwZSBNdXRhYmxlV2ViUmVxdWVzdFN0YXRlID0geyBldmVudFRpbWVzOiBXZWJSZXF1ZXN0RHVyYXRpb25zOyB9O1xyXG5cclxuZXhwb3J0IGNsYXNzIFdlYlJlcXVlc3RTdGF0ZSB7XHJcblx0LyoqXHJcblx0ICogRmlyc3QgYmVmb3JlIHJlcXVlc3QgZXZlbnQuXHJcblx0ICogUmVtb3ZlZCBhZnRlciB0aGUgU3RhcnQgZXZlbnQgaXMgc2VudCAhXHJcblx0ICovXHJcblx0cHVibGljIGJlZm9yZVJlcXVlc3RFdmVudD86IE91dGdvaW5nRXZlbnRNZXNzYWdlPElXZWJSZXF1ZXN0RXZlbnREYXRhPjtcclxuXHJcblx0LyoqXHJcblx0ICogVHJ1ZSB3aGVuIGJlZm9yZVJlcXVlc3RFdmVudCBtZW1iZXIgaXMgc2V0LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzZXRCZWZvcmVSZXF1ZXN0RXZlbnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyoqXHJcblx0ICogVHJ1ZSB3aGVuIFN0YXJ0IGV2ZW50IGhhcyBiZWVuIHBvc3RlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgcG9zdGVkU3RhcnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0cHVibGljIHN0YXJ0TWVzYWdlT3JkZXI/OiBudW1iZXI7XHJcblxyXG5cdHB1YmxpYyB0b3RhbEluY29taW5nQnl0ZXMgPSAwO1xyXG5cdHB1YmxpYyB0b3RhbE91dGdvaW5nQnl0ZXMgPSAwO1xyXG5cdHB1YmxpYyByZXF1ZXN0U3RhcnRUaW1lOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBcInNlcnZlciB0aW1lXCIgdGhhdCBpcyB0aGUgdGltZSBiZXR3ZWVuIHNlbmRpbmcgaGVhZGVycyBhbmQgcmVjZWl2aW5nIHRoZSBzZXJ2ZXIgcmVzcG9uc2UuXHJcblx0ICovXHJcblx0cHVibGljIHRvdGFsU2VydmVyVGltZSA9IDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gcmVtZW1iZXIgdGhlIGxhc3QgdGltZXN0YW1wIHRoYXQgd2Ugd2VudCB0aHJvdWdoIE9uU2VuZEhlYWRlcnMuXHJcblx0ICovXHJcblx0cHVibGljIGxhc3RPblNlbmRIZWFkZXJzVHMgPSAwO1xyXG5cclxuXHQvKipcclxuXHQgKiBTdG9yZWQgZXZlbnQgdGltZXMuXHJcblx0ICovXHJcblx0cHVibGljIHJlYWRvbmx5IGV2ZW50VGltZXM6IFdlYlJlcXVlc3REdXJhdGlvbnMgPSB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHJlcXVlc3QgY2FtZSB3aXRoIEFwcEludGVybmFscyBoZWFkZXIuXHJcblx0ICovXHJcblx0cHVibGljIGFwcEludGVybmFsc01vbml0b3Jpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyoqXHJcblx0ICogU3RvcmVzIGV2ZW50IHRpbWUgZm9yIHRoZSBnaXZlbiBldmVudFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHJlcXVlc3RFdmVudCBSZXF1ZXN0IGV2ZW50IG5hbWUuXHJcblx0ICogQHBhcmFtIGV2ZW50VGltZSBUaW1lIG9mIHRoaXMgZXZlbnQuXHJcblx0ICovXHJcblx0cHVibGljIHN0b3JlRXZlbnRUaW1lKHJlcXVlc3RFdmVudDogV2ViUmVxdWVzdEV2ZW50LCBldmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0bGV0IGR1cmF0aW9uID0gMTAgKiAoZXZlbnRUaW1lIC0gdGhpcy5yZXF1ZXN0U3RhcnRUaW1lKTtcclxuXHRcdGR1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbikgLyAxMDtcclxuXHJcblx0XHRjb25zdCByZXF1ZXN0RXZlbnRTdHIgPSBXZWJSZXF1ZXN0RXZlbnRbcmVxdWVzdEV2ZW50XTtcclxuXHRcdGlmICghKHJlcXVlc3RFdmVudFN0ciBpbiB0aGlzLmV2ZW50VGltZXMpKSB7XHJcblx0XHRcdHRoaXMuZXZlbnRUaW1lc1tyZXF1ZXN0RXZlbnRTdHJdID0gW107XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ldmVudFRpbWVzW3JlcXVlc3RFdmVudFN0cl0ucHVzaChkdXJhdGlvbik7XHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvcihyZXF1ZXN0U3RhcnRUaW1lOiBudW1iZXIpIHtcclxuXHRcdHRoaXMucmVxdWVzdFN0YXJ0VGltZSA9IHJlcXVlc3RTdGFydFRpbWU7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElXZWJSZXF1ZXN0cyB7XHJcblx0W3JlcXVlc3RJZDogc3RyaW5nXTogV2ViUmVxdWVzdFN0YXRlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgV2ViUmVxdWVzdHNTdGF0ZXMge1xyXG5cdHByaXZhdGUgcmVxdWVzdHM6IElXZWJSZXF1ZXN0cyA9IHt9O1xyXG5cclxuXHRwdWJsaWMgYWRkKHJlcXVlc3RJZDogc3RyaW5nLCB0aW1lU3RhbXA6IG51bWJlcik6IFdlYlJlcXVlc3RTdGF0ZSB7XHJcblx0XHRnZXRMb2dnZXIoKS5kZWJ1ZyhcIkFkZGluZyByZXF1ZXN0XCIsIHJlcXVlc3RJZCk7XHJcblx0XHRyZXR1cm4gdGhpcy5yZXF1ZXN0c1tyZXF1ZXN0SWRdID0gbmV3IFdlYlJlcXVlc3RTdGF0ZSh0aW1lU3RhbXApO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldChyZXF1ZXN0SWQ6IHN0cmluZyk6IFdlYlJlcXVlc3RTdGF0ZSB8IHVuZGVmaW5lZCB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZXF1ZXN0c1tyZXF1ZXN0SWRdO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZShyZXF1ZXN0SWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJSZW1vdmluZyByZXF1ZXN0XCIsIHJlcXVlc3RJZCk7XHJcblx0XHRkZWxldGUgdGhpcy5yZXF1ZXN0c1tyZXF1ZXN0SWRdO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5yZXF1ZXN0cyA9IHt9O1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IEZyYW1lU3RhdGUgfSBmcm9tIFwiLi9UYWJzU3RhdGVcIjtcclxuaW1wb3J0IHsgSUFnZW50Q29tbXVuaWNhdGlvbiB9IGZyb20gXCIuL0lBZ2VudENvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IHsgZ2V0RnJhbWVUeXBlIH0gZnJvbSBcIi4uL2NvbW1vbi9GcmFtZVR5cGVcIjtcclxuaW1wb3J0IHsgVVhEYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi9VWERhdGFcIjtcclxuaW1wb3J0IHsgT3V0Z29pbmdFdmVudE1lc3NhZ2UgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NhZ2luZ01vZGVsXCI7XHJcbmltcG9ydCB7IFdlYk5hdmlnYXRpb25FdmVudCB9IGZyb20gXCIuL0lXZWJOYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IGlzU2VyaWFsaXphYmxlUHJpbWl0aXZlIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XHJcblxyXG5pbnRlcmZhY2UgV2ViTmF2aWdhdGlvbkV2ZW50RGF0YSBleHRlbmRzIFVYRGF0YSB7XHJcblx0Ly8gI3JlZ2lvbiBHZW5lcmljIGV2ZW50IHByb3BlcnRpZXNcclxuXHJcblx0dXJsOiBzdHJpbmc7XHJcblx0dGFiSWQ6IG51bWJlcjtcclxuXHRmcmFtZUlkOiBudW1iZXI7XHJcblx0dHlwZTogc3RyaW5nO1xyXG5cclxuXHRmcmFtZVVybDogc3RyaW5nO1xyXG5cdGZyYW1lQ3VycmVudFVybDogc3RyaW5nO1xyXG5cdGZyYW1lQ29tbWl0dGVkVXJsOiBzdHJpbmc7XHJcblx0ZG9jdW1lbnRVcmw6IHN0cmluZztcclxuXHRkb2N1bWVudEN1cnJlbnRVcmw6IHN0cmluZztcclxuXHRkb2N1bWVudENvbW1pdHRlZFVybDogc3RyaW5nO1xyXG5cclxuXHQvLyAjZW5kcmVnaW9uXHJcblxyXG5cdC8vICNyZWdpb24gRXZlbnQgc3BlY2lmaWMgcHJvcGVydGllc1xyXG5cclxuXHRzb3VyY2VGcmFtZUlkPzogbnVtYmVyO1xyXG5cdHNvdXJjZVRhYklkPzogbnVtYmVyO1xyXG5cdHBhcmVudEZyYW1lSWQ/OiBudW1iZXI7XHJcblx0ZXJyb3I/OiBzdHJpbmc7XHJcblx0dHJhbnNpdGlvblF1YWxpZmllcnM/OiBzdHJpbmc7XHJcblx0dHJhbnNpdGlvblR5cGU/OiBzdHJpbmc7XHJcblxyXG5cdC8vICNlbmRyZWdpb25cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFdFQl9OQVZJR0FUSU9OX0VWRU5UX05BTUVTUEFDRSA9IFwiaHRtbDpjaHJvbWU6V2ViTmF2aWdhdGlvblwiO1xyXG5cclxuZnVuY3Rpb24gbWFrZUV2ZW50TmFtZShldmVudDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gV0VCX05BVklHQVRJT05fRVZFTlRfTkFNRVNQQUNFICsgXCIuXCIgKyBldmVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcG9ydHMgV2ViTmF2aWdhdGlvbiBldmVudHMgdG8gQWdlbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViTmF2aWdhdGlvblJlcG9ydGVyIHtcclxuXHRwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb21tdW5pY2F0aW9uOiBJQWdlbnRDb21tdW5pY2F0aW9uKSB7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVhZG9ubHkgb25XZWJOYXZpZ2F0aW9uID0gKFxyXG5cdFx0ZXZlbnQ6IFdlYk5hdmlnYXRpb25FdmVudCxcclxuXHRcdGRldGFpbHM6IGNocm9tZS53ZWJOYXZpZ2F0aW9uLldlYk5hdmlnYXRpb25DYWxsYmFja0RldGFpbHMsXHJcblx0XHRmcmFtZVN0YXRlPzogRnJhbWVTdGF0ZSB8IG51bGwsXHJcblx0XHR0YWJTdGF0ZT86IEZyYW1lU3RhdGUgfCBudWxsKSA9PiB7XHJcblxyXG5cdFx0Y29uc3QgbWVzc2FnZSA9IG5ldyBPdXRnb2luZ0V2ZW50TWVzc2FnZShtYWtlRXZlbnROYW1lKGV2ZW50KSwgZGV0YWlscy50aW1lU3RhbXApO1xyXG5cdFx0Y29uc3QgZXZlbnREYXRhID0gbWVzc2FnZS5tZXNzYWdlRGF0YS5EYXRhWzBdIGFzIFdlYk5hdmlnYXRpb25FdmVudERhdGE7XHJcblx0XHRjb25zdCBkZXRhaWxzUmVjb3JkID0gZGV0YWlscyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHJcblx0XHQvLyBDb3B5IGFsbCBwcm9wZXJ0aWVzXHJcblx0XHRmb3IgKGNvbnN0IHByb3AgaW4gZGV0YWlscykge1xyXG5cdFx0XHRpZiAoZGV0YWlscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG5cdFx0XHRcdGNvbnN0IHByb3BWYWx1ZSA9IGRldGFpbHNSZWNvcmRbcHJvcF07XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlcmlhbGl6YWJsZVByaW1pdGl2ZShwcm9wVmFsdWUpKSB7XHJcblx0XHRcdFx0XHRldmVudERhdGFbcHJvcF0gPSBwcm9wVmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIEFycmF5IGhhcyBzcGVjaWFsIHRyZWF0bWVudFxyXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xyXG5cdFx0XHRcdFx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWFueVxyXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgcHJvcFZhbHVlKSB7XHJcblx0XHRcdFx0XHRcdFx0ZXZlbnREYXRhW2Ake3Byb3B9LiR7aXRlbX1gXSA9IFwidHJ1ZVwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIEFkZCB1cmxzXHJcblx0XHRpZiAoZnJhbWVTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdGV2ZW50RGF0YS5mcmFtZVVybCA9IGZyYW1lU3RhdGUuc3RhcnRVcmw7XHJcblx0XHRcdGV2ZW50RGF0YS5mcmFtZUN1cnJlbnRVcmwgPSBmcmFtZVN0YXRlLmN1cnJlbnRVcmw7XHJcblx0XHRcdGlmIChmcmFtZVN0YXRlLmNvbW1pdHRlZFVybCAhPSBudWxsKSB7XHJcblx0XHRcdFx0ZXZlbnREYXRhLmZyYW1lQ29tbWl0dGVkVXJsID0gZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGV2ZW50RGF0YS50eXBlID0gZ2V0RnJhbWVUeXBlKGZyYW1lU3RhdGUuZnJhbWVJZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRhYlN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0ZXZlbnREYXRhLmRvY3VtZW50VXJsID0gdGFiU3RhdGUuc3RhcnRVcmw7XHJcblx0XHRcdGV2ZW50RGF0YS5kb2N1bWVudEN1cnJlbnRVcmwgPSB0YWJTdGF0ZS5jdXJyZW50VXJsO1xyXG5cdFx0XHRpZiAodGFiU3RhdGUuY29tbWl0dGVkVXJsICE9IG51bGwpIHtcclxuXHRcdFx0XHRldmVudERhdGEuZG9jdW1lbnRDb21taXR0ZWRVcmwgPSB0YWJTdGF0ZS5jb21taXR0ZWRVcmw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBHZXQgdHlwZSB1c2luZyBkZXRhaWxzIGlmIHdhcyBub3Qgc2V0LlxyXG5cdFx0aWYgKGV2ZW50ICE9PSBcIkNyZWF0ZU5hdmlnYXRpb25UYXJnZXRcIiAmJiBldmVudERhdGEudHlwZSA9PSBudWxsKSB7XHJcblx0XHRcdC8vIFJlU2hhcnBlciBkaXNhYmxlIG9uY2UgU3VzcGljaW91c1R5cGVvZkNoZWNrXHJcblx0XHRcdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1hbnkgbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cclxuXHRcdFx0Y29uc3QgZnJhbWVJZCA9IGRldGFpbHNSZWNvcmRbXCJmcmFtZUlkXCJdIGFzIHVua25vd24gfCBudW1iZXI7XHJcblx0XHRcdGlmICh0eXBlb2YgZnJhbWVJZCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRcdGV2ZW50RGF0YS50eXBlID0gZ2V0RnJhbWVUeXBlKGZyYW1lSWQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLndhcm4oXCJOZWl0aGVyIGZyYW1lU3RhdGUgbm9yIGRldGFpbHMgaGFzIGZyYW1lIGlkZW50aWZpZXJcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0fVxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuLi9jb21tb24vY29uZmlndXJhdGlvbi9Db25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCAqIGFzIENvbnN0cyBmcm9tIFwiLi4vY29tbW9uL2NvbnN0c1wiO1xyXG5pbXBvcnQgeyBVWERhdGEgfSBmcm9tIFwiLi4vY29tbW9uL1VYRGF0YVwiO1xyXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xyXG5pbXBvcnQgeyBMYXp5IH0gZnJvbSBcIi4uL3V0aWxzL2xhenlcIjtcclxuaW1wb3J0IHsgUG9zdE5hdGl2ZU1lc3NhZ2VPcHRpb25zIH0gZnJvbSBcIi4vSUFnZW50Q29tbXVuaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBPdXRnb2luZ0V2ZW50TWVzc2FnZURhdGEgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NhZ2luZ01vZGVsXCI7XHJcbmltcG9ydCBQcmltaXRpdmUgPSBVdGlscy5QcmltaXRpdmU7XHJcblxyXG5leHBvcnQgY2xhc3MgTWVzc2FnZVByb2Nlc3NvciB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9QT1NUX05BVElWRV9NRVNTQUdFX09QVElPTlM6IFBvc3ROYXRpdmVNZXNzYWdlT3B0aW9ucyA9IHtcclxuXHRcdGZvcmNlUG9zdDogZmFsc2VcclxuXHR9O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb24pIHtcclxuXHR9XHJcblxyXG5cdC8qXHJcblx0ICogQHJldHVybiB0cnVlIGlmIGV2ZW50IGlzIGluIHRoZSBldmVudCBmaWx0ZXJzIGxpc3QgYW5kIGl0IGhhcyBhbGwgcmVxdWlyZWQgcHJvcGVydGllc1xyXG5cdCAqIGZvciB0aGlzIGV2ZW50LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBpc0V2ZW50TW9uaXRvcmVkKG1lc3NhZ2U6IE91dGdvaW5nRXZlbnRNZXNzYWdlRGF0YTxVWERhdGE+KTogYm9vbGVhbiB7XHJcblx0XHQvLyBWYWxpZGF0ZSBtZXNzYWdlIGFuZCBldmVudFxyXG5cdFx0aWYgKG1lc3NhZ2UuRGF0YSA9PSBudWxsIHx8XHJcblx0XHRcdG1lc3NhZ2UuRGF0YVswXSA9PSBudWxsIHx8XHJcblx0XHRcdCF0aGlzLmNvbmZpZ3VyYXRpb24uaGFzRXZlbnRGaWx0ZXIobWVzc2FnZS5FdmVudFR5cGUpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXZWJSZXF1ZXN0IHJlcXVpcmVkIHByb3BlcnRpZXNcclxuXHRcdGlmIChDb25zdHMuV0VCUkVRVUVTVF9FVkVOVF9SRS50ZXN0KG1lc3NhZ2UuRXZlbnRUeXBlKSkge1xyXG5cdFx0XHRjb25zdCBkYXRhID0gbWVzc2FnZS5EYXRhWzBdO1xyXG5cclxuXHRcdFx0aWYgKCFDb25zdHMuV0VCUkVRVUVTVF9SRVFVSVJFRF9QUk9QRVJUSUVTLnNvbWUoXHJcblx0XHRcdFx0cHJvcGVydGllcyA9PiBwcm9wZXJ0aWVzLmV2ZXJ5KHAgPT4gdGhpcy5pc01hdGNoRXZlbnQobWVzc2FnZS5FdmVudFR5cGUsIHAsIGRhdGFbcF0pKSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGwgaXNNYXRjaEV2ZW50IHdpdGggY2hlY2sgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgaXNNYXRjaEV2ZW50PFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwcm9wZXJ0eU5hbWU6IHN0cmluZywgaW5wdXQ6IFQpOiBib29sZWFuIHtcclxuXHRcdGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5pc01hdGNoRXZlbnQoXHJcblx0XHRcdGV2ZW50TmFtZSxcclxuXHRcdFx0cHJvcGVydHlOYW1lLFxyXG5cdFx0XHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWFueVxyXG5cdFx0XHRpbnB1dC50b1N0cmluZygpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEByZXR1cm4gV2hldGhlciBwcm9wZXJ0eSBpcyBub3QgdHJ1bmNhdGVkLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgaXNOb25UcnVuY2F0ZWQobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHQvLyBBbGwgYXRlcm5pdHkgcHJvcGVydGllcyBhcmUgbm90IHRydW5jYXRlZC5cclxuXHRcdHJldHVybiBVdGlscy5zdGFydHNXaXRoKG5hbWUsIFwiYXRlcm5pdHlcIik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IGFuZCBmaWx0ZXIgYXJyYXkgdmFsdWVzLlxyXG5cdCAqIFRoZSBzdHJpbmcgcmV0dXJuZWQgZG9lc24ndCBoYXZlIHRoZSBwcmVjaXNlIHNpemUgb2YgbWF4UHJvcGVydHlMZW5ndGggZHVlIHRvIEpTT04gZm9ybWF0LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcHJvY2Vzc01lc3NhZ2VEYXRhQXJyYXkoXHJcblx0XHRldmVudFR5cGU6IHN0cmluZyxcclxuXHRcdG5hbWU6IHN0cmluZyxcclxuXHRcdGFycmF5OiBSZWFkb25seUFycmF5PFByaW1pdGl2ZT4sXHJcblx0XHRvcHRpb25zOiBQb3N0TmF0aXZlTWVzc2FnZU9wdGlvbnMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cclxuXHRcdGNvbnN0IHZhbHVlU3RyID0gbmV3IExhenkoKCkgPT4ge1xyXG5cdFx0XHRjb25zdCBuZXdBcnJheTogc3RyaW5nW10gPSBbXTtcclxuXHRcdFx0bGV0IHJlbWFpbmluZ0NoYXJzID0gdGhpcy5pc05vblRydW5jYXRlZChuYW1lKVxyXG5cdFx0XHRcdD8gSW5maW5pdHlcclxuXHRcdFx0XHQ6IHRoaXMuY29uZmlndXJhdGlvbi5tYXhQcm9wZXJ0eUxlbmd0aDtcclxuXHJcblx0XHRcdC8vIEdvIG92ZXIgYWxsIHRoZSBlbGVtZW50c1xyXG5cdFx0XHRmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXJyYXkpIHtcclxuXHRcdFx0XHRpZiAoIVV0aWxzLmlzU2VyaWFsaXphYmxlUHJpbWl0aXZlKGVsZW1lbnQpKSB7XHJcblx0XHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgaW4gYXJyYXlcIiwgZWxlbWVudCk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFJlU2hhcnBlciBkaXNhYmxlIG9uY2UgVHNSZXNvbHZlZEZyb21JbmFjY2Vzc2libGVNb2R1bGVcclxuXHRcdFx0XHRjb25zdCBvYmpBdEVsZW1lbnQgPSBlbGVtZW50LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0Y29uc3Qgb2JqQXRFbGVtZW50TGVuZ3RoID0gb2JqQXRFbGVtZW50Lmxlbmd0aDtcclxuXHJcblx0XHRcdFx0bmV3QXJyYXkucHVzaChvYmpBdEVsZW1lbnQuc3Vic3RyKDAsIHJlbWFpbmluZ0NoYXJzKSk7XHJcblx0XHRcdFx0Ly8gQWRkIDMgbW9yZSBjaGFyYWN0ZXJzLCBpdCBpcyB0aGUgYXZlcmFnZSBsZW5ndGggZm9yIGVhY2ggZWxlbWVudDogXCIsXCIuXHJcblx0XHRcdFx0cmVtYWluaW5nQ2hhcnMgLT0gb2JqQXRFbGVtZW50TGVuZ3RoICsgMztcclxuXHJcblx0XHRcdFx0Ly8gSWYgbm8gY2hhcnMgcmVtYWluaW5nLCBicmVha1xyXG5cdFx0XHRcdGlmIChyZW1haW5pbmdDaGFycyA8PSAwKSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShuZXdBcnJheSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBUZXN0IHByb3BlcnR5XHJcblx0XHRyZXR1cm4gb3B0aW9ucy5mb3JjZVBvc3QgfHwgdGhpcy5jb25maWd1cmF0aW9uLmlzTWF0Y2hFdmVudChldmVudFR5cGUsIG5hbWUsIHZhbHVlU3RyKSA/XHJcblx0XHRcdHZhbHVlU3RyLmdldFZhbHVlKCkgOlxyXG5cdFx0XHR1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHByb2Nlc3NNZXNzYWdlRGF0YVZhbHVlKFxyXG5cdFx0ZXZlbnRUeXBlOiBzdHJpbmcsXHJcblx0XHRuYW1lOiBzdHJpbmcsXHJcblx0XHR2YWx1ZTogUHJpbWl0aXZlLFxyXG5cdFx0b3B0aW9uczogUG9zdE5hdGl2ZU1lc3NhZ2VPcHRpb25zKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHRcdGlmICghVXRpbHMuaXNTZXJpYWxpemFibGVQcmltaXRpdmUodmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29udmVydFxyXG5cdFx0Y29uc3QgdmFsdWVTdHIgPSBuZXcgTGF6eSgoKSA9PiB7XHJcblx0XHRcdGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0Ly8gRG8gbm90IHRydW5jYXRlIGF0ZXJuaXR5IHByb3BlcnRpZXMuXHJcblx0XHRcdGlmICghdGhpcy5pc05vblRydW5jYXRlZChuYW1lKSkge1xyXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoMCwgdGhpcy5jb25maWd1cmF0aW9uLm1heFByb3BlcnR5TGVuZ3RoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH0pO1xyXG5cclxuXHJcblx0XHQvLyBUZXN0IHByb3BlcnR5XHJcblx0XHRyZXR1cm4gb3B0aW9ucy5mb3JjZVBvc3QgfHwgdGhpcy5jb25maWd1cmF0aW9uLmlzTWF0Y2hFdmVudChldmVudFR5cGUsIG5hbWUsIHZhbHVlU3RyKSA/XHJcblx0XHRcdHZhbHVlU3RyLmdldFZhbHVlKCkgOlxyXG5cdFx0XHR1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIHByb3BlcnR5IHRvIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuXHQgKiBAcmV0dXJuIENvbnZlcnRlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBtYXRjaCBmaWx0ZXJzLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgcHJvY2Vzc01lc3NhZ2VEYXRhUHJvcGVydHkoXHJcblx0XHRldmVudFR5cGU6IHN0cmluZyxcclxuXHRcdG5hbWU6IHN0cmluZyxcclxuXHRcdHZhbHVlOiBSZWFkb25seUFycmF5PFByaW1pdGl2ZT4gfCBQcmltaXRpdmUsXHJcblx0XHRvcHRpb25zOiBQb3N0TmF0aXZlTWVzc2FnZU9wdGlvbnMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnByb2Nlc3NNZXNzYWdlRGF0YUFycmF5KGV2ZW50VHlwZSwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJvY2Vzc01lc3NhZ2VEYXRhVmFsdWUoZXZlbnRUeXBlLCBuYW1lLCB2YWx1ZSBhcyBQcmltaXRpdmUsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHByb2Nlc3NNZXNzYWdlRGF0YU9iamVjdChcclxuXHRcdGV2ZW50VHlwZTogc3RyaW5nLFxyXG5cdFx0ZGF0YTogVVhEYXRhLFxyXG5cdFx0b3B0aW9uczogUG9zdE5hdGl2ZU1lc3NhZ2VPcHRpb25zID0gTWVzc2FnZVByb2Nlc3Nvci5ERUZBVUxUX1BPU1RfTkFUSVZFX01FU1NBR0VfT1BUSU9OUyk6IHZvaWQge1xyXG5cdFx0VXRpbHMucmV3cml0ZU9iamVjdChcclxuXHRcdFx0ZGF0YSxcclxuXHRcdFx0KG46IHN0cmluZywgdjogUHJpbWl0aXZlIHwgUmVhZG9ubHlBcnJheTxQcmltaXRpdmU+KSA9PiB0aGlzLnByb2Nlc3NNZXNzYWdlRGF0YVByb3BlcnR5KGV2ZW50VHlwZSwgbiwgdiwgb3B0aW9ucyksXHJcblx0XHRcdGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGV2ZXJ5IHByb3BlcnR5IHRvIHN0cmluZyByZXByZXNlbnRhdGlvbiBhbmQgcmVtb3ZlcyB1bm1hdGNoZWQgb25lcy5cclxuXHQgKiBJZiB0aGUgcHJvcGVydHkgbWF0Y2hlcywgdGhlbiBpdCBpcyB0cmltbWVkIHRvIENvbmZpZ3VyYXRpb24ubWF4UHJvcGVydHlMZW5ndGguXHJcblx0ICovXHJcblx0cHVibGljIHByb2Nlc3NNZXNzYWdlRGF0YShcclxuXHRcdG1lc3NhZ2VEYXRhOiBPdXRnb2luZ0V2ZW50TWVzc2FnZURhdGE8VVhEYXRhPixcclxuXHRcdG9wdGlvbnM6IFBvc3ROYXRpdmVNZXNzYWdlT3B0aW9ucyA9IE1lc3NhZ2VQcm9jZXNzb3IuREVGQVVMVF9QT1NUX05BVElWRV9NRVNTQUdFX09QVElPTlMpOiB2b2lkIHtcclxuXHRcdGZvciAoY29uc3QgZGF0YSBvZiBtZXNzYWdlRGF0YS5EYXRhKSB7XHJcblx0XHRcdHRoaXMucHJvY2Vzc01lc3NhZ2VEYXRhT2JqZWN0KG1lc3NhZ2VEYXRhLkV2ZW50VHlwZSwgZGF0YSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxzL2xvZ1wiO1xyXG5pbXBvcnQgeyBUYWJzU3RhdGVzLCBGcmFtZVN0YXRlIH0gZnJvbSBcIi4vVGFic1N0YXRlXCI7XHJcbmltcG9ydCB7IGdldEZyYW1lVHlwZSB9IGZyb20gXCIuLi9jb21tb24vRnJhbWVUeXBlXCI7XHJcbmltcG9ydCB7IElXZWJOYXZpZ2F0aW9uLCBXZWJOYXZpZ2F0aW9uRXZlbnQsIFdlYk5hdmlnYXRpb25SZXBvcnRDYWxsYmFjayB9IGZyb20gXCIuL0lXZWJOYXZpZ2F0aW9uXCI7XHJcblxyXG5pbXBvcnQgd2ViTmF2aWdhdGlvbiA9IGNocm9tZS53ZWJOYXZpZ2F0aW9uO1xyXG5cclxuY29uc3QgV0VCTkFWSUdBVElPTl9VUkxfRklMVEVSOiBSZWFkb25seTx3ZWJOYXZpZ2F0aW9uLldlYk5hdmlnYXRpb25FdmVudEZpbHRlcj4gPSB7XHJcblx0dXJsOiBbe3NjaGVtZXM6IFtcImh0dHBcIiwgXCJodHRwc1wiXX1dXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgV2ViTmF2aWdhdGlvbiBpbXBsZW1lbnRzIElXZWJOYXZpZ2F0aW9uIHtcclxuXHRwdWJsaWMgcmVhZG9ubHkgd2ViTmF2aWdhdGlvblRhYnNTdGF0ZXMgPSBuZXcgVGFic1N0YXRlcygpO1xyXG5cclxuXHRwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcblx0XHQvLyBNb25pdG9yIHJlbW92ZWQgdGFicyBmb3IgaW5zdGFuY2UgbmF2aWdhdGlvbnMuXHJcblx0XHRjaHJvbWUudGFicy5vblJlbW92ZWQuYWRkTGlzdGVuZXIodGhpcy5vblJlbW92ZWQpO1xyXG5cclxuXHRcdHdlYk5hdmlnYXRpb24ub25DcmVhdGVkTmF2aWdhdGlvblRhcmdldC5hZGRMaXN0ZW5lcih0aGlzLm9uQ3JlYXRlZE5hdmlnYXRpb25UYXJnZXQsIFdFQk5BVklHQVRJT05fVVJMX0ZJTFRFUik7XHJcblx0XHR3ZWJOYXZpZ2F0aW9uLm9uQmVmb3JlTmF2aWdhdGUuYWRkTGlzdGVuZXIodGhpcy5vbkJlZm9yZU5hdmlnYXRlLCBXRUJOQVZJR0FUSU9OX1VSTF9GSUxURVIpO1xyXG5cdFx0d2ViTmF2aWdhdGlvbi5vbkNvbW1pdHRlZC5hZGRMaXN0ZW5lcih0aGlzLm9uQ29tbWl0dGVkLCBXRUJOQVZJR0FUSU9OX1VSTF9GSUxURVIpO1xyXG5cdFx0d2ViTmF2aWdhdGlvbi5vbkRPTUNvbnRlbnRMb2FkZWQuYWRkTGlzdGVuZXIodGhpcy5vbkRPTUNvbnRlbnRMb2FkZWQsIFdFQk5BVklHQVRJT05fVVJMX0ZJTFRFUik7XHJcblx0XHR3ZWJOYXZpZ2F0aW9uLm9uQ29tcGxldGVkLmFkZExpc3RlbmVyKHRoaXMub25Db21wbGV0ZWQsIFdFQk5BVklHQVRJT05fVVJMX0ZJTFRFUik7XHJcblx0XHR3ZWJOYXZpZ2F0aW9uLm9uRXJyb3JPY2N1cnJlZC5hZGRMaXN0ZW5lcih0aGlzLm9uRXJyb3JPY2N1cnJlZCwgV0VCTkFWSUdBVElPTl9VUkxfRklMVEVSKTtcclxuXHJcblx0XHR3ZWJOYXZpZ2F0aW9uLm9uSGlzdG9yeVN0YXRlVXBkYXRlZC5hZGRMaXN0ZW5lcih0aGlzLm9uTG9jYXRpb25DaGFuZ2VkLCBXRUJOQVZJR0FUSU9OX1VSTF9GSUxURVIpO1xyXG5cdFx0d2ViTmF2aWdhdGlvbi5vblJlZmVyZW5jZUZyYWdtZW50VXBkYXRlZC5hZGRMaXN0ZW5lcih0aGlzLm9uTG9jYXRpb25DaGFuZ2VkLCBXRUJOQVZJR0FUSU9OX1VSTF9GSUxURVIpO1xyXG5cclxuXHRcdHRoaXMud2ViTmF2aWdhdGlvblRhYnNTdGF0ZXMudmFsaWRhdGVBbGxUYWJzKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IHJlcG9ydENhbGxiYWNrczogU2V0PFdlYk5hdmlnYXRpb25SZXBvcnRDYWxsYmFjaz4gPSBuZXcgU2V0PFdlYk5hdmlnYXRpb25SZXBvcnRDYWxsYmFjaz4oKTtcclxuXHJcblx0LyoqXHJcblx0ICogU3Vic2NyaWJlIHRvIGV2ZW50cy5cclxuXHQgKiBPbmx5IG9uZSBzdWJzY3JpcHRpb24gaXMgc3VwcG9ydGVkLlxyXG5cdCAqIElmIHdhcyBzdWJzY3JpYmVkIGJlZm9yZSwgbmV3IHN1YnNjcmlwdGlvbiBkb2Vzbid0IHJlcGxhY2Ugb2xkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIHRvIHJlY2VpdmUgYWxsIFdlYk5hdmlnYXRpb24gZXZlbnRzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBzdWJzY3JpYmUoY2FsbGJhY2s6IFdlYk5hdmlnYXRpb25SZXBvcnRDYWxsYmFjayk6IHZvaWQge1xyXG5cdFx0aWYgKCF0aGlzLnJlcG9ydENhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XHJcblx0XHRcdHRoaXMucmVwb3J0Q2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgbGFzdCBzdWJzY3JpcHRpb24gaWYgYW55LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyB1bnN1YnNjcmliZShjYWxsYmFjazogV2ViTmF2aWdhdGlvblJlcG9ydENhbGxiYWNrKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5yZXBvcnRDYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xyXG5cdFx0XHR0aGlzLnJlcG9ydENhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEZyYW1lKHRhYklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IEZyYW1lU3RhdGUge1xyXG5cdFx0cmV0dXJuIHRoaXMud2ViTmF2aWdhdGlvblRhYnNTdGF0ZXMuZ2V0RnJhbWUoeyB0YWJJZDogdGFiSWQsIGZyYW1lSWQ6IGZyYW1lSWQgfSk7XHJcblx0fVxyXG5cclxuXHQvLyAjcmVnaW9uIFV0aWxpdHkgZnVuY3Rpb25zXHJcblxyXG5cdHByaXZhdGUgYWRkRnJhbWUoZGV0YWlsczogUmVhZG9ubHk8d2ViTmF2aWdhdGlvbi5XZWJOYXZpZ2F0aW9uUGFyZW50ZWRDYWxsYmFja0RldGFpbHM+KTogRnJhbWVTdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpcy53ZWJOYXZpZ2F0aW9uVGFic1N0YXRlcy5hZGRGcmFtZShcclxuXHRcdFx0ZGV0YWlscy50YWJJZCxcclxuXHRcdFx0ZGV0YWlscy5mcmFtZUlkLFxyXG5cdFx0XHRkZXRhaWxzLnVybCxcclxuXHRcdFx0Z2V0RnJhbWVUeXBlKGRldGFpbHMuZnJhbWVJZCksXHJcblx0XHRcdFwiXCIpO1xyXG5cdH1cclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG5cclxuXHQvLyAjcmVnaW9uIEhhbmRsZXJzXHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25DcmVhdGVkTmF2aWdhdGlvblRhcmdldCA9IChkZXRhaWxzOiB3ZWJOYXZpZ2F0aW9uLldlYk5hdmlnYXRpb25Tb3VyY2VDYWxsYmFja0RldGFpbHMpID0+IHtcclxuXHRcdGdldExvZ2dlcigpLmRlYnVnKFwiV2ViTmF2aWdhdGlvbi5vbkNyZWF0ZWROYXZpZ2F0aW9uVGFyZ2V0XCIsIGRldGFpbHMpO1xyXG5cclxuXHRcdHRoaXMucmVwb3J0Q2FsbGJhY2tzLmZvckVhY2gocmVwb3J0Q2FsbGJhY2sgPT4gcmVwb3J0Q2FsbGJhY2soXCJDcmVhdGVOYXZpZ2F0aW9uVGFyZ2V0XCIsIGRldGFpbHMpKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25CZWZvcmVOYXZpZ2F0ZSA9IChkZXRhaWxzOiB3ZWJOYXZpZ2F0aW9uLldlYk5hdmlnYXRpb25QYXJlbnRlZENhbGxiYWNrRGV0YWlscykgPT4ge1xyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJXZWJOYXZpZ2F0aW9uLm9uQmVmb3JlTmF2aWdhdGVcIiwgZGV0YWlscyk7XHJcblxyXG5cdFx0Ly8gR2V0IGZyYW1lIHN0YXRlXHJcblx0XHRsZXQgZnJhbWVTdGF0ZSA9IHRoaXMud2ViTmF2aWdhdGlvblRhYnNTdGF0ZXMuZ2V0RnJhbWUoZGV0YWlscyk7XHJcblxyXG5cdFx0Ly8gTm8gZnJhbWUgc3RhdGUgLT4gQ3JlYXRlIGEgbmV3IG9uZVxyXG5cdFx0aWYgKGZyYW1lU3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHRmcmFtZVN0YXRlID0gdGhpcy5hZGRGcmFtZShkZXRhaWxzKTtcclxuXHJcblx0XHRcdC8vIFJlbW92ZSBpbnN0YW50IHRhYnNcclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB0aGlzLndlYk5hdmlnYXRpb25UYWJzU3RhdGVzLnZhbGlkYXRlVGFiKGRldGFpbHMudGFiSWQpLCA2MCAqIDEwMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gUmVtb3ZlIGFuZCBhZGQgYSBuZXcgb25lXHJcblx0XHRcdHRoaXMud2ViTmF2aWdhdGlvblRhYnNTdGF0ZXMucmVtb3ZlRnJhbWUoZGV0YWlscy50YWJJZCwgZGV0YWlscy5mcmFtZUlkKTtcclxuXHRcdFx0ZnJhbWVTdGF0ZSA9IHRoaXMuYWRkRnJhbWUoZGV0YWlscyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSW5pdGlhbCB2YWx1ZXMgd2hlbiBzdGFydGluZyBuYXZpZ2F0aW9uIC0gdGhlc2Ugd2lsbCBiZSB1cGRhdGVkIGFsb25nIHRoZSB3YXlcclxuXHRcdGZyYW1lU3RhdGUuY3VycmVudFVybCA9IGRldGFpbHMudXJsO1xyXG5cclxuXHRcdHRoaXMucmVwb3J0RXZlbnQoXCJCZWZvcmVOYXZpZ2F0ZVwiLCBkZXRhaWxzKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25Db21taXR0ZWQgPSAoZGV0YWlsczogd2ViTmF2aWdhdGlvbi5XZWJOYXZpZ2F0aW9uVHJhbnNpdGlvbkNhbGxiYWNrRGV0YWlscykgPT4ge1xyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJvbkNvbW1pdHRlZFwiLCBkZXRhaWxzKTtcclxuXHJcblx0XHRjb25zdCBmcmFtZVN0YXRlID0gdGhpcy53ZWJOYXZpZ2F0aW9uVGFic1N0YXRlcy5nZXRGcmFtZShkZXRhaWxzKTtcclxuXHRcdGlmIChmcmFtZVN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0Ly8gVXBkYXRlIGN1cnJlbnQgdXJsXHJcblx0XHRcdGZyYW1lU3RhdGUuY3VycmVudFVybCA9IGRldGFpbHMudXJsO1xyXG5cclxuXHRcdFx0Ly8gVGhlIFVSTCB0byB3aGljaCB0aGUgZ2l2ZW4gZnJhbWUgd2lsbCBuYXZpZ2F0ZS5cclxuXHRcdFx0ZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgPSBkZXRhaWxzLnVybDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiRnJhbWUgc3RhdGUgaXMgbnVsbCBmb3IgdGFiOiBcIiwgZGV0YWlscy50YWJJZCwgXCJmcmFtZTogXCIsIGRldGFpbHMuZnJhbWVJZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5yZXBvcnRFdmVudChcIkNvbW1pdHRlZFwiLCBkZXRhaWxzKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlU2hhcnBlciBkaXNhYmxlIG9uY2UgSW5jb25zaXN0ZW50TmFtaW5nXHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25ET01Db250ZW50TG9hZGVkID0gKGRldGFpbHM6IHdlYk5hdmlnYXRpb24uV2ViTmF2aWdhdGlvbkZyYW1lZENhbGxiYWNrRGV0YWlscykgPT4ge1xyXG5cdFx0dGhpcy5yZXBvcnRFdmVudChcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZGV0YWlscyk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uQ29tcGxldGVkID0gKGRldGFpbHM6IHdlYk5hdmlnYXRpb24uV2ViTmF2aWdhdGlvbkZyYW1lZENhbGxiYWNrRGV0YWlscykgPT4ge1xyXG5cdFx0dGhpcy5yZXBvcnRFdmVudChcIkNvbXBsZXRlZFwiLCBkZXRhaWxzKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25FcnJvck9jY3VycmVkID0gKGRldGFpbHM6IHdlYk5hdmlnYXRpb24uV2ViTmF2aWdhdGlvbkZyYW1lZEVycm9yQ2FsbGJhY2tEZXRhaWxzKSA9PiB7XHJcblx0XHR0aGlzLnJlcG9ydEV2ZW50KFwiRXJyb3JPY2N1cnJlZFwiLCBkZXRhaWxzKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25Mb2NhdGlvbkNoYW5nZWQgPSAoZGV0YWlsczogd2ViTmF2aWdhdGlvbi5XZWJOYXZpZ2F0aW9uVHJhbnNpdGlvbkNhbGxiYWNrRGV0YWlscykgPT4ge1xyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoXCJXZWJOYXZpZ2F0aW9uLm9uTG9jYXRpb25DaGFuZ2VkXCIsIGRldGFpbHMpO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRGcmFtZSA9IHRoaXMud2ViTmF2aWdhdGlvblRhYnNTdGF0ZXMuZ2V0RnJhbWUoZGV0YWlscyk7XHJcblxyXG5cdFx0aWYgKGN1cnJlbnRGcmFtZSA9PSBudWxsKSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiRnJhbWUgZG9lcyBub3QgZXhpc3QgaW4gdGFiIHN0YXRlc1wiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN1cnJlbnRGcmFtZS5jdXJyZW50VXJsID0gZGV0YWlscy51cmw7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlcG9ydEV2ZW50KFxyXG5cdFx0ZXZlbnQ6IFdlYk5hdmlnYXRpb25FdmVudCxcclxuXHRcdGRldGFpbHM6IHdlYk5hdmlnYXRpb24uV2ViTmF2aWdhdGlvbkZyYW1lZENhbGxiYWNrRGV0YWlscyk6IHZvaWQge1xyXG5cdFx0Z2V0TG9nZ2VyKCkuZGVidWcoYFdlYk5hdmlnYXRpb24ub24ke2V2ZW50fWAsIGRldGFpbHMpO1xyXG5cclxuXHRcdGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLndlYk5hdmlnYXRpb25UYWJzU3RhdGVzLmdldEZyYW1lKGRldGFpbHMpO1xyXG5cdFx0Y29uc3QgdGFiU3RhdGUgPSB0aGlzLndlYk5hdmlnYXRpb25UYWJzU3RhdGVzLmdldFRhYihkZXRhaWxzLnRhYklkKTtcclxuXHJcblx0XHR0aGlzLnJlcG9ydENhbGxiYWNrcy5mb3JFYWNoKHJlcG9ydENhbGxiYWNrID0+IHJlcG9ydENhbGxiYWNrKGV2ZW50LCBkZXRhaWxzLCBmcmFtZVN0YXRlLCB0YWJTdGF0ZSkpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSByZWFkb25seSBvblJlbW92ZWQgPSAodGFiSWQ6IG51bWJlcikgPT4ge1xyXG5cdFx0dGhpcy53ZWJOYXZpZ2F0aW9uVGFic1N0YXRlcy5yZW1vdmVUYWIodGFiSWQpO1xyXG5cdH1cclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IHN0YXJ0c1dpdGggfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcclxuXHJcbi8vIGltcG9ydCB7IGNocm9tZSB9IGZyb20gXCIuLi9jb21tb24vZ2xvYmFsQ2hyb21lXCI7XHJcblxyXG5mdW5jdGlvbiBtYWtlSGFzaCh0YWJJZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdHJldHVybiB0YWJJZC50b1N0cmluZygpICsgXCIsXCIgKyBmcmFtZUlkLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRhYklkRnJvbUhhc2goaGFzaDogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRjb25zdCBjb21tYUlkeCA9IGhhc2guaW5kZXhPZihcIixcIik7XHJcblx0Y29uc3QgdGFiSWRTdHIgPSBoYXNoLnN1YnN0cmluZygwLCBjb21tYUlkeCk7XHJcblx0cmV0dXJuIE51bWJlcih0YWJJZFN0cik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZyYW1lVXJsKCk6IHN0cmluZyB7XHJcblx0cmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xyXG59XHJcblxyXG4vKipcclxuICogTWFpbiBmcmFtZSBvciBzdWIgZnJhbWUgc3RhdGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRnJhbWVTdGF0ZSB7XHJcblx0LyoqXHJcblx0ICogTmF2aWdhdGlvbiB1cmwgb2YgdGhlIGZyYW1lLlxyXG5cdCAqIFNldCBieSB0aGUgZmlyc3QgbmF2aWdhdGlvbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgcmVhZG9ubHkgc3RhcnRVcmw6IHN0cmluZztcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBmcmFtZSdzIGlkLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWFkb25seSBmcmFtZUlkOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgY29udGFpbmluZyB0YWIncyBpZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgcmVhZG9ubHkgdGFiSWQ6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcblx0ICogQ3VycmVudCB1cmwgb2YgdGhlIGZyYW1lLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjdXJyZW50VXJsOiBzdHJpbmc7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBmaW5hbCBjb21taXR0ZWQgdXJsIHRoYXQgdGhlIGZyYW1lIGlzIG5hdmlnYXRpbmcgdG8uXHJcblx0ICogVW5kZWZpbmVkIGluIHRoZSBiZWdpbm5pbmcgb2YgbmF2aWdhdGlvbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgY29tbWl0dGVkVXJsPzogc3RyaW5nO1xyXG5cclxuXHQvKiogY2hyb21lLndlYlJlcXVlc3QuQ2FsbGJhY2tEZXRhaWxzLnR5cGUgKi9cclxuXHRwdWJsaWMgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xyXG5cclxuXHRwdWJsaWMgcmVhZG9ubHkgcmVxdWVzdElkOiBzdHJpbmc7XHJcblxyXG5cdHB1YmxpYyBzdGF0dXNDb2RlPzogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGZyYW1lSWQ6IG51bWJlcixcclxuXHRcdHRhYklkOiBudW1iZXIsXHJcblx0XHR1cmw6IHN0cmluZyxcclxuXHRcdHR5cGU6IHN0cmluZyxcclxuXHRcdHJlcXVlc3RJZDogc3RyaW5nKSB7XHJcblx0XHR0aGlzLmZyYW1lSWQgPSBmcmFtZUlkO1xyXG5cdFx0dGhpcy50YWJJZCA9IHRhYklkO1xyXG5cdFx0dGhpcy5zdGFydFVybCA9IHVybDtcclxuXHRcdHRoaXMuY3VycmVudFVybCA9IHVybDtcclxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcclxuXHR9XHJcbn1cclxuXHJcbmludGVyZmFjZSBGcmFtZXMge1xyXG5cdFtoYXNoOiBzdHJpbmddOiBGcmFtZVN0YXRlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVGFic1N0YXRlcyB7XHJcblx0cHJpdmF0ZSBmcmFtZXM6IEZyYW1lcztcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHR0aGlzLmZyYW1lcyA9IHt9O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZEZyYW1lKFxyXG5cdFx0dGFiSWQ6IG51bWJlcixcclxuXHRcdGZyYW1lSWQ6IG51bWJlcixcclxuXHRcdHVybDogc3RyaW5nLFxyXG5cdFx0dHlwZTogc3RyaW5nLFxyXG5cdFx0cmVxdWVzdElkOiBzdHJpbmcpOiBGcmFtZVN0YXRlIHtcclxuXHJcblx0XHRjb25zdCBoYXNoID0gbWFrZUhhc2godGFiSWQsIGZyYW1lSWQpO1xyXG5cdFx0dGhpcy5mcmFtZXNbaGFzaF0gPSBuZXcgRnJhbWVTdGF0ZShmcmFtZUlkLCB0YWJJZCwgdXJsLCB0eXBlLCByZXF1ZXN0SWQpO1xyXG5cdFx0Y29uc3QgZnJhbWUgPSB0aGlzLmZyYW1lc1toYXNoXTtcclxuXHJcblx0XHRyZXR1cm4gZnJhbWU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0VGFiKHRhYklkOiBudW1iZXIpOiBGcmFtZVN0YXRlIHtcclxuXHRcdHJldHVybiB0aGlzLmdldEZyYW1lKHsgdGFiSWQ6IHRhYklkLCBmcmFtZUlkOiAwIH0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEZyYW1lKFxyXG5cdFx0e3RhYklkLCBmcmFtZUlkLCB1cmwgPSBcIlwifTogeyB0YWJJZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIsIHVybD86IHN0cmluZyB8IG51bGwgfSk6IEZyYW1lU3RhdGUge1xyXG5cclxuXHRcdGxldCBmcmFtZSA9IHRoaXMuZnJhbWVzW21ha2VIYXNoKHRhYklkLCBmcmFtZUlkKV07XHJcblxyXG5cdFx0aWYgKGZyYW1lID09IG51bGwpIHtcclxuXHRcdFx0Ly8gVGhpcyBjYW4gYmUgYSB2YWxpZCBzdGF0ZTogdGhlIGV4dGVuc2lvbiBpcyBsb2FkZWQgaW4gcGFyYWxsZWwgd2l0aCB0aGUgcGFnZXMsXHJcblx0XHRcdC8vIGFuZCBzb21ldGltZXMgKGluIHBhcnRpY3VsYXIgd2hlbiB1cmwgaXMgZ2l2ZW4gb24gdGhlIGNvbW1hbmQgbGluZSkgaXRcclxuXHRcdFx0Ly8gZmluaXNoZXMgbG9hZGluZyBhZnRlciBzb21lIGZyYW1lcyBhbmQgdGhpcy5mcmFtZXNbXSBpcyBpbmNvbXBsZXRlLlxyXG5cdFx0XHQvLyBXZSBhZGQgdGhlIG1pc3NpbmcgZnJhbWUgbGF6aWx5LCBoZXJlLlxyXG5cclxuXHRcdFx0aWYgKHVybCAhPSBudWxsICYmIHVybCAhPT0gXCJcIikgeyAvLyB1c2UgdGhlIGlucHV0IGRldGFpbHNcclxuXHRcdFx0XHRmcmFtZSA9IHRoaXMuYWRkRnJhbWUodGFiSWQsIGZyYW1lSWQsIHVybCwgXCJ1bmtub3duXCIsIFwiXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNocm9tZS5zY3JpcHRpbmcuZXhlY3V0ZVNjcmlwdChcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB7dGFiSWQ6IHRhYklkLCBhbGxGcmFtZXM6IGZhbHNlLCBmcmFtZUlkczogW2ZyYW1lSWRdfSxcclxuXHRcdFx0XHRcdFx0ZnVuYzogZ2V0RnJhbWVVcmxcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHQocmVzdWx0cykgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBUaGVyZSBhcmUgdmFsaWQgc2NlbmFyaW9zIHdoZXJlIGdldEZyYW1lIGlzIGNhbGxlZCBmb3IgYSBjbG9zZWQgdGFiLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGZvciBleGFtcGxlIHdoZW4gYW4gYWpheCBpcyBjYW5jZWxsZWQgZHVyaW5nIHRhYiBjbG9zaW5nOlxyXG5cdFx0XHRcdFx0XHRcdC8vIFdlYlJlcXVlc3Qub25FcnJvck9jY3VyZWQgLT4gaXNNb25pdG9yZWQgLT4gdGFiU3RhdGVzLmdldFRhYiAtPiBnZXRGcmFtZVxyXG5cdFx0XHRcdFx0XHRcdC8vIFdlIHRyeSB0byBsb2cgb25seSBlcnJvcnMgZnJvbSB1bmV4cGVjdGVkIHNjZW5hcmlvcy5cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlID09PSBcIlRoZSBmcmFtZSB3YXMgcmVtb3ZlZC5cIiB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRzV2l0aChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSEsIFwiTm8gZnJhbWUgd2l0aCBpZFwiKSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRzV2l0aChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSEsIFwiTm8gdGFiIHdpdGggaWRcIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjsgIC8vIGZyYW1lIG51bGwgd2lsbCBiZSByZXR1cm5lZFxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcImNocm9tZS50YWJzLmV4ZWN1dGVTY3JpcHQgZmFpbGVkIGluIHRhYklkXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRhYklkLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlc3VsdHMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuYWRkRnJhbWUodGFiSWQsIGZyYW1lSWQsIHJlc3VsdHNbMF0ucmVzdWx0IGFzIHVua25vd24gYXMgc3RyaW5nLCBcInVua25vd25cIiwgXCJcIik7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJjaHJvbWUuc2NyaXB0aW5nLmV4ZWN1dGVTY3JpcHQgcmV0dXJuZWQgZW1wdHlcIik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZyYW1lO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEFsbFRhYklkcygpOiBudW1iZXJbXSB7XHJcblx0XHRsZXQgdGFiSURzOiBudW1iZXJbXSA9IFtdO1xyXG5cdFx0Y2hyb21lLnRhYnMucXVlcnkoe30sXHJcblx0XHRcdChyZXNUYWJzOiBjaHJvbWUudGFicy5UYWJbXSkgPT4ge1xyXG5cdFx0XHRcdGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoYGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcjogJHtjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZX1gKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW5vbi1udWxsLWFzc2VydGlvblxyXG5cdFx0XHRcdHRhYklEcyA9IHJlc1RhYnMuZmlsdGVyKHRhYiA9PiB0YWIuaWQgIT09IG51bGwpLm1hcCh0YWIgPT4gdGFiLmlkISk7XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0XHRyZXR1cm4gdGFiSURzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZURlYWRGcmFtZXMoKTogdm9pZCB7XHJcblx0XHRjb25zdCBsaXZlVGFiSWRzID0gdGhpcy5nZXRBbGxUYWJJZHMoKTtcclxuXHJcblx0XHQvLyBJdGVyYXRlIG9uIGFsbCBmcmFtZXMgYW5kIHJlbW92ZSB0aG9zZSBpbiBkZWFkIHRhYklkJ3NcclxuXHRcdE9iamVjdC5rZXlzKHRoaXMuZnJhbWVzKS5mb3JFYWNoKGhhc2ggPT4ge1xyXG5cdFx0XHRjb25zdCBmcmFtZSA9IHRoaXMuZnJhbWVzW2hhc2hdO1xyXG5cdFx0XHRpZiAobGl2ZVRhYklkcy5pbmRleE9mKGZyYW1lLnRhYklkKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5mcmFtZXNbaGFzaF07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEZyYW1lc0J5V2luZG93VXJsKHdpbmRvd1VybDogc3RyaW5nKTogRnJhbWVTdGF0ZVtdIHtcclxuXHRcdGNvbnN0IGZyYW1lczogRnJhbWVTdGF0ZVtdID0gW107XHJcblxyXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy5mcmFtZXMpIHtcclxuXHRcdFx0Y29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVzW2tleV07XHJcblx0XHRcdGlmIChmcmFtZVN0YXRlLmNvbW1pdHRlZFVybCA9PT0gd2luZG93VXJsKSB7XHJcblx0XHRcdFx0ZnJhbWVzLnB1c2goZnJhbWVTdGF0ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnJhbWVzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZVRhYih0YWJJZDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBJdGVyYXRlIG9uIGFsbCBmcmFtZXMgYW5kIHJlbW92ZSB0aG9zZSB3aXRoIHRoZSBnaXZlbiB0YWJJZFxyXG5cdFx0T2JqZWN0LmtleXModGhpcy5mcmFtZXMpLmZvckVhY2goaGFzaCA9PiB7XHJcblx0XHRcdGNvbnN0IGZyYW1lID0gdGhpcy5mcmFtZXNbaGFzaF07XHJcblx0XHRcdGlmIChmcmFtZS50YWJJZCA9PT0gdGFiSWQpIHtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5mcmFtZXNbaGFzaF07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbW92ZUZyYW1lKHRhYklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKGZyYW1lSWQgPT09IDApIHtcclxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBlbnRpcmUgdGFiXHJcblx0XHRcdHRoaXMucmVtb3ZlVGFiKHRhYklkKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJlbW92ZUhhc2ggPSBtYWtlSGFzaCh0YWJJZCwgZnJhbWVJZCk7XHJcblx0XHQvLyBSZW1vdmUgdGhlIGZyYW1lXHJcblx0XHRkZWxldGUgdGhpcy5mcmFtZXNbcmVtb3ZlSGFzaF07XHJcblx0fVxyXG5cclxuXHJcblx0cHVibGljIGhhc1RhYih0YWJJZDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNGcmFtZSh0YWJJZCwgMCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaGFzRnJhbWUodGFiSWQ6IG51bWJlciwgZnJhbWVJZDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gbWFrZUhhc2godGFiSWQsIGZyYW1lSWQpIGluIHRoaXMuZnJhbWVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXIgdGhlIHN0YXRlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuXHRcdHRoaXMuZnJhbWVzID0ge307XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdmFsaWRhdGVUYWIodGFiSWQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y2hyb21lLnRhYnMuZ2V0KHRhYklkLCB0YWIgPT4ge1xyXG5cdFx0XHQvLyBJZiB0YWIgZG9lc24ndCBleGlzdCB3ZSBoYXZlIGFuIGVycm9yLlxyXG5cdFx0XHQvLyBJdCBtZWFucyB0aGF0IHRoaXMgdGFiIGlzIG5vdCByZWFsIGFuZCB1c2VkIGZvciBpbnN0YW50IHNlYXJjaC5cclxuXHRcdFx0aWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvciAhPSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy5yZW1vdmVUYWIodGFiSWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB2YWxpZGF0ZUFsbFRhYnMoKTogdm9pZCB7XHJcblx0XHRmb3IgKGNvbnN0IGhhc2ggaW4gdGhpcy5mcmFtZXMpIHtcclxuXHRcdFx0Y29uc3QgdGFiSWQgPSB0YWJJZEZyb21IYXNoKGhhc2gpO1xyXG5cdFx0XHR0aGlzLnZhbGlkYXRlVGFiKHRhYklkKTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxzL2xvZ1wiO1xyXG5pbXBvcnQgeyBzZW5kTWVzc2FnZVRvVGFiLCBleGVjdXRlRnVuY3Rpb25JblRhYiB9IGZyb20gXCIuL3RhYnNcIjtcclxuaW1wb3J0IHsgSUJhY2tncm91bmRNYW5hZ2VyIH0gZnJvbSBcIi4vSUJhY2tncm91bmRNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IElBZ2VudENvbW11bmljYXRpb24gfSBmcm9tIFwiLi9JQWdlbnRDb21tdW5pY2F0aW9uXCI7XHJcbmltcG9ydCB7IElUYWJFdmVudERhdGEsIElUYWJzTW9uaXRvcmluZyB9IGZyb20gXCIuL0lUYWJzTW9uaXRvcmluZ1wiO1xyXG5pbXBvcnQgeyB0aW1lUHJvdmlkZXIgfSBmcm9tIFwiLi4vdXRpbHMvdGltZVByb3ZpZGVyXCI7XHJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xyXG5pbXBvcnQge1xyXG5cdE91dGdvaW5nRXZlbnRNZXNzYWdlLFxyXG5cdENocm9tZURvY3VtZW50VGl0bGVSZXF1ZXN0LFxyXG5cdENocm9tZUNvbnRlbnRNZXNzYWdlVHlwZSxcclxuXHRDaHJvbWVEb2N1bWVudFRpdGxlUmVzcG9uc2UsXHJcblx0Q2hyb21lRG9jdW1lbnRUaXRsZVVwZGF0ZVxyXG5cdH0gZnJvbSBcIi4uL2NvbW1vbi9NZXNzYWdpbmdNb2RlbFwiO1xyXG5cclxuaW1wb3J0IFRhYiA9IGNocm9tZS50YWJzLlRhYjtcclxuXHJcbmV4cG9ydCBjbGFzcyBUYWJzTW9uaXRvcmluZyBpbXBsZW1lbnRzIElUYWJzTW9uaXRvcmluZyB7XHJcblx0cHVibGljIHN0YXRpYyByZWFkb25seSBUQUJfRVZFTlRfTkFNRVNQQUNFID0gXCJ1aTpjaHJvbWU6VGFiXCI7XHJcblxyXG5cdHByaXZhdGUgbWFuYWdlcj86IElCYWNrZ3JvdW5kTWFuYWdlcjtcclxuXHRwcml2YXRlIGNvbW11bmljYXRpb24/OiBJQWdlbnRDb21tdW5pY2F0aW9uO1xyXG5cclxuXHQvLyAjcmVnaW9uIFV0aWxpdHlcclxuXHJcblx0cHJpdmF0ZSBtYWtlRXZlbnROYW1lKGV2ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFRhYnNNb25pdG9yaW5nLlRBQl9FVkVOVF9OQU1FU1BBQ0UgKyBcIi5cIiArIGV2ZW50O1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBnbG9iYWxUYWJzU3RhdGVzOiB7IFt0YWJJZDogbnVtYmVyXTogSVRhYkV2ZW50RGF0YTsgfSA9IHt9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYmFzZSB0YWIgbWVzc2FnZS5cclxuXHQgKi9cclxuXHRwcml2YXRlIGNyZWF0ZURhdGFNZXNzYWdlKGV2ZW50OiBzdHJpbmcsIHRhYklkOiBudW1iZXIsIHRpbWVzdGFtcDogbnVtYmVyID0gdGltZVByb3ZpZGVyLm5vdygpKTpcclxuXHRcdE91dGdvaW5nRXZlbnRNZXNzYWdlPElUYWJFdmVudERhdGE+IHtcclxuXHJcblx0XHRjb25zdCBtZXNzYWdlID0gbmV3IE91dGdvaW5nRXZlbnRNZXNzYWdlPElUYWJFdmVudERhdGE+KHRoaXMubWFrZUV2ZW50TmFtZShldmVudCksIHRpbWVzdGFtcCk7XHJcblxyXG5cdFx0Y29uc3QgdGFiU3RhdGUgPSB0aGlzLmdsb2JhbFRhYnNTdGF0ZXNbdGFiSWRdO1xyXG5cdFx0Y29uc3QgbWVzc2FnZURhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblxyXG5cdFx0bWVzc2FnZURhdGEudGFiSWQgPSB0YWJJZDtcclxuXHRcdG1lc3NhZ2VEYXRhLnRpdGxlID0gdGFiU3RhdGUudGl0bGU7XHJcblx0XHRpZiAodGFiU3RhdGUuc3RhdHVzICE9IG51bGwpIHtcclxuXHRcdFx0bWVzc2FnZURhdGEuc3RhdHVzID0gdGFiU3RhdGUuc3RhdHVzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRhYlN0YXRlLmN1cnJlbnRVcmwgIT0gbnVsbCkge1xyXG5cdFx0XHRtZXNzYWdlRGF0YS5jdXJyZW50VXJsID0gdGFiU3RhdGUuY3VycmVudFVybDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWVzc2FnZTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYWRkVGFiKHRhYjogVGFiKTogdm9pZCB7XHJcblx0XHRjb25zdCB0YWJJZCA9IHRhYi5pZDtcclxuXHRcdGlmICh0YWJJZCA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0aXRsZSA9IHRhYi50aXRsZSAhPSBudWxsID8gdGFiLnRpdGxlIDogXCJcIjtcclxuXHRcdHRoaXMuZ2xvYmFsVGFic1N0YXRlc1t0YWJJZF0gPSB7XHJcblx0XHRcdGN1cnJlbnRVcmw6IHRhYi51cmwsXHJcblx0XHRcdHRhYklkOiB0YWJJZCxcclxuXHRcdFx0d2luZG93SWQ6IHRhYi53aW5kb3dJZCxcclxuXHRcdFx0dGl0bGU6IHRpdGxlLFxyXG5cdFx0XHRkb2N1bWVudFRpdGxlOiB0aXRsZVxyXG5cdFx0fTtcclxuXHRcdGlmICh0YWIuc3RhdHVzICE9IG51bGwpIHtcclxuXHRcdFx0dGhpcy5nbG9iYWxUYWJzU3RhdGVzW3RhYklkXS5zdGF0dXMgPSB0YWIuc3RhdHVzO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhZGRUYWJJZkRvZXNudEV4aXN0cyh0YWJJZDogbnVtYmVyLCB0YWI6IFRhYik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMuZ2xvYmFsVGFic1N0YXRlc1t0YWJJZF0gPT0gbnVsbCkge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5sb2coXCJBZGRpbmcgdGFiOiBcIiwgdGFiKTtcclxuXHRcdFx0dGhpcy5hZGRUYWIodGFiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vICNlbmRyZWdpb25cclxuXHJcblx0Ly8gI3JlZ2lvbiBFeHBvcnRlZCBwcml2YXRlc1xyXG5cclxuXHQvKipcclxuXHQgKiBAcGFyYW0gdGFiSWQgVGFiIGlkZW50aWZpZXJcclxuXHQgKiBAcmV0dXJuIFRhYiBzdGF0ZS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0VGFiU3RhdGUodGFiSWQ6IG51bWJlcik6IElUYWJFdmVudERhdGEgfCBudWxsIHtcclxuXHRcdGNvbnN0IHRhYlN0YXRlID0gdGhpcy5nbG9iYWxUYWJzU3RhdGVzW3RhYklkXTtcclxuXHRcdGlmICh0YWJTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdHJldHVybiB7Li4udGFiU3RhdGV9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYSBUYWIgU3RhdGUgb2JqZWN0IGFjY29yZGFudCB0byBzb21lIFRhYiBJRC5cclxuXHQgKiBAcGFyYW0gdGFiSWQgVGhlIElEIG9mIHRoZSBUYWIgd2hvc2UgVGFiIFN0YXRlIG9iamVjdCBpcyB0byBiZSBmZXRjaGVkIG9yIGNyZWF0ZWQuXHJcblx0ICogQHBhcmFtIGJyb3dzZXJUYWIgT3B0aW9uYWwgQnJvd3NlciBUYWIgb2JqZWN0LCB1c2VkIGluIHRoZSBjcmVhdGlvbiBvZiB0aGUgcmVxdWVzdGVkIFRhYiBTdGF0ZSBvYmplY3QuXHJcblx0ICogQHJldHVybiBQcm9taXNlIHRvIGRlbGl2ZXIgYSBUYWIgU3RhdGUgb2JqZWN0IG9yIGEgbnVsbCwgaWYgc3VjaCBvYmplY3QgZG9lcyBub3QgZXhpc3QgYW5kIHNob3VsZCBub3QgYmUgY3JlYXRlZC5cclxuXHQgKi9cclxuXHRwcml2YXRlIGdldE9yQ3JlYXRlVGFiU3RhdGVBc3luYyhcclxuXHRcdHRhYklkOiBudW1iZXIsXHJcblx0XHRicm93c2VyVGFiOiBjaHJvbWUudGFicy5UYWIgfCBudWxsID0gbnVsbCk6IFByb21pc2U8SVRhYkV2ZW50RGF0YSB8IG51bGw+IHtcclxuXHRcdGNvbnN0IHRhYkRhdGFQcm9taXNlID0gbmV3IFByb21pc2U8SVRhYkV2ZW50RGF0YSB8IG51bGw+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHRcdFx0Ly8gVGhpcyBpcyB0aGUgYm9keSBvZiB0aGUgb3V0cHV0IFByb21pc2UuXHJcblx0XHRcdGNvbnN0IHRhYlN0YXRlID0gdGhpcy5nbG9iYWxUYWJzU3RhdGVzW3RhYklkXTtcclxuXHRcdFx0aWYgKHRhYlN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0XHQvLyBUYWIgU3RhdGUgb2JqZWN0IHdpdGggdGhlIHJlcXVlc3RlZCBJRCBhbHJlYWR5IGV4aXN0cy5cclxuXHRcdFx0XHQvLyBSZXNvbHZlIHRoZSBQcm9taXNlIHdpdGggdGhlIGV4aXN0aW5nIFRhYiBTdGF0ZS5cclxuXHRcdFx0XHRyZXNvbHZlKHRhYlN0YXRlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBUYWIgU3RhdGUgb2JqZWN0IHdpdGggdGhlIHJlcXVlc3RlZCBJRCBkb2VzIG5vdCBleGlzdC5cclxuXHRcdFx0XHQvLyBBcyB0aGVyZSBpcyBubyBUYWIgU3RhdGUgb2JqZWN0IGFjY29yZGFudCB0byB0aGUgcmVxdWVzdGVkIFRhYiBJRCwgcmVzb2x2ZSB0aGUgb3V0cHV0IFByb21pc2Ugd2l0aCBudWxsLlxyXG5cdFx0XHRcdHJlc29sdmUobnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB0YWJEYXRhUHJvbWlzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhIGJyb3dzZXIgVGFiIG9iamVjdCBhY2NvcmRhbnQgdG8gc29tZSBUYWIgSUQuXHJcblx0ICogQHBhcmFtIHRhYklkIFRoZSBJRCBvZiB0aGUgVGFiIHdob3NlIGJyb3dzZXIgVGFiIG9iamVjdCBpcyB0byBiZSBmZXRjaGVkIG9yIGNyZWF0ZWQuXHJcblx0ICogQHJldHVybiBQcm9taXNlIHRvIGRlbGl2ZXIgYSBicm93c2VyIFRhYiBvYmplY3QuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBnZXRUYWIodGFiSWQ6IG51bWJlcik6IFByb21pc2U8Y2hyb21lLnRhYnMuVGFiPiB7XHJcblx0XHRjb25zdCBicm93c2VyVGFiUHJvbWlzZSA9IG5ldyBQcm9taXNlPGNocm9tZS50YWJzLlRhYj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBib2R5IG9mIHRoZSBQcm9taXNlLlxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNocm9tZS50YWJzLmdldCh0YWJJZCwgKGJyb3dzZXJUYWI6IGNocm9tZS50YWJzLlRhYikgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyB0aGUgYm9keSBvZiB0aGUgY2FsbGJhY2sgc3VwcGxpZWQgdG8gJ2Nocm9tZS50YWJzLmdldCcuXHJcblx0XHRcdFx0XHRpZiAoY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0Ly8gVGhlIGJyb3dzZXIgVGFiIG9iamVjdCBhY2NvcmRhbnQgdG8gdGhlIHJlcXVlc3RlZCBUYWIgSUQgaGFkIGJlZW4gZm91bmQuXHJcblx0XHRcdFx0XHRcdC8vIFJlc29sdmUgdGhlIFByb21pc2Ugd2l0aCB0aGF0IFRhYiBvYmplY3QuXHJcblx0XHRcdFx0XHRcdHJlc29sdmUoYnJvd3NlclRhYik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgaXMgbm8gYnJvd3NlciBUYWIgd2l0aCB0aGUgcmVxdWVzdGVkIFRhYiBJRC5cclxuXHRcdFx0XHRcdFx0Ly8gUmVqZWN0IHRoZSBQcm9taXNlLlxyXG5cdFx0XHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIk5vIEJyb3dzZXIgVGFiIG9iamVjdCBmb3IgVGFiIElELlwiLCB0YWJJZCwgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yKTtcclxuXHRcdFx0XHRcdFx0cmVqZWN0KGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdC8vIEV4Y2VwdGlvbiBvY2N1cmVkIGluIHRoZSBjYWxsIHRvICdjaHJvbWUudGFicy5nZXQnLlxyXG5cdFx0XHRcdC8vIFJlamVjdCB0aGUgUHJvbWlzZS5cclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkV4Y2VwdGlvbiB3aGlsZSBnZXR0aW5nIEJyb3dzZXIgVGFiIG9iamVjdC5cIiwgdGFiSWQsIGVycik7XHJcblx0XHRcdFx0cmVqZWN0KGVycik7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBicm93c2VyVGFiUHJvbWlzZTtcclxuXHR9XHJcblxyXG5cdC8vICNlbmRyZWdpb25cclxuXHJcblx0Ly8gI3JlZ2lvbiBIYW5kbGVyc1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uQ3JlYXRlZCA9ICh0YWI6IGNocm9tZS50YWJzLlRhYikgPT4ge1xyXG5cdFx0Y29uc3QgdGltZXN0YW1wID0gdGltZVByb3ZpZGVyLm5vdygpO1xyXG5cdFx0dGhpcy5vbkNyZWF0ZWRJbXBsKHRhYiwgdGltZXN0YW1wKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgb25DcmVhdGVkSW1wbCh0YWI6IGNocm9tZS50YWJzLlRhYiwgdGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm1hbmFnZXIgPT0gbnVsbCB8fCAhdGhpcy5tYW5hZ2VyLmFjdGl2ZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRnZXRMb2dnZXIoKS5sb2coXCJUYWIgb25DcmVhdGVkXCIsIHRhYi5pZCwgdGFiKTtcclxuXHRcdGlmICh0YWIuaWQgPT0gbnVsbCkge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihgTm8gdGFiLmlkIGZvciAke3RhYn1gKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZ2xvYmFsVGFic1N0YXRlc1t0YWIuaWRdO1xyXG5cdFx0dGhpcy5hZGRUYWIodGFiKTtcclxuXHJcblx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5jcmVhdGVEYXRhTWVzc2FnZShcIkNyZWF0ZWRcIiwgdGFiLmlkLCB0aW1lc3RhbXApO1xyXG5cdFx0aWYgKHRoaXMuY29tbXVuaWNhdGlvbiAhPSBudWxsKSB7XHJcblx0XHRcdHRoaXMuY29tbXVuaWNhdGlvbi5wb3N0TmF0aXZlTWVzc2FnZShtZXNzYWdlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25VcGRhdGVkID0gKHRhYklkOiBudW1iZXIsIGNoYW5nZUluZm86IGNocm9tZS50YWJzLlRhYkNoYW5nZUluZm8sIHRhYjogY2hyb21lLnRhYnMuVGFiKSA9PiB7XHJcblx0XHRpZiAodGhpcy5tYW5hZ2VyID09IG51bGwgfHwgIXRoaXMubWFuYWdlci5hY3RpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiVGFiIG9uVXBkYXRlZFwiLCB0YWJJZCwgY2hhbmdlSW5mbywgdGFiKTtcclxuXHRcdGlmICh0YWIuaWQgPT0gbnVsbCkge1xyXG5cdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihgTm8gdGFiLmlkIGZvciAke3RhYn1gKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSB0aXRsZSBpbiBjb250ZW50IHNjcmlwdFxyXG5cdFx0aWYgKHR5cGVvZiB0YWIudGl0bGUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0dGhpcy51cGRhdGVEb2N1bWVudFRpdGxlSW5GcmFtZXModGFiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGZXRjaCB0aGUgVGFiIFN0YXRlIG9iamVjdCBhc3luY2hyb25vdXNseSwgY3JlYXRlIGl0IGlmIG5lZWRlZC5cclxuXHRcdHRoaXMuZ2V0T3JDcmVhdGVUYWJTdGF0ZUFzeW5jKHRhYklkKVxyXG5cdFx0XHQudGhlbih0YWJTdGF0ZSA9PiB7XHJcblx0XHRcdFx0aWYgKHRhYlN0YXRlID09IG51bGwpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBjaGFuZ2VJbmZvLnRpdGxlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdFx0XHRnZXRMb2dnZXIoKS5sb2coYFRhYiBvblVwZGF0ZWQgcHJldmlvdXMgdGl0bGU6ICR7dGFiU3RhdGUudGl0bGV9LCBuZXcgdGl0bGU6ICR7Y2hhbmdlSW5mby50aXRsZX1gKTtcclxuXHRcdFx0XHRcdHRhYlN0YXRlLnRpdGxlID0gY2hhbmdlSW5mby50aXRsZTtcclxuXHJcblx0XHRcdFx0XHQvLyBTZXQgaW5pdGlhbCBkb2N1bWVudFRpdGxlIGFzIHRpdGxlLlxyXG5cdFx0XHRcdFx0Ly8gSXQgd2lsbCBiZSB1cGRhdGVkIGxhdGVyIGluIHRoZSB1cGRhdGVEb2N1bWVudFRpdGxlSW5GcmFtZXNcclxuXHRcdFx0XHRcdHRhYlN0YXRlLmRvY3VtZW50VGl0bGUgPSBjaGFuZ2VJbmZvLnRpdGxlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNoYW5nZUluZm8udXJsICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdHRhYlN0YXRlLmN1cnJlbnRVcmwgPSBjaGFuZ2VJbmZvLnVybDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGNoYW5nZUluZm8uc3RhdHVzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdC8vIElmIHdlIGdvdCBoZXJlIGZvbGxvd2luZyBhIHJlZnJlc2ggdGhlcmUncyBhbiBleGNlbGxlbnQgY2hhbmNlIHRoZSBjb250ZW50IHNjcmlwdFxyXG5cdFx0XHRcdFx0Ly8gaGFkbid0IGZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIGNvbmZpZyB5ZXQgYW5kIFRpdGxlTWFuYWdlciBpc24ndCBhdmFpbGFibGUuXHJcblx0XHRcdFx0XHQvLyBJdCBzdWZmaWNlcyB0byBkZWxheSB0aGUgbWVzc2FnZSBwYXNzaW5nIGEgYml0LiBJZiBzb21lIGRheSBpdCBkb2Vzbid0IC0gYWRkIHNvbWVcclxuXHRcdFx0XHRcdC8vICdDT05URU5UX1JFQURZJyBtZXNzYWdlLCBhbmQgZG8gdGhpcyBvbmx5IGFmdGVyd2FyZHMuXHJcblx0XHRcdFx0XHRpZiAoY2hhbmdlSW5mby5zdGF0dXMgPT09IFwiY29tcGxldGVcIikge1xyXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KFxyXG5cdFx0XHRcdFx0XHRcdCgpID0+IHRoaXMudXBkYXRlRG9jdW1lbnRUaXRsZUluRnJhbWVzKHRhYiksXHJcblx0XHRcdFx0XHRcdFx0MCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5jcmVhdGVEYXRhTWVzc2FnZShcIlVwZGF0ZWRcIiwgdGFiSWQpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQpXHJcblx0XHRcdC5jYXRjaChlcnIgPT4ge1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiRXJyb3Igd2hpbGUgZ2V0dGluZyBUYWIgU3RhdGUgb2JqZWN0IG9uIFRhYiBVcGRhdGUuXCIsIHRhYklkLCBlcnIpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25SZW1vdmVkID0gKHRhYklkOiBudW1iZXIsIHJlbW92ZUluZm86IGNocm9tZS50YWJzLlRhYlJlbW92ZUluZm8pID0+IHtcclxuXHRcdHRoaXMub25SZW1vdmVkSW1wbCh0YWJJZCwgcmVtb3ZlSW5mbywgdGltZVByb3ZpZGVyLm5vdygpKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgb25SZW1vdmVkSW1wbCh0YWJJZDogbnVtYmVyLCByZW1vdmVJbmZvOiBjaHJvbWUudGFicy5UYWJSZW1vdmVJbmZvLCB0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsIHx8ICF0aGlzLm1hbmFnZXIuYWN0aXZlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIlRhYiBvblJlbW92ZWRcIiwgdGFiSWQsIHJlbW92ZUluZm8pO1xyXG5cclxuXHRcdC8vIEZldGNoIHRoZSBUYWIgU3RhdGUgb2JqZWN0IGFzeW5jaHJvbm91c2x5LCBjcmVhdGUgaXQgaWYgbmVlZGVkLlxyXG5cdFx0dGhpcy5nZXRPckNyZWF0ZVRhYlN0YXRlQXN5bmModGFiSWQpXHJcblx0XHRcdC50aGVuKHRhYlN0YXRlID0+IHtcclxuXHRcdFx0XHRpZiAodGFiU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlRGF0YU1lc3NhZ2UoXCJSZW1vdmVkXCIsIHRhYklkLCB0aW1lc3RhbXApO1xyXG5cdFx0XHRcdFx0Y29uc3QgbWVzc2FnZURhdGEgPSBtZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblx0XHRcdFx0XHRtZXNzYWdlRGF0YS5pc1dpbmRvd0Nsb3NpbmcgPSByZW1vdmVJbmZvLmlzV2luZG93Q2xvc2luZztcclxuXHRcdFx0XHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2xvYmFsVGFic1N0YXRlc1t0YWJJZF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2F0Y2goZXJyID0+IHtcclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkVycm9yIHdoaWxlIGdldHRpbmcgVGFiIFN0YXRlIG9iamVjdCBvbiBUYWIgUmVtb3ZlLlwiLCB0YWJJZCwgZXJyKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uUmVwbGFjZWQgPSAoYWRkZWRUYWJJZDogbnVtYmVyLCByZW1vdmVkVGFiSWQ6IG51bWJlcikgPT4ge1xyXG5cdFx0Y29uc3QgdGltZXN0YW1wID0gdGltZVByb3ZpZGVyLm5vdygpO1xyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsIHx8ICF0aGlzLm1hbmFnZXIuYWN0aXZlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIlRhYiBvblJlcGxhY2VkXCIsIGFkZGVkVGFiSWQsIHJlbW92ZWRUYWJJZCk7XHJcblxyXG5cdFx0Ly8gUmVwbGFjZWQgaXMgbGlrZSByZW1vdmUgYW5kIHRoZW4gY3JlYXRlIHNvIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSBuZXcgZGF0YSBhbmQgcmVwb3J0XHJcblx0XHQvLyBBbmQgdGhlc2UgbXVzdCBiZSByZXBvcnRlZCBpbiB0aGlzIG9yZGVyIChyZW1vdmUgLT4gY3JlYXRlIC0+IHJlcGxhY2UpIGJlY2F1c2UgdGhlXHJcblx0XHQvLyBtZWFuaW5nIG9mIHJlcGxhY2UgaXMgdGhhdCB0aGVyZSB3YXMgYSByZW1vdmUgYW5kIHRoZW4gYSBjcmVhdGVcclxuXHRcdGNocm9tZS50YWJzLmdldChhZGRlZFRhYklkLFxyXG5cdFx0XHRhZGRlZFRhYiA9PiB7XHJcblx0XHRcdFx0Ly8gVGhpcyBpcyB0aGUgYm9keSBvZiB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBUYWIgYWNjb3JkYW50IHRvIHRoZVxyXG5cdFx0XHRcdC8vIGFkZGVkVGFiSWQgaXMgcmV0cmlldmVkLlxyXG5cdFx0XHRcdGNvbnN0IGFkZGVkVGFiT2JqZWN0RmV0Y2hlZCA9IGNocm9tZS5ydW50aW1lLmxhc3RFcnJvciA9PSBudWxsO1xyXG5cdFx0XHRcdC8vIEZldGNoIHRoZSByZW1vdmVkIFRhYiBTdGF0ZSBvYmplY3QgYXN5bmNocm9ub3VzbHksIGNyZWF0ZSBpdCBpZiBuZWVkZWQuXHJcblx0XHRcdFx0dGhpcy5nZXRPckNyZWF0ZVRhYlN0YXRlQXN5bmMocmVtb3ZlZFRhYklkKVxyXG5cdFx0XHRcdFx0LnRoZW4odGFiU3RhdGUgPT4ge1xyXG5cdFx0XHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBib2R5IG9mIHRoZSByZXNvbHZlIG9mIHRoZSBQcm9taXNlIHRoYXQgcmV0cmlldmVzIHRoZSBUYWIgU3RhdGVcclxuXHRcdFx0XHRcdFx0Ly8gb2JqZWN0IGFjY29yZGFudCB0byB0aGUgcmVtb3ZlZCBUYWIgSUQuXHJcblx0XHRcdFx0XHRcdGxldCByZXBsYWNlZE1lc3NhZ2U6IE91dGdvaW5nRXZlbnRNZXNzYWdlPElUYWJFdmVudERhdGE+IHwgdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0XHRpZiAoYWRkZWRUYWJPYmplY3RGZXRjaGVkICYmIHRhYlN0YXRlICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXBsYWNlZE1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiUmVwbGFjZWRcIiwgcmVtb3ZlZFRhYklkLCB0aW1lc3RhbXApO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1lc3NhZ2VEYXRhID0gcmVwbGFjZWRNZXNzYWdlLm1lc3NhZ2VEYXRhLkRhdGFbMF07XHJcblx0XHRcdFx0XHRcdFx0bWVzc2FnZURhdGEubmV3VGFiSWQgPSBhZGRlZFRhYklkO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBNdXN0IGZpcnN0IHJlcG9ydCByZW1vdmVkLCB0aGVuIGNyZWF0ZWQgYW5kIG9ubHkgYWZ0ZXIgYm90aCAtIHJlcGxhY2VkLlxyXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmVkIG11c3QgYmUgcmVwb3J0ZWQgYW55d2F5IC0gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBuZXcgdGFiSWQgZXhpc3RzIG9yIG5vdC5cclxuXHRcdFx0XHRcdFx0dGhpcy5vblJlbW92ZWRJbXBsKFxyXG5cdFx0XHRcdFx0XHRcdHJlbW92ZWRUYWJJZCxcclxuXHRcdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3dJZDogYWRkZWRUYWIud2luZG93SWQsIC8vIE9idmlvdXNseSB0aGV5J3JlIGluIHRoZSBzYW1lIHdpbmRvdy5cclxuXHRcdFx0XHRcdFx0XHRcdGlzV2luZG93Q2xvc2luZzogZmFsc2UgLy8gQmVjYXVzZSB0aGUgd2luZG93IGlzbid0IGNsb3Npbmcgd2hlbiBpdCdzIHJlcGxhY2UuXHJcblx0XHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XHR0aW1lc3RhbXApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGFkZGVkVGFiT2JqZWN0RmV0Y2hlZCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub25DcmVhdGVkSW1wbChhZGRlZFRhYiwgdGltZXN0YW1wKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBDb25kaXRpb25Jc0Fsd2F5c0NvbnN0XHJcblx0XHRcdFx0XHRcdGlmIChyZXBsYWNlZE1lc3NhZ2UgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKHJlcGxhY2VkTWVzc2FnZSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmNhdGNoKGVyciA9PiB7XHJcblx0XHRcdFx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiRXJyb3Igd2hpbGUgZ2V0dGluZyByZW1vdmVkIFRhYiBTdGF0ZSBvYmplY3Qgb24gVGFiIFJlcGxhY2UuXCIsIHJlbW92ZWRUYWJJZCwgZXJyKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25BY3RpdmF0ZWQgPSAoYWN0aXZlSW5mbzogY2hyb21lLnRhYnMuVGFiQWN0aXZlSW5mbykgPT4ge1xyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsIHx8ICF0aGlzLm1hbmFnZXIuYWN0aXZlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIlRhYiBvbkFjdGl2YXRlZFwiLCBhY3RpdmVJbmZvKTtcclxuXHJcblx0XHQvLyBGZXRjaCB0aGUgVGFiIFN0YXRlIG9iamVjdCBhc3luY2hyb25vdXNseSwgY3JlYXRlIGl0IGlmIG5lZWRlZC5cclxuXHRcdHRoaXMuZ2V0T3JDcmVhdGVUYWJTdGF0ZUFzeW5jKGFjdGl2ZUluZm8udGFiSWQpXHJcblx0XHRcdC50aGVuKHRhYlN0YXRlID0+IHtcclxuXHRcdFx0XHRpZiAodGFiU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlRGF0YU1lc3NhZ2UoXCJBY3RpdmF0ZWRcIiwgYWN0aXZlSW5mby50YWJJZCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gZml4aW5nIFdBQyBidWcgd2l0aCBmb2N1c1xyXG5cdFx0XHRcdFx0Y2hyb21lLnRhYnMuZ2V0KGFjdGl2ZUluZm8udGFiSWQsXHJcblx0XHRcdFx0XHRcdCh0YWI6IGNocm9tZS50YWJzLlRhYikgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGV4ZWN1dGVGdW5jdGlvbkluVGFiKHRhYiwgKCkgPT4geyB3aW5kb3cuZm9jdXMoKTsgfSwgXCJmb2N1c1wiKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2F0Y2goZXJyID0+IHtcclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkVycm9yIHdoaWxlIGdldHRpbmcgVGFiIFN0YXRlIG9iamVjdCBvbiBUYWIgQWN0aXZhdGlvbi5cIiwgYWN0aXZlSW5mby50YWJJZCwgZXJyKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uTW92ZWQgPSAodGFiSWQ6IG51bWJlciwgbW92ZUluZm86IGNocm9tZS50YWJzLlRhYk1vdmVJbmZvKSA9PiB7XHJcblx0XHRpZiAodGhpcy5tYW5hZ2VyID09IG51bGwgfHwgIXRoaXMubWFuYWdlci5hY3RpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiVGFiIG9uTW92ZWRcIiwgbW92ZUluZm8pO1xyXG5cclxuXHRcdC8vIEZldGNoIHRoZSBUYWIgU3RhdGUgb2JqZWN0IGFzeW5jaHJvbm91c2x5LCBjcmVhdGUgaXQgaWYgbmVlZGVkLlxyXG5cdFx0dGhpcy5nZXRPckNyZWF0ZVRhYlN0YXRlQXN5bmModGFiSWQpXHJcblx0XHRcdC50aGVuKHRhYlN0YXRlID0+IHtcclxuXHRcdFx0XHRpZiAodGFiU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlRGF0YU1lc3NhZ2UoXCJNb3ZlZFwiLCB0YWJJZCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGVyciA9PiB7XHJcblx0XHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJFcnJvciB3aGlsZSBnZXR0aW5nIFRhYiBTdGF0ZSBvYmplY3Qgb24gVGFiIE1vdmUuXCIsIHRhYklkLCBlcnIpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25BdHRhY2hlZCA9ICh0YWJJZDogbnVtYmVyLCBhdHRhY2hJbmZvOiBjaHJvbWUudGFicy5UYWJBdHRhY2hJbmZvKSA9PiB7XHJcblx0XHRpZiAodGhpcy5tYW5hZ2VyID09IG51bGwgfHwgIXRoaXMubWFuYWdlci5hY3RpdmUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiVGFiIG9uQXR0YWNoZWRcIiwgYXR0YWNoSW5mbyk7XHJcblxyXG5cdFx0Ly8gRmV0Y2ggdGhlIFRhYiBTdGF0ZSBvYmplY3QgYXN5bmNocm9ub3VzbHksIGNyZWF0ZSBpdCBpZiBuZWVkZWQuXHJcblx0XHR0aGlzLmdldE9yQ3JlYXRlVGFiU3RhdGVBc3luYyh0YWJJZClcclxuXHRcdFx0LnRoZW4odGFiU3RhdGUgPT4ge1xyXG5cdFx0XHRcdGlmICh0YWJTdGF0ZSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb25zdCBtZXNzYWdlID0gdGhpcy5jcmVhdGVEYXRhTWVzc2FnZShcIkF0dGFjaGVkXCIsIHRhYklkKTtcclxuXHRcdFx0XHRcdGlmICh0aGlzLmNvbW11bmljYXRpb24gIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2F0Y2goZXJyID0+IHtcclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5lcnJvcihcIkVycm9yIHdoaWxlIGdldHRpbmcgVGFiIFN0YXRlIG9iamVjdCBvbiBUYWIgQXR0YWNoLlwiLCB0YWJJZCwgZXJyKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uRGV0YWNoZWQgPSAodGFiSWQ6IG51bWJlciwgZGV0YWNoSW5mbzogY2hyb21lLnRhYnMuVGFiRGV0YWNoSW5mbykgPT4ge1xyXG5cdFx0aWYgKHRoaXMubWFuYWdlciA9PSBudWxsIHx8ICF0aGlzLm1hbmFnZXIuYWN0aXZlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIlRhYiBvbkRldGFjaGVkXCIsIGRldGFjaEluZm8pO1xyXG5cclxuXHRcdC8vIEZldGNoIHRoZSBUYWIgU3RhdGUgb2JqZWN0IGFzeW5jaHJvbm91c2x5LCBjcmVhdGUgaXQgaWYgbmVlZGVkLlxyXG5cdFx0dGhpcy5nZXRPckNyZWF0ZVRhYlN0YXRlQXN5bmModGFiSWQpXHJcblx0XHRcdC50aGVuKHRhYlN0YXRlID0+IHtcclxuXHRcdFx0XHRpZiAodGFiU3RhdGUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlRGF0YU1lc3NhZ2UoXCJEZXRhY2hlZFwiLCB0YWJJZCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGVyciA9PiB7XHJcblx0XHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJFcnJvciB3aGlsZSBnZXR0aW5nIFRhYiBTdGF0ZSBvYmplY3Qgb24gVGFiIERldGFjaC5cIiwgdGFiSWQsIGVycik7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gI2VuZHJlZ2lvblxyXG5cclxuXHQvKipcclxuXHQgKiBBc2sgZG9jdW1lbnQudGl0bGUgcHJvcGVydHkgZnJvbSB0b3AgZnJhbWUgYW5kIHB1Ymxpc2ggaXQgdG8gb3RoZXIgZnJhbWVzIGluIHRoZSB0YWIuXHJcblx0ICogVGhpcyB3YXkgd2UgYXJlIGJ5cGFzc2luZyB0aGUgY3Jvc3Mtc2l0ZSBkb21haW4gaXNzdWUuXHJcblx0ICovXHJcblx0cHJpdmF0ZSB1cGRhdGVEb2N1bWVudFRpdGxlSW5GcmFtZXModGFiOiBUYWIpOiB2b2lkIHtcclxuXHRcdGlmICh0YWIuaWQgPT0gbnVsbCB8fCB0YWIudGl0bGUgPT0gbnVsbCB8fCB0YWIudXJsID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFVdGlscy5zdGFydHNXaXRoKHRhYi51cmwsIFwiaHR0cFwiKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGRvY3VtZW50VGl0bGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcblx0XHQvLyBBc2sgZG9jdW1lbnRUaXRsZSBmcm9tIHRvcCBmcmFtZSAoZnJhbWVJZCA9IDApIGFuZCB0aGVuIHB1Ymxpc2ggaXQgdG8gYWxsIGZyYW1lcyBpbiB0YWIuXHJcblx0XHRjb25zdCBkb2N1bWVudFRpdGxlUmVxdWVzdDogQ2hyb21lRG9jdW1lbnRUaXRsZVJlcXVlc3QgPSB7XHJcblx0XHRcdG1lc3NhZ2VUeXBlOiBDaHJvbWVDb250ZW50TWVzc2FnZVR5cGUuRE9DVU1FTlRfVElUTEVfUkVRVUVTVFxyXG5cdFx0fTtcclxuXHJcblx0XHRnZXRMb2dnZXIoKS5sb2coYFJlcXVlc3RpbmcgZG9jdW1lbnQgdGl0bGUgZnJvbSB0YWIgaWQ6ICR7dGFiLmlkfSwgdXJsOiAke3RhYi51cmx9YCk7XHJcblx0XHRzZW5kTWVzc2FnZVRvVGFiKFxyXG5cdFx0XHR0YWIsXHJcblx0XHRcdDAsIC8vIFJlcXVlc3Qgb25seSB0b3AgZnJhbWVcclxuXHRcdFx0ZG9jdW1lbnRUaXRsZVJlcXVlc3QsXHJcblx0XHRcdChyZXNwb25zZSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGRvY3VtZW50VGl0bGVSZXNwb25zZSA9IHJlc3BvbnNlIGFzIFBhcnRpYWw8Q2hyb21lRG9jdW1lbnRUaXRsZVJlc3BvbnNlPjtcclxuXHRcdFx0XHRpZiAodHlwZW9mIHJlc3BvbnNlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdFx0XHRnZXRMb2dnZXIoKS53YXJuKFwiQmFkIHJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdldExvZ2dlcigpLmxvZyhgUmVxdWVzdGluZyBkb2N1bWVudCB0aXRsZSBmcm9tIHRhYiBpZDogJHt0YWIuaWR9LCB1cmw6ICR7dGFiLnVybH1gKTtcclxuXHRcdFx0XHQvLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIFN1c3BpY2lvdXNUeXBlb2ZDaGVja1xyXG5cdFx0XHRcdGlmIChkb2N1bWVudFRpdGxlUmVzcG9uc2UgPT09IG51bGwgfHxcclxuXHRcdFx0XHRcdGRvY3VtZW50VGl0bGVSZXNwb25zZS5tZXNzYWdlVHlwZSAhPT0gQ2hyb21lQ29udGVudE1lc3NhZ2VUeXBlLkRPQ1VNRU5UX1RJVExFX1JFU1BPTlNFIHx8XHJcblx0XHRcdFx0XHR0eXBlb2YgZG9jdW1lbnRUaXRsZVJlc3BvbnNlLmRvY3VtZW50VGl0bGUgIT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdGdldExvZ2dlcigpLndhcm4oXCJCYWQgZG9jdW1lbnRUaXRsZVJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcclxuXHRcdFx0XHRcdGlmICh0YWIudGl0bGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRkb2N1bWVudFRpdGxlID0gdGFiLnRpdGxlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHsgLy8gZG9jdW1lbnRUaXRsZVJlc3BvbnNlIGlzIHZhbGlkXHJcblx0XHRcdFx0XHRkb2N1bWVudFRpdGxlID0gZG9jdW1lbnRUaXRsZVJlc3BvbnNlLmRvY3VtZW50VGl0bGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChkb2N1bWVudFRpdGxlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFNlbmQgdGl0bGUgdXBkYXRlIHRvIGFsbCBmcmFtZXNcclxuXHRcdFx0XHRjb25zdCBkb2N1bWVudFRpdGxlVXBkYXRlOiBDaHJvbWVEb2N1bWVudFRpdGxlVXBkYXRlID0ge1xyXG5cdFx0XHRcdFx0bWVzc2FnZVR5cGU6IENocm9tZUNvbnRlbnRNZXNzYWdlVHlwZS5ET0NVTUVOVF9USVRMRV9VUERBVEUsXHJcblx0XHRcdFx0XHRkb2N1bWVudFRpdGxlOiBkb2N1bWVudFRpdGxlXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRzZW5kTWVzc2FnZVRvVGFiKHRhYiwgdW5kZWZpbmVkLCBkb2N1bWVudFRpdGxlVXBkYXRlKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0KGxhc3RFcnJvcikgPT4ge1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLndhcm4oYENvdWxkbid0IHJlcXVlc3QgZG9jdW1lbnQudGl0bGUgZnJvbSB0YWIgaWQ6ICR7dGFiLmlkfSwgdXJsOiAke3RhYi51cmx9YCwgbGFzdEVycm9yKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZm9yQWxsVGFicyhmdW5jOiAodGFiOiBUYWIpID0+IHZvaWQpOiB2b2lkIHtcclxuXHRcdGNocm9tZS50YWJzLnF1ZXJ5KHt9LCB0YWJzID0+IHRhYnMuZm9yRWFjaChmdW5jKSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IGZpbmROYW1lQ2hhbmdlZCA9ICh0YWI6IFRhYikgPT4ge1xyXG5cdFx0aWYgKHRhYi5pZCA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YWJTdGF0ZSA9IHRoaXMuZ2xvYmFsVGFic1N0YXRlc1t0YWIuaWRdO1xyXG5cdFx0aWYgKHRhYlN0YXRlICE9IG51bGwgJiYgdGFiU3RhdGUudGl0bGUgIT09IHRhYi50aXRsZSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHRhYi50aXRsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdHRhYlN0YXRlLnRpdGxlID0gdGFiLnRpdGxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdldExvZ2dlcigpLmxvZyhcIkludGVydmFsIGZvdW5kIGEgdGl0bGVDaGFuZ2VcIiwgdGFiU3RhdGUpO1xyXG5cclxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IHRoaXMuY3JlYXRlRGF0YU1lc3NhZ2UoXCJUaXRsZUNoYW5nZVwiLCB0YWIuaWQpO1xyXG5cdFx0XHRpZiAodGhpcy5jb21tdW5pY2F0aW9uICE9IG51bGwpIHtcclxuXHRcdFx0XHR0aGlzLmNvbW11bmljYXRpb24ucG9zdE5hdGl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgdXBkYXRlVGFiSW50ZXJ2YWw6IE5vZGVKUy5UaW1lciB8IHVuZGVmaW5lZDtcclxuXHRwcml2YXRlIHRhYk1vbml0b3JpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdHB1YmxpYyBpbml0VGFic01vbml0b3JpbmcoXHJcblx0XHRtYW5hZ2VyOiBJQmFja2dyb3VuZE1hbmFnZXIsXHJcblx0XHRjb21tdW5pY2F0aW9uOiBJQWdlbnRDb21tdW5pY2F0aW9uKTogdm9pZCB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuXHRcdHRoaXMuY29tbXVuaWNhdGlvbiA9IGNvbW11bmljYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMudGFiTW9uaXRvcmluZ0VuYWJsZWQpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkuZXJyb3IoXCJZb3UgY2FuJ3QgaW5pdCB0YWIgbW9uaXRvcmluZyB0d2ljZSBpbiBhIHJvdyAod2l0aG91dCB1bmluaXQpXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50YWJNb25pdG9yaW5nRW5hYmxlZCA9IHRydWU7XHJcblxyXG5cdFx0Y2hyb21lLnRhYnMub25DcmVhdGVkLmFkZExpc3RlbmVyKHRoaXMub25DcmVhdGVkKTtcclxuXHRcdGNocm9tZS50YWJzLm9uVXBkYXRlZC5hZGRMaXN0ZW5lcih0aGlzLm9uVXBkYXRlZCk7XHJcblx0XHRjaHJvbWUudGFicy5vblJlbW92ZWQuYWRkTGlzdGVuZXIodGhpcy5vblJlbW92ZWQpO1xyXG5cclxuXHRcdGlmIChjaHJvbWUudGFicy5vblJlcGxhY2VkICE9IG51bGwpIHtcclxuXHRcdFx0Y2hyb21lLnRhYnMub25SZXBsYWNlZC5hZGRMaXN0ZW5lcih0aGlzLm9uUmVwbGFjZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNocm9tZS50YWJzLm9uQWN0aXZhdGVkLmFkZExpc3RlbmVyKHRoaXMub25BY3RpdmF0ZWQpO1xyXG5cclxuXHRcdGlmIChjaHJvbWUudGFicy5vbk1vdmVkICE9IG51bGwpIHtcclxuXHRcdFx0Y2hyb21lLnRhYnMub25Nb3ZlZC5hZGRMaXN0ZW5lcih0aGlzLm9uTW92ZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNocm9tZS50YWJzLm9uQXR0YWNoZWQuYWRkTGlzdGVuZXIodGhpcy5vbkF0dGFjaGVkKTtcclxuXHRcdGNocm9tZS50YWJzLm9uRGV0YWNoZWQuYWRkTGlzdGVuZXIodGhpcy5vbkRldGFjaGVkKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVRhYkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5mb3JBbGxUYWJzKHRoaXMuZmluZE5hbWVDaGFuZ2VkKSwgMTAwMCk7XHJcblxyXG5cdFx0Ly8gUXVlcnkgZXhpc3RpbmcgdGFic1xyXG5cdFx0dGhpcy5mb3JBbGxUYWJzKHRhYiA9PiB7XHJcblx0XHRcdGlmICh0YWIuaWQgPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0dGhpcy5hZGRUYWJJZkRvZXNudEV4aXN0cyh0YWIuaWQsIHRhYik7XHJcblx0XHRcdGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZURhdGFNZXNzYWdlKFwiRGlzY292ZXJlZFwiLCB0YWIuaWQpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuY29tbXVuaWNhdGlvbiAhPSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy5jb21tdW5pY2F0aW9uLnBvc3ROYXRpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1bmluaXRUYWJzTW9uaXRvcmluZygpOiB2b2lkIHtcclxuXHRcdHRoaXMudGFiTW9uaXRvcmluZ0VuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmdsb2JhbFRhYnNTdGF0ZXMgPSB7fTtcclxuXHJcblx0XHRpZiAodGhpcy51cGRhdGVUYWJJbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy51cGRhdGVUYWJJbnRlcnZhbCk7XHJcblx0XHRcdHRoaXMudXBkYXRlVGFiSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2hyb21lLnRhYnMub25DcmVhdGVkLnJlbW92ZUxpc3RlbmVyKHRoaXMub25DcmVhdGVkKTtcclxuXHRcdGNocm9tZS50YWJzLm9uVXBkYXRlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uVXBkYXRlZCk7XHJcblx0XHRjaHJvbWUudGFicy5vblJlbW92ZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vblJlbW92ZWQpO1xyXG5cdFx0aWYgKGNocm9tZS50YWJzLm9uUmVwbGFjZWQgIT0gbnVsbCkge1xyXG5cdFx0XHRjaHJvbWUudGFicy5vblJlcGxhY2VkLnJlbW92ZUxpc3RlbmVyKHRoaXMub25SZXBsYWNlZCk7XHJcblx0XHR9XHJcblx0XHRjaHJvbWUudGFicy5vbkFjdGl2YXRlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uQWN0aXZhdGVkKTtcclxuXHRcdGlmIChjaHJvbWUudGFicy5vbk1vdmVkICE9IG51bGwpIHtcclxuXHRcdFx0Y2hyb21lLnRhYnMub25Nb3ZlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uTW92ZWQpO1xyXG5cdFx0fVxyXG5cdFx0Y2hyb21lLnRhYnMub25BdHRhY2hlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uQXR0YWNoZWQpO1xyXG5cdFx0Y2hyb21lLnRhYnMub25EZXRhY2hlZC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uRGV0YWNoZWQpO1xyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY29tbXVuaWNhdGlvbiA9IHVuZGVmaW5lZDtcclxuXHR9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBJVGFic01vbml0b3JpbmcgfSBmcm9tIFwiLi9JVGFic01vbml0b3JpbmdcIjtcclxuaW1wb3J0IHsgc2VuZE1lc3NhZ2VUb1RhYldpdGhMb2cgfSBmcm9tIFwiLi90YWJzXCI7XHJcbmltcG9ydCB7IENvbnRlbnRNZXNzYWdlVHlwZSB9IGZyb20gXCIuLi9jb21tb24vTWVzc2FnaW5nTW9kZWxcIjtcclxuaW1wb3J0IHsgSUh0bWxFdmVudHNNb25pdG9yaW5nIH0gZnJvbSBcIi4vSUh0bWxFdmVudHNNb25pdG9yaW5nXCI7XHJcblxyXG5mdW5jdGlvbiBzZW5kQWxsVGFic01lc3NhZ2UodGFic01vbml0b3Jpbmc6IElUYWJzTW9uaXRvcmluZywgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcblx0dGFic01vbml0b3JpbmcuZm9yQWxsVGFicyh0YWIgPT4gc2VuZE1lc3NhZ2VUb1RhYldpdGhMb2codGFiLCBtZXNzYWdlKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNb25pdG9yIEhUTUwgZXZlbnRzIGluIGNvbnRlbnQgc2NyaXB0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEh0bWxFdmVudHNNb25pdG9yaW5nIGltcGxlbWVudHMgSUh0bWxFdmVudHNNb25pdG9yaW5nIHtcclxuXHRwdWJsaWMgaW5pdEV2ZW50c01vbml0b3JpbmcodGFic01vbml0b3Jpbmc6IElUYWJzTW9uaXRvcmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy50YWJzTW9uaXRvcmluZyA9IHRhYnNNb25pdG9yaW5nO1xyXG5cclxuXHRcdHNlbmRBbGxUYWJzTWVzc2FnZSh0YWJzTW9uaXRvcmluZywgQ29udGVudE1lc3NhZ2VUeXBlLlJFQ09ORklHVVJFKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1bmluaXRFdmVudHNNb25pdG9yaW5nKCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMudGFic01vbml0b3JpbmcgIT0gbnVsbCkge1xyXG5cdFx0XHQgc2VuZEFsbFRhYnNNZXNzYWdlKHRoaXMudGFic01vbml0b3JpbmcsIENvbnRlbnRNZXNzYWdlVHlwZS5VTklOSVRJQUxJWkUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSB0YWJzTW9uaXRvcmluZz86IElUYWJzTW9uaXRvcmluZztcclxufVxyXG4iLCJpbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7XHJcblx0QnJvd3NlclR5cGUsXHJcblx0Q29udGVudEluamVjdGVkLFxyXG5cdEZhcmV3ZWxsUmVxdWVzdCxcclxuXHRGYXJld2VsbFJlc3BvbnNlLFxyXG5cdEdyZWV0aW5nUmVxdWVzdCxcclxuXHRHcmVldGluZ1Jlc3BvbnNlLFxyXG5cdGlzRXh0ZW5zaW9uTWVzc2FnZSxcclxuXHRNZXNzYWdlQWRkcmVzc0ZyYW1lLFxyXG5cdE1lc3NhZ2VGcm9tSW5qZWN0ZWQsXHJcblx0TWVzc2FnZVRvSW5qZWN0ZWQsXHJcblx0Tm90QWN0aXZlUmVzcG9uc2UsXHJcblx0VGFiUmVtb3ZlZCxcclxuXHR2YWxpZGF0ZUNvbmZpZ3VyYXRpb25VcGRhdGUsXHJcblx0dmFsaWRhdGVGYXJld2VsbFJlcXVlc3QsXHJcblx0dmFsaWRhdGVHcmVldGluZ1JlcXVlc3QsXHJcblx0V2FjSW5jb21pbmcsXHJcblx0V2FjT3V0Z29pbmdcclxufSBmcm9tIFwiLi9XYWNBUElcIjtcclxuaW1wb3J0IHsgYnJvd3NlckluZm8gfSBmcm9tIFwiLi4vdXRpbHMvYnJvd3NlckluZm9cIjtcclxuaW1wb3J0IHsgSVdhY0NvbW11bmljYXRpb24gfSBmcm9tIFwiLi9JV2FjQ29tbXVuaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBXZWJOYXZpZ2F0aW9uRXZlbnQgfSBmcm9tIFwiLi9JV2ViTmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyBGcmFtZVN0YXRlIH0gZnJvbSBcIi4vVGFic1N0YXRlXCI7XHJcbmltcG9ydCB7IElXYWNOYXRpdmVDb21tdW5pY2F0aW9uIH0gZnJvbSBcIi4vSVdhY05hdGl2ZUNvbW11bmljYXRpb25cIjtcclxuaW1wb3J0IHsgSU5hdGl2ZU1lc3NhZ2VQb3N0ZXIgfSBmcm9tIFwiLi9JTmF0aXZlTWVzc2FnZVBvc3RlclwiO1xyXG5pbXBvcnQgeyBXYWNPdXRnb2luZ05hdGl2ZU1lc3NhZ2UgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NhZ2luZ01vZGVsXCI7XHJcbmltcG9ydCB7IENvbmZpZ3VyYXRpb25NYW5hZ2VyIH0gZnJvbSBcIi4vQ29uZmlndXJhdGlvbk1hbmFnZXJcIjtcclxuaW1wb3J0IHsgSVRhYnNNb25pdG9yaW5nIH0gZnJvbSBcIi4vSVRhYnNNb25pdG9yaW5nXCI7XHJcbmltcG9ydCBNZXNzYWdlU2VuZGVyID0gY2hyb21lLnJ1bnRpbWUuTWVzc2FnZVNlbmRlcjtcclxuaW1wb3J0IEV4dGVuc2lvbkluZm8gPSBjaHJvbWUubWFuYWdlbWVudC5FeHRlbnNpb25JbmZvO1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgcmVzcG9uc2Ugd2l0aCBhbGwgZmVhdHVyZXMuXHJcbiAqL1xyXG5jb25zdCBHUkVFVElOR19SRVNQT05TRTogUmVhZG9ubHk8R3JlZXRpbmdSZXNwb25zZSAmIHsgZmVhdHVyZXM6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjsgfT4gPSB7XHJcblx0bWVzc2FnZVR5cGU6IFwiR3JlZXRpbmdSZXNwb25zZVwiLFxyXG5cdGZlYXR1cmVzOiBbXCJIVE1MRXZlbnRzXCIsIFwiVmlzaWJpbGl0eVwiXVxyXG59O1xyXG5cclxuY29uc3QgRkFSRVdFTExfUkVTUE9OU0U6IFJlYWRvbmx5PEZhcmV3ZWxsUmVzcG9uc2U+ID0ge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIkZhcmV3ZWxsUmVzcG9uc2VcIixcclxufTtcclxuXHJcbmNvbnN0IE5PVF9BQ1RJVkVfUkVTUE9OU0U6IFJlYWRvbmx5PE5vdEFjdGl2ZVJlc3BvbnNlPiA9IHtcclxuXHRtZXNzYWdlVHlwZTogXCJOb3RBY3RpdmVSZXNwb25zZVwiXHJcbn07XHJcblxyXG5jb25zdCBXQUNfRVhURU5TSU9OX0lEUzogUmVhZG9ubHlBcnJheTxzdHJpbmc+ID0gW1xyXG5cdFwicG9mZm5janBoa2NoY2xlbWtmcGFka2pmZ2tiZmthZnBcIixcclxuXHRcImNkbm5wa2xiaGlwbW5rbm9qYXBrZGlvY2pnbXBscGNjXCIsXHJcblx0XCJuY2tqY3BjaG5uZWpobGRlZGdlbG9wa29lbWRoZGJiZlwiXHJcbl07XHJcblxyXG5cclxuY29uc3QgU1VQUE9SVFNfQ0hST01FX01BTkFHRU1FTlQgPSBjaHJvbWUubWFuYWdlbWVudCAhPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENvbW11bmljYXRpb24gYmV0d2VlbiBBZ2VudCBleHRlbnNpb24gYW5kIFdBQ1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdhY0NvbW11bmljYXRpb24gaW1wbGVtZW50cyBJV2FjQ29tbXVuaWNhdGlvbiwgSVdhY05hdGl2ZUNvbW11bmljYXRpb24ge1xyXG5cdHByaXZhdGUgYWN0aXZlID0gZmFsc2U7XHJcblx0cHJpdmF0ZSB3YWNFeHRlbnNpb25JZD86IHN0cmluZztcclxuXHRwcml2YXRlIG5hdGl2ZU1lc3NhZ2VQb3N0ZXI/OiBJTmF0aXZlTWVzc2FnZVBvc3RlcjtcclxuXHRwcml2YXRlIGNvbmZpZ3VyYXRpb25NYW5hZ2VyPzogQ29uZmlndXJhdGlvbk1hbmFnZXI7XHJcblx0cHJpdmF0ZSB0YWJzTW9uaXRvcmluZz86IElUYWJzTW9uaXRvcmluZztcclxuXHJcblx0cHVibGljIGFjdGl2YXRlKG5hdGl2ZU1lc3NhZ2VTZW5kZXI6IElOYXRpdmVNZXNzYWdlUG9zdGVyLCB0YWJzTW9uaXRvcmluZzogSVRhYnNNb25pdG9yaW5nLCBjb25maWdNYW5hZ2VyOiBDb25maWd1cmF0aW9uTWFuYWdlcik6IHZvaWQge1xyXG5cdFx0Z2V0TG9nZ2VyKCkudHJhY2UoXCJhY3RpdmF0ZSBXYWNDb21tdW5pY2F0aW9uXCIpO1xyXG5cdFx0aWYgKHRoaXMuYWN0aXZlIHx8ICFTVVBQT1JUU19DSFJPTUVfTUFOQUdFTUVOVCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdFx0dGhpcy5uYXRpdmVNZXNzYWdlUG9zdGVyID0gbmF0aXZlTWVzc2FnZVNlbmRlcjtcclxuXHRcdHRoaXMudGFic01vbml0b3JpbmcgPSB0YWJzTW9uaXRvcmluZztcclxuXHRcdHRoaXMuY29uZmlndXJhdGlvbk1hbmFnZXIgPSBjb25maWdNYW5hZ2VyO1xyXG5cclxuXHRcdGlmIChjaHJvbWUgIT09IHVuZGVmaW5lZCAmJiBjaHJvbWUucnVudGltZSAhPT0gdW5kZWZpbmVkICYmIGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZUV4dGVybmFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gVW5pdCB0ZXN0cyBydW4gaW4gcGFnZSAobm90IGJhY2tncm91bmQpIGNvbnRleHQsIHNvIGNocm9tZS5ydW50aW1lIGlzbid0IGF2YWlsYWJsZVxyXG5cdFx0XHRjaHJvbWUucnVudGltZS5vbk1lc3NhZ2VFeHRlcm5hbC5hZGRMaXN0ZW5lcih0aGlzLm9uTWVzc2FnZUV4dGVybmFsKTtcclxuXHRcdFx0Y2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKHRoaXMub25JbmplY3RlZE1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlID09PSB0cnVlICYmIHRoaXMud2FjRXh0ZW5zaW9uSWQgIT0gbnVsbDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkZWFjdGl2YXRlKCk6IHZvaWQge1xyXG5cdFx0Z2V0TG9nZ2VyKCkudHJhY2UoXCJkZWFjdGl2YXRlIFdhY0NvbW11bmljYXRpb25cIik7XHJcblx0XHRpZiAoIXRoaXMuYWN0aXZlIHx8ICFTVVBQT1JUU19DSFJPTUVfTUFOQUdFTUVOVCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHRcdHRoaXMubmF0aXZlTWVzc2FnZVBvc3RlciA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMud2FjRXh0ZW5zaW9uSWQgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0aWYgKGNocm9tZSAhPT0gdW5kZWZpbmVkICYmIGNocm9tZS5ydW50aW1lICE9PSB1bmRlZmluZWQgJiYgY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlRXh0ZXJuYWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyBVbml0IHRlc3RzIHJ1biBpbiBwYWdlIChub3QgYmFja2dyb3VuZCkgY29udGV4dCwgc28gY2hyb21lLnJ1bnRpbWUgaXNuJ3QgYXZhaWxhYmxlXHJcblx0XHRcdGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZUV4dGVybmFsLnJlbW92ZUxpc3RlbmVyKHRoaXMub25NZXNzYWdlRXh0ZXJuYWwpO1xyXG5cdFx0XHRjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkluamVjdGVkTWVzc2FnZSk7XHJcblx0XHRcdGNocm9tZS5tYW5hZ2VtZW50Lm9uRGlzYWJsZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkRpc2FibGVkTGlzdGVuZXIpO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2VuZGluZyBmYXJld2VsbCByZXNwb25zZVwiKTtcclxuXHRcdGlmICh0aGlzLndhY0V4dGVuc2lvbklkICE9IG51bGwpIHtcclxuXHRcdFx0dGhpcy5zZW5kTWVzc2FnZVRvV2FjKEZBUkVXRUxMX1JFU1BPTlNFKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25JbmplY3RlZE1lc3NhZ2UgPSAoe21lc3NhZ2VUeXBlLCBtZXNzYWdlfTogUGFydGlhbDxNZXNzYWdlRnJvbUluamVjdGVkPiwgbWVzc2FnZVNlbmRlcjogTWVzc2FnZVNlbmRlcikgPT4ge1xyXG5cdFx0aWYgKG1lc3NhZ2VUeXBlICE9PSBcIk1lc3NhZ2VGcm9tSW5qZWN0ZWRcIiB8fCBtZXNzYWdlID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtZXNzYWdlU2VuZGVyLnRhYiA9PSBudWxsIHx8IG1lc3NhZ2VTZW5kZXIudGFiLmlkID09IG51bGwgfHwgbWVzc2FnZVNlbmRlci5mcmFtZUlkID09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNlbmRlcjogTWVzc2FnZUFkZHJlc3NGcmFtZSA9IHtcclxuXHRcdFx0YnJvd3NlcjogYnJvd3NlckluZm8ubmFtZSxcclxuXHRcdFx0dGFiSWQ6IG1lc3NhZ2VTZW5kZXIudGFiLmlkLFxyXG5cdFx0XHRmcmFtZUlkOiBtZXNzYWdlU2VuZGVyLmZyYW1lSWRcclxuXHRcdH07XHJcblx0XHR0aGlzLnNlbmRNZXNzYWdlVG9XYWMoe21lc3NhZ2VUeXBlLCBtZXNzYWdlLCBzZW5kZXJ9KTtcclxuXHR9O1xyXG5cclxuXHRwcml2YXRlIHJlYWRvbmx5IG9uVGFiUmVtb3ZlZCA9ICh0YWJJZDogbnVtYmVyKSA9PiB7XHJcblx0XHR0aGlzLnNlbmRNZXNzYWdlVG9XYWMoe21lc3NhZ2VUeXBlOiBcIlRhYlJlbW92ZWRcIiwgcmVtb3ZlZDoge2Jyb3dzZXI6IGJyb3dzZXJJbmZvLm5hbWUsIHRhYklkfX0pO1xyXG5cdH07XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25NZXNzYWdlRXh0ZXJuYWwgPSBhc3luYyAobWVzc2FnZTogV2FjT3V0Z29pbmcsIHNlbmRlcjogTWVzc2FnZVNlbmRlcikgPT4ge1xyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiR290IG1lc3NhZ2VcIiwgbWVzc2FnZSwgc2VuZGVyKTtcclxuXHRcdC8vIFJlcGx5IHdpdGggZXJyb3Igd2hlbiBtYW5hZ2VyIGlzIG5vdCBhY3RpdmVcclxuXHRcdGlmICghdGhpcy5hY3RpdmUpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiRXh0ZW5zaW9uIGlzIG5vdCByZWFkeVwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHNlbmRlci5pZCA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWlzRXh0ZW5zaW9uTWVzc2FnZShtZXNzYWdlKSkgcmV0dXJuO1xyXG5cclxuXHRcdHN3aXRjaCAobWVzc2FnZS5tZXNzYWdlVHlwZSkge1xyXG5cdFx0XHRjYXNlIFwiR3JlZXRpbmdSZXF1ZXN0XCI6XHJcblx0XHRcdFx0aWYgKCF2YWxpZGF0ZUdyZWV0aW5nUmVxdWVzdChtZXNzYWdlKSkgcmV0dXJuO1xyXG5cdFx0XHRcdHRoaXMuaGFuZGxlR3JlZXRpbmcoc2VuZGVyLmlkLCBtZXNzYWdlKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgXCJGYXJld2VsbFJlcXVlc3RcIjpcclxuXHRcdFx0XHRpZiAoIXZhbGlkYXRlRmFyZXdlbGxSZXF1ZXN0KG1lc3NhZ2UpKSBcdCByZXR1cm47XHJcblx0XHRcdFx0dGhpcy5oYW5kbGVGYXJld2VsbChzZW5kZXIuaWQpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBcIk1lc3NhZ2VUb0luamVjdGVkXCI6XHJcblx0XHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2VuZGluZyBleGVjIHNjcmlwdCByZXNwb25zZVwiKTtcclxuXHRcdFx0XHRpZiAobWVzc2FnZS5yZWNpcGllbnQuYnJvd3NlciA9PT0gQnJvd3NlclR5cGUuSUUpIHtcclxuXHRcdFx0XHRcdHRoaXMuc2VuZFRvSUUobWVzc2FnZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBcIkluamVjdE5vdGlmaWNhdGlvbnNGcmFtZVwiOlxyXG5cdFx0XHRcdGNvbnN0IHticm93c2VyLCB0YWJJZH0gPSBtZXNzYWdlLnJlY2lwaWVudDtcclxuXHRcdFx0XHRpZiAoISh0aGlzLmlzQnJvd3NlckNocm9taXVtQmFzZWQoYnJvd3NlcikgJiYgdGFiSWQgIT0gbnVsbCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuc2VuZFRvSUUoe1xyXG5cdFx0XHRcdFx0XHRtZXNzYWdlVHlwZTogXCJJbmplY3ROb3RpZmljYXRpb25zRnJhbWVcIixcclxuXHRcdFx0XHRcdFx0cmVjaXBpZW50OiBtZXNzYWdlLnJlY2lwaWVudFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBcIkNvbmZpZ3VyYXRpb25VcGRhdGVcIjpcclxuXHRcdFx0XHRnZXRMb2dnZXIoKS5sb2coXCJDb25maWd1cmF0aW9uVXBkYXRlIHJlY2VpdmVkXCIpO1xyXG5cdFx0XHRcdGlmICghdmFsaWRhdGVDb25maWd1cmF0aW9uVXBkYXRlKG1lc3NhZ2UpKSByZXR1cm47XHJcblx0XHRcdFx0aWYgKHRoaXMuY29uZmlndXJhdGlvbk1hbmFnZXIgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jb25maWd1cmF0aW9uTWFuYWdlci5zZXRXYWNDb25maWd1cmF0aW9uKG1lc3NhZ2UuZXZlbnRDb25kaXRpb25zKTtcclxuXHRcdFx0XHRcdHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvblVwZGF0ZShtZXNzYWdlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cHVibGljIHNlbmRNZXNzYWdlVG9XYWMobWVzc2FnZTogV2FjSW5jb21pbmcpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLndhY0V4dGVuc2lvbklkID09IG51bGwpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZCB0byBXYWMgRXh0ZW5zaW9uXCIpO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgcHJvbWlzZSA9IGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHRoaXMud2FjRXh0ZW5zaW9uSWQsIG1lc3NhZ2UpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzQnJvd3NlckNocm9taXVtQmFzZWQoYnJvd3Nlck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIChicm93c2VyTmFtZSA9PT0gQnJvd3NlclR5cGUuQ2hyb21lIHx8IGJyb3dzZXJOYW1lID09PSBCcm93c2VyVHlwZS5FZGdlKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVhZG9ubHkgb25EaXNhYmxlZExpc3RlbmVyID0gKGRpc2FibGVkRXh0SW5mbzogRXh0ZW5zaW9uSW5mbykgPT4ge1xyXG5cdFx0aWYgKGRpc2FibGVkRXh0SW5mby5pZCA9PT0gdGhpcy53YWNFeHRlbnNpb25JZCkge1xyXG5cdFx0XHR0aGlzLmhhbmRsZUZhcmV3ZWxsKGRpc2FibGVkRXh0SW5mby5pZCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cHJpdmF0ZSBoYW5kbGVHcmVldGluZyhleHRJZDogc3RyaW5nLCBncmVldGluZ1JlcXVlc3Q6IEdyZWV0aW5nUmVxdWVzdCk6IHZvaWQge1xyXG5cdFx0dGhpcy53YWNFeHRlbnNpb25JZCA9IGV4dElkO1xyXG5cdFx0Y2hyb21lLnRhYnMub25SZW1vdmVkLmFkZExpc3RlbmVyKHRoaXMub25UYWJSZW1vdmVkKTtcclxuXHJcblx0XHRjaHJvbWUubWFuYWdlbWVudC5vbkRpc2FibGVkLmFkZExpc3RlbmVyKHRoaXMub25EaXNhYmxlZExpc3RlbmVyKTtcclxuXHJcblx0XHR0aGlzLnNlbmRUb0lFKGdyZWV0aW5nUmVxdWVzdCk7XHJcblx0XHRpZiAodGhpcy5jb25maWd1cmF0aW9uTWFuYWdlciAhPSBudWxsKSB7XHJcblx0XHRcdHRoaXMuY29uZmlndXJhdGlvbk1hbmFnZXIuc2V0V2FjQWN0aXZlKHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2VuZGluZyBncmVldGluZyByZXNwb25zZVwiLCBncmVldGluZ1JlcXVlc3QpO1xyXG5cdFx0dGhpcy5zZW5kTWVzc2FnZVRvV2FjKEdSRUVUSU5HX1JFU1BPTlNFKTtcclxuXHJcblx0XHQvLyB0b2RvIChpbmplY3QgdG8gYWxsIGZyYW1lcykgb3IgKHNlbmQgbGlzdCBvZiBhbGwgdGFicy9mcmFtZXMgdG8gd2FjKVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBoYW5kbGVGYXJld2VsbChleHRJZDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHQvLyBVbnN1YnNjcmliZSB0byBXQUMgZGlzYWJsZW1lbnRcclxuXHRcdGNocm9tZS5tYW5hZ2VtZW50Lm9uRGlzYWJsZWQucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkRpc2FibGVkTGlzdGVuZXIpO1xyXG5cdFx0Y2hyb21lLnRhYnMub25SZW1vdmVkLnJlbW92ZUxpc3RlbmVyKHRoaXMub25UYWJSZW1vdmVkKTtcclxuXHJcblx0XHQvLyBGb3J3YXJkIHRvIElFXHJcblx0XHR0aGlzLnNlbmRUb0lFKHttZXNzYWdlVHlwZTogXCJGYXJld2VsbFJlcXVlc3RcIn0pO1xyXG5cclxuXHRcdC8vIHRvZG86IEZvcndhcmQgdG8gZnJhbWVzXHJcblxyXG5cdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2VuZGluZyBmYXJld2VsbCByZXNwb25zZVwiKTtcclxuXHRcdHRoaXMuc2VuZE1lc3NhZ2VUb1dhYyhGQVJFV0VMTF9SRVNQT05TRSk7XHJcblx0XHR0aGlzLndhY0V4dGVuc2lvbklkID0gdW5kZWZpbmVkO1xyXG5cdFx0aWYgKHRoaXMuY29uZmlndXJhdGlvbk1hbmFnZXIgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmNvbmZpZ3VyYXRpb25NYW5hZ2VyLnNldFdhY0FjdGl2ZShmYWxzZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGhhbmRsZUNvbmZpZ3VyYXRpb25VcGRhdGUobWVzc2FnZTogV2FjT3V0Z29pbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMuc2VuZFRvSUUobWVzc2FnZSk7XHJcblx0XHRnZXRMb2dnZXIoKS5sb2coXCJTZW5kaW5nIENvbmZpZ3VyYXRpb24gVXBkYXRlIFRvIElFXCIpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpc05hdmlnYXRpb25GaW5pc2hlZChodHRwU3RhdHVzQ29kZT86IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKGh0dHBTdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRpZiAoaHR0cFN0YXR1c0NvZGUgPT09IDMwNCkge1xyXG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UsIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzMwNCA6XHJcblx0XHRcdC8vIFwibm8gbmVlZCB0byByZXRyYW5zbWl0IHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2VzLiBJdCBpcyBhbiBpbXBsaWNpdCByZWRpcmVjdGlvbiB0byBhIGNhY2hlZCByZXNvdXJjZVwiXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGh0dHBTdGF0dXNDb2RlIDwgMjAwIHx8IGh0dHBTdGF0dXNDb2RlID49IDMwMCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cclxuXHRwdWJsaWMgcmVhZG9ubHkgb25XZWJOYXZpZ2F0aW9uID0gKFxyXG5cdFx0ZXZlbnQ6IFdlYk5hdmlnYXRpb25FdmVudCxcclxuXHRcdGRldGFpbHM6IGNocm9tZS53ZWJOYXZpZ2F0aW9uLldlYk5hdmlnYXRpb25DYWxsYmFja0RldGFpbHMsXHJcblx0XHRmcmFtZVN0YXRlPzogRnJhbWVTdGF0ZSB8IG51bGwsXHJcblx0XHR0YWJTdGF0ZT86IEZyYW1lU3RhdGUgfCBudWxsKSA9PiB7XHJcblxyXG5cdFx0aWYgKHRhYlN0YXRlID09IG51bGwgfHwgZnJhbWVTdGF0ZSA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuaXNOYXZpZ2F0aW9uRmluaXNoZWQodGFiU3RhdGUuc3RhdHVzQ29kZSkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMud2FjRXh0ZW5zaW9uSWQgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAoZXZlbnQgIT09IFwiQ29tcGxldGVkXCIgfHwgZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmwgPT0gbnVsbCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy50YWJzTW9uaXRvcmluZyA9PSBudWxsKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YWJJZCA9IHRhYlN0YXRlLnRhYklkO1xyXG5cdFx0Y29uc3QgZnJhbWVJZCA9IGZyYW1lU3RhdGUuZnJhbWVJZDtcclxuXHRcdGNvbnN0IGZyYW1lQ3VycmVudFVybCA9IGZyYW1lU3RhdGUuY3VycmVudFVybDtcclxuXHRcdGNvbnN0IGZyYW1lVXJsID0gZnJhbWVTdGF0ZS5zdGFydFVybDtcclxuXHRcdGNvbnN0IGZyYW1lQ29tbWl0dGVkVXJsID0gZnJhbWVTdGF0ZS5jb21taXR0ZWRVcmw7XHJcblx0XHRjb25zdCB0YWJNb25pdG9yaW5nU3RhdGUgPSB0aGlzLnRhYnNNb25pdG9yaW5nLmdldFRhYlN0YXRlKHRhYklkKTtcclxuXHRcdGlmICh0YWJNb25pdG9yaW5nU3RhdGUgPT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE5vIHRhYiBzdGF0ZSBpbiB0YWJJZCAke3RhYklkfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2VuZE1lc3NhZ2VUb1dhYyh7XHJcblx0XHRcdG1lc3NhZ2VUeXBlOiBcIkNvbnRlbnRJbmplY3RlZFwiLFxyXG5cdFx0XHRmcmFtZUluZm86IHtcclxuXHRcdFx0XHR0aXRsZTogdGFiTW9uaXRvcmluZ1N0YXRlLnRpdGxlLFxyXG5cdFx0XHRcdGJyb3dzZXI6IGJyb3dzZXJJbmZvLm5hbWUsXHJcblx0XHRcdFx0ZnJhbWVJZCxcclxuXHRcdFx0XHR0YWJJZCxcclxuXHRcdFx0XHRmcmFtZUN1cnJlbnRVcmwsXHJcblx0XHRcdFx0ZnJhbWVVcmwsXHJcblx0XHRcdFx0ZnJhbWVDb21taXR0ZWRVcmxcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaW5jb21pbmdNZXNzYWdlKG1lc3NhZ2U6IFdhY0luY29taW5nKTogdm9pZCB7XHJcblx0XHRpZiAoIWlzRXh0ZW5zaW9uTWVzc2FnZShtZXNzYWdlKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLnNlbmRNZXNzYWdlVG9XYWMobWVzc2FnZSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHNlbmRUb0lFKG1lc3NhZ2U6IFdhY091dGdvaW5nKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5uYXRpdmVNZXNzYWdlUG9zdGVyID09IG51bGwpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihuZXcgRXJyb3IoXCJVbmFibGUgdG8gZXhlYyBzY3JpcHQgaW4gJ0ludGVybmV0RXhwbG9yZXInOiBObyBuYXRpdmVNZXNzYWdlUG9zdGVyXCIpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubmF0aXZlTWVzc2FnZVBvc3Rlci5wb3N0TmF0aXZlTWVzc2FnZShuZXcgV2FjT3V0Z29pbmdOYXRpdmVNZXNzYWdlKG1lc3NhZ2UpKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiZXhwb3J0IGNvbnN0IFBST1RPQ09MX1ZFUlNJT04gPSAxO1xyXG5cclxuZXhwb3J0IHR5cGUgV2FjT3V0Z29pbmcgPVxyXG5cdC8vIG1lc3NhZ2VzXHJcblx0TWVzc2FnZVRvSW5qZWN0ZWQgfFxyXG5cdC8vIHJlcXVlc3RzXHJcblx0R3JlZXRpbmdSZXF1ZXN0IHxcclxuXHRGYXJld2VsbFJlcXVlc3QgfFxyXG5cdEluamVjdE5vdGlmaWNhdGlvbnNGcmFtZSB8XHJcblx0Q29uZmlndXJhdGlvblVwZGF0ZSB8XHJcblxyXG5cdEVycm9yUmVzcG9uc2VcclxuXHQ7XHJcblxyXG5leHBvcnQgdHlwZSBXYWNJbmNvbWluZyA9XHJcblx0Ly8gbWVzc2FnZXNcclxuXHRUYWJSZW1vdmVkIHxcclxuXHRNZXNzYWdlRnJvbUluamVjdGVkIHxcclxuXHRFdmVudE1hdGNoUmVwb3J0IHxcclxuXHRDb250ZW50SW5qZWN0ZWQgfFxyXG5cdFdhY0ZyYW1lSW5qZWN0ZWQgfFxyXG5cdC8vIHJlc3BvbnNlc1xyXG5cdEdyZWV0aW5nUmVzcG9uc2UgfFxyXG5cdEZhcmV3ZWxsUmVzcG9uc2UgfFxyXG5cclxuXHRFcnJvclJlc3BvbnNlXHJcblx0O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFeHRlbnNpb25NZXNzYWdlIHtcclxuXHRtZXNzYWdlVHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEluamVjdE5vdGlmaWNhdGlvbnNGcmFtZSBleHRlbmRzIEV4dGVuc2lvbk1lc3NhZ2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIkluamVjdE5vdGlmaWNhdGlvbnNGcmFtZVwiO1xyXG5cdHJlY2lwaWVudDogTWVzc2FnZUFkZHJlc3NUYWI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3JlZXRpbmdSZXF1ZXN0IGV4dGVuZHMgRXh0ZW5zaW9uTWVzc2FnZSB7XHJcblx0bWVzc2FnZVR5cGU6IFwiR3JlZXRpbmdSZXF1ZXN0XCI7XHJcblx0cHJvdG9jb2xWZXJzaW9uOiBudW1iZXI7XHJcblx0Y29udGVudFNjcmlwdDogc3RyaW5nO1xyXG5cdG5vdGlmaWNhdGlvbnNTY3JpcHQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGYXJld2VsbFJlcXVlc3QgZXh0ZW5kcyBFeHRlbnNpb25NZXNzYWdlIHtcclxuXHRtZXNzYWdlVHlwZTogXCJGYXJld2VsbFJlcXVlc3RcIjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQWRkcmVzc1RhYiB7XHJcblx0YnJvd3NlcjogQnJvd3NlclR5cGU7XHJcblx0dGFiSWQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlQWRkcmVzc0ZyYW1lIHtcclxuXHRicm93c2VyOiBCcm93c2VyVHlwZTtcclxuXHR0YWJJZDogbnVtYmVyO1xyXG5cdGZyYW1lSWQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlVG9JbmplY3RlZCBleHRlbmRzIEV4dGVuc2lvbk1lc3NhZ2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIk1lc3NhZ2VUb0luamVjdGVkXCI7XHJcblx0cmVjaXBpZW50OiBNZXNzYWdlQWRkcmVzc0ZyYW1lO1xyXG5cdG1lc3NhZ2U6IHVua25vd247XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlndXJhdGlvblVwZGF0ZSBleHRlbmRzIEV4dGVuc2lvbk1lc3NhZ2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIkNvbmZpZ3VyYXRpb25VcGRhdGVcIjtcclxuXHRldmVudENvbmRpdGlvbnM6IEV2ZW50Q29uZGl0aW9uW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFiUmVtb3ZlZCBleHRlbmRzIEV4dGVuc2lvbk1lc3NhZ2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIlRhYlJlbW92ZWRcIjtcclxuXHRyZW1vdmVkOiBNZXNzYWdlQWRkcmVzc1RhYjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTWVzc2FnZVRvSW5qZWN0ZWQobTogdW5rbm93bik6IG0gaXMgTWVzc2FnZVRvSW5qZWN0ZWQge1xyXG5cdGNvbnN0IG1tID0gbSBhcyBQYXJ0aWFsPE1lc3NhZ2VUb0luamVjdGVkPjtcclxuXHRyZXR1cm4gbW0ubWVzc2FnZVR5cGUgPT09IFwiTWVzc2FnZVRvSW5qZWN0ZWRcIjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXYWNGcmFtZUluamVjdGVkIGV4dGVuZHMgRXh0ZW5zaW9uTWVzc2FnZSB7XHJcblx0bWVzc2FnZVR5cGU6IFwiV2FjRnJhbWVJbmplY3RlZFwiO1xyXG5cdGFkZHJlc3M6IE1lc3NhZ2VBZGRyZXNzRnJhbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudEluamVjdGVkIGV4dGVuZHMgRXh0ZW5zaW9uTWVzc2FnZSB7XHJcblx0bWVzc2FnZVR5cGU6IFwiQ29udGVudEluamVjdGVkXCI7XHJcblx0ZnJhbWVJbmZvOiBGcmFtZUluZm87XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZUZyb21JbmplY3RlZCBleHRlbmRzIEV4dGVuc2lvbk1lc3NhZ2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIk1lc3NhZ2VGcm9tSW5qZWN0ZWRcIjtcclxuXHRzZW5kZXI6IE1lc3NhZ2VBZGRyZXNzRnJhbWU7XHJcblx0bWVzc2FnZTogdW5rbm93bjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTWVzc2FnZUZyb21JbmplY3RlZChtOiB1bmtub3duKTogbSBpcyBNZXNzYWdlRnJvbUluamVjdGVkIHtcclxuXHRjb25zdCBtbSA9IG0gYXMgUGFydGlhbDxNZXNzYWdlRnJvbUluamVjdGVkPjtcclxuXHRyZXR1cm4gbW0ubWVzc2FnZVR5cGUgPT09IFwiTWVzc2FnZUZyb21JbmplY3RlZFwiICYmIHR5cGVvZiBtbS5zZW5kZXIgPT09IFwib2JqZWN0XCI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRNYXRjaFJlcG9ydCBleHRlbmRzIEV4dGVuc2lvbk1lc3NhZ2Uge1xyXG5cdG1lc3NhZ2VUeXBlOiBcIkV2ZW50TWF0Y2hSZXBvcnRcIjtcclxuXHRldmVudDogTWF0Y2hSZXBvcnRFdmVudDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTWF0Y2hFdmVudFR5cGUgPSBcIkNvbW1pdHRlZFwiIHwgXCJDb21wbGV0ZWRcIiB8IFwiVmlzaWJsZVwiIHwgXCJrZXlkb3duXCIgfCBcImNsaWNrXCIgfCBcImRibGNsaWNrXCIgfFxyXG5cdFwibW91c2Vkb3duXCIgfCBcIm1vdXNlZW50ZXJcIiB8IFwibW91c2V1cFwiIHwgXCJjaGFuZ2VcIiB8IFwiY29udGV4dG1lbnVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWF0Y2hSZXBvcnRFdmVudCB7XHJcblx0ZG9jdW1lbnRDb21taXR0ZWRVcmw6IHN0cmluZztcclxuXHRmcmFtZUNvbW1pdHRlZFVybD86IHN0cmluZztcclxuXHRtb2RpZmllcktleXM6IHN0cmluZzsgLy8gdG9kbzogbmVlZGVkP1xyXG5cdG1vdXNlQnV0dG9uPzogc3RyaW5nO1xyXG5cdGRvY3VtZW50VGl0bGU6IHN0cmluZztcclxuXHRjc3NTZWxlY3Rvcj86IHN0cmluZztcclxuXHRldmVudFR5cGU6IE1hdGNoRXZlbnRUeXBlO1xyXG5cdGZyYW1lSWQ6IG51bWJlcjtcclxuXHR0YWJJZDogbnVtYmVyO1xyXG5cdHRpbWVTdGFtcDogbnVtYmVyO1xyXG5cdGJyb3dzZXI/OiBCcm93c2VyVHlwZTtcclxuXHRrZXk/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTWF0Y2hSZXBvcnRFdmVudChldmVudDogTWF0Y2hSZXBvcnRFdmVudCk6IGV2ZW50IGlzIE1hdGNoUmVwb3J0RXZlbnQge1xyXG5cdGNvbnN0IHZhbGlkYXRlRXZlbnRUeXBlID0gKGV2ZW50VHlwZTogc3RyaW5nKSA9PiBldmVudFR5cGUgPT09IFwiQ29tbWl0dGVkXCIgfHxcclxuXHRcdGV2ZW50VHlwZSA9PT0gXCJDb21wbGV0ZWRcIiB8fFxyXG5cdFx0ZXZlbnRUeXBlID09PSBcIlZpc2libGVcIiB8fFxyXG5cdFx0ZXZlbnRUeXBlID09PSBcImtleWRvd25cIiB8fFxyXG5cdFx0ZXZlbnRUeXBlID09PSBcImNsaWNrXCIgfHxcclxuXHRcdGV2ZW50VHlwZSA9PT0gXCJkYmxjbGlja1wiIHx8XHJcblx0XHRldmVudFR5cGUgPT09IFwibW91c2Vkb3duXCIgfHxcclxuXHRcdGV2ZW50VHlwZSA9PT0gXCJtb3VzZWVudGVyXCIgfHxcclxuXHRcdGV2ZW50VHlwZSA9PT0gXCJtb3VzZXVwXCIgfHxcclxuXHRcdGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiB8fFxyXG5cdFx0ZXZlbnRUeXBlID09PSBcImNvbnRleHRtZW51XCI7XHJcblxyXG5cdHJldHVybiB0eXBlb2YgZXZlbnQuZG9jdW1lbnRDb21taXR0ZWRVcmwgPT09IFwic3RyaW5nXCIgJiZcclxuXHRcdChldmVudC5ldmVudFR5cGUgIT09IFwia2V5ZG93blwiIHx8IHR5cGVvZiBldmVudC5tb2RpZmllcktleXMgPT09IFwic3RyaW5nXCIpICYmXHJcblx0XHR0eXBlb2YgZXZlbnQuZG9jdW1lbnRUaXRsZSA9PT0gXCJzdHJpbmdcIiAmJlxyXG5cdFx0dHlwZW9mIGV2ZW50LnRhYklkID09PSBcIm51bWJlclwiICYmXHJcblx0XHR0eXBlb2YgZXZlbnQuZnJhbWVJZCA9PT0gXCJudW1iZXJcIiAmJlxyXG5cdFx0dHlwZW9mIGV2ZW50LnRpbWVTdGFtcCA9PT0gXCJudW1iZXJcIiAmJlxyXG5cdFx0dmFsaWRhdGVFdmVudFR5cGUoZXZlbnQuZXZlbnRUeXBlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXZlbnRNYXRjaFJlcG9ydChtZXNzYWdlOiBQYXJ0aWFsPEV2ZW50TWF0Y2hSZXBvcnQ+KTogbWVzc2FnZSBpcyBFdmVudE1hdGNoUmVwb3J0IHtcclxuXHRyZXR1cm4gbWVzc2FnZS5tZXNzYWdlVHlwZSA9PT0gXCJFdmVudE1hdGNoUmVwb3J0XCIgJiZcclxuXHRcdHR5cGVvZiBtZXNzYWdlLmV2ZW50ID09PSBcIm9iamVjdFwiICYmXHJcblx0XHRpc01hdGNoUmVwb3J0RXZlbnQobWVzc2FnZS5ldmVudCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdyZWV0aW5nUmVxdWVzdChtZXNzYWdlOiBQYXJ0aWFsPEdyZWV0aW5nUmVxdWVzdD4pOiBtZXNzYWdlIGlzIEdyZWV0aW5nUmVxdWVzdCB7XHJcblx0cmV0dXJuIG1lc3NhZ2UubWVzc2FnZVR5cGUgPT09IFwiR3JlZXRpbmdSZXF1ZXN0XCIgJiZcclxuXHRcdHR5cGVvZiBtZXNzYWdlLmNvbnRlbnRTY3JpcHQgPT09IFwic3RyaW5nXCIgJiZcclxuXHRcdHR5cGVvZiBtZXNzYWdlLnByb3RvY29sVmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJlxyXG5cdFx0bWVzc2FnZS5wcm90b2NvbFZlcnNpb24gPT09IFBST1RPQ09MX1ZFUlNJT047XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZhcmV3ZWxsUmVxdWVzdChtZXNzYWdlOiBFeHRlbnNpb25NZXNzYWdlKTogbWVzc2FnZSBpcyBGYXJld2VsbFJlcXVlc3Qge1xyXG5cdHJldHVybiBtZXNzYWdlLm1lc3NhZ2VUeXBlID09PSBcIkZhcmV3ZWxsUmVxdWVzdFwiO1xyXG59XHJcblxyXG4vLyBOZXcgcHJvcGVydGllc1xyXG4vLyBOZXcgZXZlbnRzXHJcbi8vIE5ldyBtYXRjaGluZyBjYXBhYmlsaXRpZXMgZS5nLiBnZXQgZGF0YSBmcm9tIHBhcmVudCBvciBjaGlsZFxyXG5leHBvcnQgdHlwZSBGZWF0dXJlID0gXCJIVE1MRXZlbnRzXCIgfCBcIlZpc2liaWxpdHlcIiB8IFwiVW5pZmllZENsaWNrXCIgfCBcIkdlbmVyaWNTdGFydFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFcnJvclJlc3BvbnNlIGV4dGVuZHMgRXh0ZW5zaW9uTWVzc2FnZSB7XHJcblx0bWVzc2FnZVR5cGU6IFwiRXJyb3JSZXNwb25zZVwiO1xyXG5cdGVycm9yOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTm90QWN0aXZlUmVzcG9uc2UgZXh0ZW5kcyBFeHRlbnNpb25NZXNzYWdlIHtcclxuXHRtZXNzYWdlVHlwZTogXCJOb3RBY3RpdmVSZXNwb25zZVwiO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdyZWV0aW5nUmVzcG9uc2UgZXh0ZW5kcyBFeHRlbnNpb25NZXNzYWdlIHtcclxuXHRtZXNzYWdlVHlwZTogXCJHcmVldGluZ1Jlc3BvbnNlXCI7XHJcblx0ZmVhdHVyZXM6IEZlYXR1cmVbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGYXJld2VsbFJlc3BvbnNlIGV4dGVuZHMgRXh0ZW5zaW9uTWVzc2FnZSB7XHJcblx0bWVzc2FnZVR5cGU6IFwiRmFyZXdlbGxSZXNwb25zZVwiO1xyXG59XHJcblxyXG4vLyBzeW5jZWQgd2l0aCBXQUMgMi4wIHByb2plY3QgaW4gZmlsZSBleHRlbnNpb25BcGkudHNcclxuZXhwb3J0IGNvbnN0IGVudW0gQnJvd3NlclR5cGUge1xyXG5cdElFID0gXCJJbnRlcm5ldEV4cGxvcmVyXCIsXHJcblx0Q2hyb21lID0gXCJDaHJvbWVcIixcclxuXHRGaXJlZm94ID0gXCJGaXJlZm94XCIsXHJcblx0RWRnZSA9IFwiRWRnZVwiLFxyXG5cdFNhZmFyaSA9IFwiU2FmYXJpXCIsXHJcblx0TkEgPSBcIk4vQVwiXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0dyZWV0aW5nUmVzcG9uc2UobWVzc2FnZTogRXh0ZW5zaW9uTWVzc2FnZSk6IG1lc3NhZ2UgaXMgR3JlZXRpbmdSZXNwb25zZSB7XHJcblx0aWYgKG1lc3NhZ2UubWVzc2FnZVR5cGUgIT09IFwiR3JlZXRpbmdSZXNwb25zZVwiKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRjb25zdCB7ZmVhdHVyZXN9ID0gbWVzc2FnZSBhcyBFeHRlbnNpb25NZXNzYWdlICYgUGFydGlhbDxHcmVldGluZ1Jlc3BvbnNlPjtcclxuXHRpZiAoIUFycmF5LmlzQXJyYXkoZmVhdHVyZXMpIHx8XHJcblx0XHRmZWF0dXJlcy5sZW5ndGggPT09IDAgfHxcclxuXHRcdGZlYXR1cmVzLnNvbWUoKGY6IHN0cmluZykgPT4gdHlwZW9mIGYgIT09IFwic3RyaW5nXCIpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJHcmVldGluZ1Jlc3BvbnNlXCIpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZGl0aW9uUHJvcGVydHkoY29uOiBDb25kaXRpb25Qcm9wZXJ0eSk6IGNvbiBpcyBDb25kaXRpb25Qcm9wZXJ0eSB7XHJcblx0cmV0dXJuIChjb24ubWF0Y2hUeXBlID09PSBcImV4YWN0XCIgfHwgY29uLm1hdGNoVHlwZSA9PT0gXCJyZWdleFwiKSAmJlxyXG5cdFx0dHlwZW9mIGNvbi5wcm9wZXJ0eSA9PT0gXCJzdHJpbmdcIiAmJlxyXG5cdFx0dHlwZW9mIGNvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVIdG1sRXZlbnRDb25kaXRpb24oZXZlbnRDb25kaXRpb246IEV2ZW50Q29uZGl0aW9uKTogZXZlbnRDb25kaXRpb24gaXMgRXZlbnRDb25kaXRpb24geyAvLyB3YWNcclxuXHRyZXR1cm4gdHlwZW9mIGV2ZW50Q29uZGl0aW9uLm5hbWUgPT09IFwic3RyaW5nXCIgJiZcclxuXHRcdHR5cGVvZiBldmVudENvbmRpdGlvbi5ldmVudCA9PT0gXCJzdHJpbmdcIiAmJlxyXG5cdFx0QXJyYXkuaXNBcnJheShldmVudENvbmRpdGlvbi5jb25kaXRpb25Qcm9wZXJ0aWVzKSAmJlxyXG5cdFx0ZXZlbnRDb25kaXRpb24uY29uZGl0aW9uUHJvcGVydGllcy5ldmVyeSh2YWxpZGF0ZUNvbmRpdGlvblByb3BlcnR5KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlndXJhdGlvblVwZGF0ZShtZXNzYWdlOiBDb25maWd1cmF0aW9uVXBkYXRlKTogbWVzc2FnZSBpcyBDb25maWd1cmF0aW9uVXBkYXRlIHtcclxuXHRyZXR1cm4gbWVzc2FnZS5tZXNzYWdlVHlwZSA9PT0gXCJDb25maWd1cmF0aW9uVXBkYXRlXCIgJiZcclxuXHRcdEFycmF5LmlzQXJyYXkobWVzc2FnZS5ldmVudENvbmRpdGlvbnMpICYmXHJcblx0XHRtZXNzYWdlLmV2ZW50Q29uZGl0aW9ucy5ldmVyeSh2YWxpZGF0ZUh0bWxFdmVudENvbmRpdGlvbik7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRDb25kaXRpb24ge1xyXG5cdG5hbWU6IHN0cmluZztcclxuXHRldmVudDogc3RyaW5nO1xyXG5cdGNvbmRpdGlvblByb3BlcnRpZXM6IENvbmRpdGlvblByb3BlcnR5W107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uZGl0aW9uUHJvcGVydHkge1xyXG5cdHByb3BlcnR5OiBzdHJpbmc7XHJcblx0bWF0Y2hUeXBlOiBcImV4YWN0XCIgfCBcInJlZ2V4XCI7XHJcblx0dmFsdWU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGcmFtZUluZm8ge1xyXG5cdGZyYW1lVXJsOiBzdHJpbmc7XHJcblx0ZnJhbWVDb21taXR0ZWRVcmw6IHN0cmluZztcclxuXHRmcmFtZUN1cnJlbnRVcmw6IHN0cmluZztcclxuXHR0aXRsZTogc3RyaW5nO1xyXG5cdHRhYklkOiBudW1iZXI7XHJcblx0ZnJhbWVJZDogbnVtYmVyO1xyXG5cdGJyb3dzZXI6IEJyb3dzZXJUeXBlO1xyXG59XHJcblxyXG4vKipcclxuICogQHJldHVybiB0cnVlIHdoZW4gbWVzc2FnZSBpcyBFeHRlbnNpb24gbWVzc2FnZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVuc2lvbk1lc3NhZ2UobWVzc2FnZTogUGFydGlhbDxFeHRlbnNpb25NZXNzYWdlPik6IG1lc3NhZ2UgaXMgV2FjT3V0Z29pbmcgfCBXYWNJbmNvbWluZyB7XHJcblx0Y29uc3Qge21lc3NhZ2VUeXBlfSA9IG1lc3NhZ2U7XHJcblx0cmV0dXJuIHR5cGVvZiBtZXNzYWdlVHlwZSA9PT0gXCJzdHJpbmdcIjtcclxufVxyXG4iLCJpbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IEV2ZW50Q29uZGl0aW9uIH0gZnJvbSBcIi4vV2FjQVBJXCI7XHJcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29tbW9uL2NvbmZpZ3VyYXRpb24vQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQgeyBQZXJzaXN0ZW50Q29uZmlndXJhdGlvbiB9IGZyb20gXCIuL1BlcnNpc3RlbnRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gXCIuL0NvbmZpZ3VyYXRpb25NYW5hZ2VySGVscGVyXCI7XHJcbmltcG9ydCB7IElDb25maWd1cmF0aW9uTWFuYWdlciB9IGZyb20gXCIuL0lDb25maWd1cmF0aW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBJQmFja2dyb3VuZE1hbmFnZXJDb250cm9sbGVyIH0gZnJvbSBcIi4vSUJhY2tncm91bmRNYW5hZ2VyQ29udHJvbGxlclwiO1xyXG5cclxuY29uc3QgQ09ORklHVVJBVElPTl9TVE9SQUdFID0gXCJfQXRlcm5pdHlDb25maWd1cmF0aW9uX1wiO1xyXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgY29uZmlndXJhdGlvbnMgZnJvbSBBZ2VudCBhbmQgZnJvbSBXQUNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uTWFuYWdlciBpbXBsZW1lbnRzIElDb25maWd1cmF0aW9uTWFuYWdlciB7XHJcblx0cHJpdmF0ZSByZWFkb25seSBhZ2VudENvbmZpZ3VyYXRpb24gPSBuZXcgUGVyc2lzdGVudENvbmZpZ3VyYXRpb24oQ09ORklHVVJBVElPTl9TVE9SQUdFKTtcclxuXHRwcml2YXRlIHdhY0NvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uO1xyXG5cdHByaXZhdGUgd2FjQWN0aXZlOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHJpdmF0ZSBtYW5hZ2VyPzogSUJhY2tncm91bmRNYW5hZ2VyQ29udHJvbGxlcjtcclxuXHJcblx0cHVibGljIGluaXRDb25maWd1cmF0aW9uTWFuYWdlcihtYW5hZ2VyOiBJQmFja2dyb3VuZE1hbmFnZXJDb250cm9sbGVyKTogdm9pZCB7XHJcblx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldEFnZW50Q29uZmlndXJhdGlvbihqc29uU3RyaW5nOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGdldExvZ2dlcigpLmxvZyhcIlJlY2VpdmVkIG5ldyBjb25maWd1cmF0aW9uIGZyb20gQWdlbnRcIik7XHJcblx0XHR0aGlzLmFnZW50Q29uZmlndXJhdGlvbi5wYXJzZUFuZFNldENvbmZpZ3VyYXRpb24oanNvblN0cmluZyk7XHJcblx0XHR0aGlzLmFjdGl2YXRlQWdlbnRDb25maWd1cmF0aW9uSWZDb25maWd1cmVkKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0V2FjQ29uZmlndXJhdGlvbih3YWNDb25maWd1cmF0aW9uOiBFdmVudENvbmRpdGlvbltdKTogdm9pZCB7XHJcblx0XHRnZXRMb2dnZXIoKS5sb2coXCJSZWNlaXZlZCBuZXcgY29uZmlndXJhdGlvbiBmcm9tIFdBQ1wiLCB3YWNDb25maWd1cmF0aW9uKTtcclxuXHRcdGlmICh0aGlzLndhY0FjdGl2ZSAmJiB0aGlzLm1hbmFnZXIgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLm1hbmFnZXIuZGVhY3RpdmF0ZSgpO1xyXG5cdFx0XHR0aGlzLndhY0NvbmZpZ3VyYXRpb24gPSB0cmFuc2Zvcm0od2FjQ29uZmlndXJhdGlvbik7XHJcblx0XHRcdHRoaXMubWFuYWdlci5hY3RpdmF0ZSh0aGlzLndhY0NvbmZpZ3VyYXRpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHNldFdhY0FjdGl2ZShhY3RpdmU6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdHRoaXMud2FjQWN0aXZlID0gYWN0aXZlO1xyXG5cdFx0dGhpcy5hY3RpdmF0ZUFnZW50Q29uZmlndXJhdGlvbklmQ29uZmlndXJlZCgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlc2V0Q29uZmlndXJhdGlvbigpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLmFnZW50Q29uZmlndXJhdGlvbiAhPSBudWxsKSB7XHJcblx0XHRcdHRoaXMuYWdlbnRDb25maWd1cmF0aW9uLmNsZWFyQ29uZmlndXJhdGlvbigpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldENvbmZpZ3VyYXRpb24oKTogQ29uZmlndXJhdGlvbiB7XHJcblx0XHRyZXR1cm4gdGhpcy53YWNBY3RpdmUgJiYgdGhpcy53YWNDb25maWd1cmF0aW9uICE9IG51bGwgPyB0aGlzLndhY0NvbmZpZ3VyYXRpb24gOiB0aGlzLmFnZW50Q29uZmlndXJhdGlvbi5nZXRDb25maWd1cmF0aW9uKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFjdGl2YXRlQWdlbnRDb25maWd1cmF0aW9uSWZDb25maWd1cmVkKCk6IHZvaWQge1xyXG5cdFx0aWYgKCF0aGlzLndhY0FjdGl2ZSAmJiB0aGlzLm1hbmFnZXIgIT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLm1hbmFnZXIuZGVhY3RpdmF0ZSgpO1xyXG5cdFx0XHR0aGlzLm1hbmFnZXIuYWN0aXZhdGUodGhpcy5hZ2VudENvbmZpZ3VyYXRpb24uZ2V0Q29uZmlndXJhdGlvbigpKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi4vdXRpbHMvbG9nXCI7XHJcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29tbW9uL2NvbmZpZ3VyYXRpb24vQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcclxuaW1wb3J0IHsgSVBlcnNpc3RlbnRDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4vSVBlcnNpc3RlbnRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7XHJcblx0RU1QVFlfQ09ORklHVVJBVElPTixcclxuXHRDb25maWd1cmF0aW9uRGF0YSxcclxuXHRDT05GSUdVUkFUSU9OX1ZFUlNJT04sXHJcblx0UmVhZG9ubHlDb25maWd1cmF0aW9uRGF0YVxyXG59IGZyb20gXCIuLi9jb21tb24vQ29uZmlndXJhdGlvbkRhdGFcIjtcclxuXHJcbi8qKlxyXG4gKiBTdG9yZXMgYW5kIGxvYWRzIGNvbmZpZ3VyYXRpb24gZnJvbSBwZXJzaXN0ZW50IHN0b3JhZ2UuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVudENvbmZpZ3VyYXRpb24gaW1wbGVtZW50cyBJUGVyc2lzdGVudENvbmZpZ3VyYXRpb24ge1xyXG5cdHByaXZhdGUgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbiA9IG5ldyBDb25maWd1cmF0aW9uKFV0aWxzLmRlZXBDbG9uZShFTVBUWV9DT05GSUdVUkFUSU9OKSk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWQgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBsb2NhbFN0b3JhZ2UgaWYgZXhpc3RzLlxyXG5cdCAqIFVzZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gaWYgbm8gY29uZmlndXJhdGlvbiB3YXMgc3RvcmVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHN0b3JhZ2VLZXkge3N0cmluZ30gS2V5IHVzZWQgZm9yIGNvbmZpZ3VyYXRpb24gc3RvcmFnZSBpbiBsb2NhbFN0b3JhZ2Ugb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc3RvcmFnZUtleTogc3RyaW5nKSB7XHJcblx0XHQvLyBTZXQgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBsb2NhbCBzdG9yYWdlXHJcblxyXG5cdFx0Ly8gbXYzIGNoYW5nZSAtIFRlc3RlZFxyXG5cdFx0Y29uc3QgcCA9IHRoaXMubXlJbml0KHN0b3JhZ2VLZXkpO1xyXG5cdH1cclxuXHQvLyBtdjNcclxuXHRwcml2YXRlIGFzeW5jIG15SW5pdChzdG9yYWdlS2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChudWxsKVxyXG5cdFx0XHQudGhlbigoaXRlbXMpID0+IHtcclxuXHRcdFx0XHR0aGlzLnBhcnNlQW5kU2V0Q29uZmlndXJhdGlvbihTdHJpbmcoaXRlbXMuc3RvcmFnZUtleSkpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2F0Y2goKHJlc3BvbnNlKSA9PiBnZXRMb2dnZXIoKS5lcnJvcihyZXNwb25zZSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2UgY29uZmlndXJhdGlvbiBzdHJpbmcgYW5kIHVwZGF0ZSBjb25maWd1cmF0aW9uIGlmIHN1Y2Nlc3NmdWxseSBwYXJzZWQuXHJcblx0ICogSWYgY29uZmlndXJhdGlvbiBzdHJpbmcgaXMgaW52YWxpZCwgc2V0IGRlZmF1bHQgY29uZmlndXJhdGlvbi5cclxuXHQgKi9cclxuXHRwdWJsaWMgcGFyc2VBbmRTZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb25TdHJpbmc6IHN0cmluZyB8IG51bGwpOiB2b2lkIHtcclxuXHRcdC8vIFN0YXJ0IHdpdGggZGVmYXVsdFxyXG5cdFx0Y29uc3QgY29uZmlndXJhdGlvbkRhdGEgPSBVdGlscy5kZWVwQ2xvbmUoRU1QVFlfQ09ORklHVVJBVElPTik7XHJcblx0XHRpZiAoY29uZmlndXJhdGlvblN0cmluZyAhPSBudWxsICYmIGNvbmZpZ3VyYXRpb25TdHJpbmcubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRsZXQgcGFyc2VkQ29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbkRhdGE7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1hbnlcclxuXHRcdFx0XHRwYXJzZWRDb25maWd1cmF0aW9uID0gSlNPTi5wYXJzZShjb25maWd1cmF0aW9uU3RyaW5nKTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdGdldExvZ2dlcigpLmVycm9yKFwiRmFpbGVkIHBhcnNpbmcgY29uZmlndXJhdGlvblwiLCBjb25maWd1cmF0aW9uU3RyaW5nKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdFV0aWxzLnBvcHVsYXRlKHBhcnNlZENvbmZpZ3VyYXRpb24sIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldENvbmZpZ3VyYXRpb25JbXBsKGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb25EYXRhOiBQYXJ0aWFsPFJlYWRvbmx5Q29uZmlndXJhdGlvbkRhdGE+KTogdm9pZCB7XHJcblx0XHRsZXQgbmV3Q29uZmlndXJhdGlvbkRhdGE6IFBhcnRpYWw8UmVhZG9ubHlDb25maWd1cmF0aW9uRGF0YT47XHJcblxyXG5cdFx0Ly8gVmFsaWRhdGUgdmVyc2lvblxyXG5cdFx0aWYgKGNvbmZpZ3VyYXRpb25EYXRhID09IG51bGwpIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiTm8gY29uZmlndXJhdGlvbiBmb3VuZCwgdXNpbmcgZW1wdHlcIik7XHJcblx0XHRcdG5ld0NvbmZpZ3VyYXRpb25EYXRhID0gVXRpbHMuZGVlcENsb25lKEVNUFRZX0NPTkZJR1VSQVRJT04pO1xyXG5cdFx0fSBlbHNlIGlmIChjb25maWd1cmF0aW9uRGF0YS5Db25maWd1cmF0aW9uVmVyc2lvbiAhPT0gQ09ORklHVVJBVElPTl9WRVJTSU9OKSB7XHJcblx0XHRcdGdldExvZ2dlcigpLmxvZyhcIkZvdW5kIGNvbmZpZ3VyYXRpb24gaW4gb2xkIGZvcm1hdCwgdXNpbmcgZW1wdHlcIik7XHJcblx0XHRcdG5ld0NvbmZpZ3VyYXRpb25EYXRhID0gVXRpbHMuZGVlcENsb25lKEVNUFRZX0NPTkZJR1VSQVRJT04pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Z2V0TG9nZ2VyKCkubG9nKFwiU2V0IG5ldyBjb25maWd1cmF0aW9uXCIsIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuXHRcdFx0bmV3Q29uZmlndXJhdGlvbkRhdGEgPSBVdGlscy5kZWVwQ2xvbmUoY29uZmlndXJhdGlvbkRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0Q29uZmlndXJhdGlvbkltcGwobmV3Q29uZmlndXJhdGlvbkRhdGEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNvbmZpZ3VyYXRpb24gaW1wbGVtZW50YXRpb24uXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzZXRDb25maWd1cmF0aW9uSW1wbChjb25maWd1cmF0aW9uRGF0YTogUGFydGlhbDxSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhPik6IHZvaWQge1xyXG5cdFx0Y29uc3QgcmVzdWx0aW5nQ29uZmlndXJhdGlvbkRhdGEgPSBVdGlscy5kZWVwQ2xvbmUoY29uZmlndXJhdGlvbkRhdGEpO1xyXG5cclxuXHRcdC8vIERvIG5vdCBhbGxvdyBuZWdhdGl2ZSB2YWx1ZXMuXHJcblx0XHRpZiAocmVzdWx0aW5nQ29uZmlndXJhdGlvbkRhdGEuTWF4UHJvcGVydHlMZW5ndGggIT0gbnVsbCAmJlxyXG5cdFx0XHRyZXN1bHRpbmdDb25maWd1cmF0aW9uRGF0YS5NYXhQcm9wZXJ0eUxlbmd0aCA8IDApIHtcclxuXHRcdFx0cmVzdWx0aW5nQ29uZmlndXJhdGlvbkRhdGEuTWF4UHJvcGVydHlMZW5ndGggPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29uZmlndXJhdGlvbiA9IG5ldyBDb25maWd1cmF0aW9uKHJlc3VsdGluZ0NvbmZpZ3VyYXRpb25EYXRhKTtcclxuXHJcblx0XHQvLyBTdG9yZSBsb2NhbGx5XHJcblx0XHQvLyBvcm9naW5hbFxyXG5cdFx0Ly8gbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShjb25maWd1cmF0aW9uRGF0YSkpO1xyXG5cclxuXHRcdC8vIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldChbdGhpcy5zdG9yYWdlS2V5XSwgSlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvbkRhdGEpKTtcclxuXHJcblx0XHQvLyBjb25zdCBzdG9yYWdlS2V5ID0gdGhpcy5zdG9yYWdlS2V5O1xyXG5cdFx0Y29uc3QgY29uZmlnID0gSlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvbkRhdGEpO1xyXG5cdFx0Y29uc3QgcHJvbWlzZSA9IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7c3RvcmFnZUtleTogY29uZmlnfSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY2xlYXJDb25maWd1cmF0aW9uKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5zZXRDb25maWd1cmF0aW9uKEVNUFRZX0NPTkZJR1VSQVRJT04pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldENvbmZpZ3VyYXRpb24oKTogQ29uZmlndXJhdGlvbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VyaWFsaXplZCBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0U2VyaWFsaXplZENvbmZpZ3VyYXRpb24oKTogc3RyaW5nIHwgbnVsbCB7XHJcblx0XHQvLyBtdjNcclxuXHRcdGxldCBzdG9yYWdlS2V5VmFsdWUgPSBcIlwiO1xyXG5cdFx0Ly8gY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KFt0aGlzLnN0b3JhZ2VLZXldLCAoIGl0ZW1zKSA9PiB7c3RvcmFnZUtleVZhbHVlID0gU3RyaW5nKGl0ZW1zW3RoaXMuc3RvcmFnZUtleV0pO1xyXG5cdFx0Ly8gXHRyZXR1cm4gc3RvcmFnZUtleVZhbHVlO1xyXG5cdFx0Ly8gfSk7XHJcblxyXG5cdFx0Y29uc3QgcHJvbWlzZSA9IGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChbdGhpcy5zdG9yYWdlS2V5XSk7XHJcblxyXG5cdFx0cHJvbWlzZS50aGVuKHZhbHVlID0+IHN0b3JhZ2VLZXlWYWx1ZSA9IFN0cmluZyh2YWx1ZVt0aGlzLnN0b3JhZ2VLZXldKSkuY2F0Y2gocmVhc29uID0+IGdldExvZ2dlcigpLmVycm9yKFwic3RvcmFnZSBrZXkgZXJyb3JcIiwgcmVhc29uKSk7XHJcblxyXG5cdFx0cmV0dXJuIHN0b3JhZ2VLZXlWYWx1ZTtcclxuXHRcdC8vIG9yaWdpbmFsXHJcblx0XHQvLyByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgY2xlYXJQZXJzaXN0ZW50Q29uZmlndXJhdGlvbihzdG9yYWdlS2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdC8vIG12M1xyXG5cdFx0Y29uc3QgcHJvbWlzZSA9IGNocm9tZS5zdG9yYWdlLmxvY2FsLnJlbW92ZShzdG9yYWdlS2V5KS5jYXRjaChyZWFzb24gPT4gZ2V0TG9nZ2VyKCkuZXJyb3IoXCJzdG9yYWdlIGtleSByZW1vdmUgZXJyb3JcIiwgcmVhc29uKSk7XHJcblxyXG5cdFx0Ly8gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCB7IEV2ZW50Q29uZGl0aW9uIH0gZnJvbSBcIi4vV2FjQVBJXCI7XHJcbmltcG9ydCB7XHJcblx0Q29uZGl0aW9uc1BlckV2ZW50LFxyXG5cdEV2ZW50c1BlclByb3BlcnR5VmFsdWUsXHJcblx0UHJvcGVydHlNYXRjaCxcclxuXHRSZWFkb25seUNvbmZpZ3VyYXRpb25EYXRhLFxyXG5cdFNUQVJUSU5HX0NPTkZJR1VSQVRJT05cclxufSBmcm9tIFwiLi4vY29tbW9uL0NvbmZpZ3VyYXRpb25EYXRhXCI7XHJcbmltcG9ydCB7IGRlZXBDbG9uZSwgcG9wdWxhdGUgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcclxuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuLi9jb21tb24vY29uZmlndXJhdGlvbi9Db25maWd1cmF0aW9uXCI7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb25zb2xpZGF0ZWRFdmVudENvbmZpZyhldmVudENvbmRpdGlvbnM6IEV2ZW50Q29uZGl0aW9uW10pOiBFdmVudHNQZXJQcm9wZXJ0eVZhbHVlW10ge1xyXG5cdHJldHVybiBldmVudENvbmRpdGlvbnMubWFwKChldmVudENvbmRpdGlvbjogRXZlbnRDb25kaXRpb24pID0+IHtcclxuXHRcdGNvbnN0IGNvbmRpdGlvbnM6IHsgW3Byb3BlcnR5OiBzdHJpbmddOiBQcm9wZXJ0eU1hdGNoW107IH0gPSB7fTtcclxuXHRcdGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50Q29uZGl0aW9uLmV2ZW50O1xyXG5cdFx0Y29uc3QgY29tbWl0dGVkVXJsOiBzdHJpbmcgPSBldmVudENvbmRpdGlvbi5jb25kaXRpb25Qcm9wZXJ0aWVzLmZpbHRlcih2YWx1ZSA9PiB2YWx1ZS5wcm9wZXJ0eSA9PT0gXCJkb2N1bWVudENvbW1pdHRlZFVybFwiKVswXS52YWx1ZTtcclxuXHRcdGZvciAoY29uc3Qge3ZhbHVlLCBtYXRjaFR5cGUsIHByb3BlcnR5fSBvZiBldmVudENvbmRpdGlvbi5jb25kaXRpb25Qcm9wZXJ0aWVzKSB7XHJcblx0XHRcdGlmIChjb25kaXRpb25zW3Byb3BlcnR5XSA9PSBudWxsKSB7XHJcblx0XHRcdFx0Y29uZGl0aW9uc1twcm9wZXJ0eV0gPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25kaXRpb25zW3Byb3BlcnR5XS5wdXNoKHtNYXRjaFR5cGU6IG1hdGNoVHlwZSwgVmFsdWU6IHZhbHVlfSk7XHJcblx0XHR9XHJcblx0XHRjb25zdCBldmVudHNQZXJQcm9wZXJ0eVZhbHVlOiBFdmVudHNQZXJQcm9wZXJ0eVZhbHVlID0ge307XHJcblx0XHRldmVudHNQZXJQcm9wZXJ0eVZhbHVlW2NvbW1pdHRlZFVybF0gPSB7fTtcclxuXHRcdGV2ZW50c1BlclByb3BlcnR5VmFsdWVbY29tbWl0dGVkVXJsXVtldmVudE5hbWVdID0gW3tDb25kaXRpb25zOiBjb25kaXRpb25zfV07XHJcblx0XHRyZXR1cm4gZXZlbnRzUGVyUHJvcGVydHlWYWx1ZTtcclxuXHR9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2VzIGNvbmZpZ3VyYXRpb24gcmVhZGFibGUgYnkgYWdlbnRcclxuICogQHBhcmFtIGV2ZW50c1BlclByb3BlcnR5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGV2ZW50c1BlclByb3BlcnR5OiBFdmVudENvbmRpdGlvbltdKTogQ29uZmlndXJhdGlvbiB7XHJcblx0Y29uc3QgZXZlbnRzUGVyUHJvcGVydHlWYWx1ZTogRXZlbnRzUGVyUHJvcGVydHlWYWx1ZSA9IHt9O1xyXG5cdGNvbnN0IGV2ZW50Q29uZmlnOiBDb25kaXRpb25zUGVyRXZlbnQgPSB7fTtcclxuXHRjb25zdCBjb25zb2xpZGF0ZWRFdmVudENvbmZpZzogRXZlbnRzUGVyUHJvcGVydHlWYWx1ZVtdID0gY3JlYXRlQ29uc29saWRhdGVkRXZlbnRDb25maWcoZXZlbnRzUGVyUHJvcGVydHkpO1xyXG5cclxuXHRmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnNvbGlkYXRlZEV2ZW50Q29uZmlnKSB7XHJcblx0XHQvLyBnZXQgZG9jdW1lbnRDb21taXR0ZWRVcmxcclxuXHRcdGNvbnN0IGRvY3VtZW50Q29tbWl0dGVkVXJsID0gT2JqZWN0LmtleXMoZXZlbnQpWzBdO1xyXG5cdFx0aWYgKGV2ZW50c1BlclByb3BlcnR5VmFsdWVbZG9jdW1lbnRDb21taXR0ZWRVcmxdID09IG51bGwpIHtcclxuXHRcdFx0ZXZlbnRzUGVyUHJvcGVydHlWYWx1ZVtkb2N1bWVudENvbW1pdHRlZFVybF0gPSB7fTtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGNvbmRpdGlvbnNQZXJFdmVudDogQ29uZGl0aW9uc1BlckV2ZW50ID0gZXZlbnRbZG9jdW1lbnRDb21taXR0ZWRVcmxdO1xyXG5cdFx0Zm9yIChjb25zdCBldmVudE5hbWUgb2YgT2JqZWN0LmtleXMoY29uZGl0aW9uc1BlckV2ZW50KSkge1xyXG5cdFx0XHRpZiAoZXZlbnRDb25maWdbZXZlbnROYW1lXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0ZXZlbnRDb25maWdbZXZlbnROYW1lXSA9IGNvbmRpdGlvbnNQZXJFdmVudFtldmVudE5hbWVdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChldmVudHNQZXJQcm9wZXJ0eVZhbHVlW2RvY3VtZW50Q29tbWl0dGVkVXJsXVtldmVudE5hbWVdID09IG51bGwpIHtcclxuXHRcdFx0XHRjb25zdCBjb25kaXRpb25QZXJFdmVudENvcHkgPSBkZWVwQ2xvbmUoY29uZGl0aW9uc1BlckV2ZW50KTtcclxuXHRcdFx0XHRldmVudHNQZXJQcm9wZXJ0eVZhbHVlW2RvY3VtZW50Q29tbWl0dGVkVXJsXVtldmVudE5hbWVdID0gY29uZGl0aW9uUGVyRXZlbnRDb3B5W2V2ZW50TmFtZV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG5cdFx0XHRcdGZvciAoY29uc3QgY29uZGl0aW9uTmFtZSBvZiBPYmplY3Qua2V5cyhjb25kaXRpb25zUGVyRXZlbnRbZXZlbnROYW1lXVswXS5Db25kaXRpb25zKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcHJvcGVydHlNYXRjaDogUHJvcGVydHlNYXRjaCA9IGNvbmRpdGlvbnNQZXJFdmVudFtldmVudE5hbWVdWzBdLkNvbmRpdGlvbnNbY29uZGl0aW9uTmFtZV1bMF07XHJcblx0XHRcdFx0XHRpZiAoY29uZGl0aW9uTmFtZSA9PT0gXCJhdGVybml0eUNTU1NlbGVjdG9yXCIgfHwgY29uZGl0aW9uTmFtZSA9PT0gXCJkb2N1bWVudENvbW1pdHRlZFVybFwiKSB7XHJcblx0XHRcdFx0XHRcdGlmIChjb25kaXRpb25OYW1lICE9PSBcImRvY3VtZW50Q29tbWl0dGVkVXJsXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRldmVudHNQZXJQcm9wZXJ0eVZhbHVlW2RvY3VtZW50Q29tbWl0dGVkVXJsXVtldmVudE5hbWVdWzBdLkNvbmRpdGlvbnNbY29uZGl0aW9uTmFtZV0ucHVzaChwcm9wZXJ0eU1hdGNoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRldmVudENvbmZpZ1tldmVudE5hbWVdWzBdLkNvbmRpdGlvbnNbY29uZGl0aW9uTmFtZV0ucHVzaChwcm9wZXJ0eU1hdGNoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNyZWF0aW5nIG5ldyBlbXB0eSBjb25maWd1cmF0aW9uXHJcblx0Y29uc3QgY29uZmlndXJhdGlvbkRhdGEgPSBkZWVwQ2xvbmUoU1RBUlRJTkdfQ09ORklHVVJBVElPTik7XHJcblx0Ly8gdXBkYXRlIG5ldyBjb25maWd1cmF0aW9uIGRhdGEgd2l0aCBkYXRhIHJlY2VpdmVkIGZyb20gV0FDXHJcblx0cG9wdWxhdGUoe1xyXG5cdFx0Q29uc29saWRhdGVkRXZlbnRDb25maWc6IHtcclxuXHRcdFx0ZG9jdW1lbnRDb21taXR0ZWRVcmw6IGV2ZW50c1BlclByb3BlcnR5VmFsdWVcclxuXHRcdH0sIEV2ZW50Q29uZmlnOiBldmVudENvbmZpZyxcclxuXHRcdFdvcmtUaW1lVGhyZXNob2xkczogW1xyXG5cdFx0XHR7V29ya1RpbWU6IDMwMCwgVGltZUZyYW1lOiAxMDAwfSxcclxuXHRcdFx0e1dvcmtUaW1lOiAxNTAwLCBUaW1lRnJhbWU6IDEwMDAwfSxcclxuXHRcdFx0e1dvcmtUaW1lOiAzMDAwLCBUaW1lRnJhbWU6IDYwMDAwfVxyXG5cdFx0XVxyXG5cdH0sIGNvbmZpZ3VyYXRpb25EYXRhKTtcclxuXHJcblx0cmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb25EYXRhKTtcclxufSIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBXYWNDb21tdW5pY2F0aW9uIH0gZnJvbSBcIi4vV2FjQ29tbXVuaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBPdXRnb2luZ0V2ZW50TWVzc2FnZSwgT3V0Z29pbmdQYWdlTmF0aXZlTWVzc2FnZSB9IGZyb20gXCIuLi9jb21tb24vTWVzc2FnaW5nTW9kZWxcIjtcclxuaW1wb3J0IHsgQnJvd3NlclR5cGUsIEV2ZW50TWF0Y2hSZXBvcnQsIGlzRXZlbnRNYXRjaFJlcG9ydCwgTWF0Y2hFdmVudFR5cGUgfSBmcm9tIFwiLi9XYWNBUElcIjtcclxuaW1wb3J0IHsgVVhEYXRhIH0gZnJvbSBcIi4uL2NvbW1vbi9VWERhdGFcIjtcclxuaW1wb3J0IHsgYnJvd3NlckluZm8gfSBmcm9tIFwiLi4vdXRpbHMvYnJvd3NlckluZm9cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBXYWNFdmVudFJlcG9ydGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB3YWNDb21tdW5pY2F0aW9uOiBXYWNDb21tdW5pY2F0aW9uKSB7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVwb3J0VG9XYWMocGFnZU1lc3NhZ2U6IFBhcnRpYWw8T3V0Z29pbmdQYWdlTmF0aXZlTWVzc2FnZT4pOiB2b2lkIHtcclxuXHRcdGNvbnN0IHJhd0RhdGEgPSAocGFnZU1lc3NhZ2UgYXMgT3V0Z29pbmdFdmVudE1lc3NhZ2U8VVhEYXRhPik7XHJcblx0XHQvLyBjcmVhdGUgYmFzaWMgc3RydWN0dXJlXHJcblx0XHRjb25zdCBldmVudFR5cGU6IE1hdGNoRXZlbnRUeXBlID0gcmF3RGF0YS5tZXNzYWdlRGF0YS5FdmVudFR5cGUuc3BsaXQoXCIuXCIpLnBvcCgpIGFzIE1hdGNoRXZlbnRUeXBlO1xyXG5cdFx0Ly8gbWFrZSB0YWIgYW5kIGZyYW1lIGFuZCB0YWIgaWRzIGFzIG51bWJlcnNcclxuXHRcdGNvbnN0IGZyYW1lSWQ6IG51bWJlciA9IHJhd0RhdGEuZnJhbWVJZCAhPSBudWxsID8gcmF3RGF0YS5mcmFtZUlkIDpcclxuXHRcdFx0cGFyc2VJbnQoKHJhd0RhdGEubWVzc2FnZURhdGEuRGF0YVswXS5mcmFtZUlkIGFzIHN0cmluZyksIDEwKTtcclxuXHRcdGNvbnN0IHRhYklkID0gcmF3RGF0YS50YWJJZCAhPSBudWxsID8gcmF3RGF0YS50YWJJZCA6XHJcblx0XHRcdHBhcnNlSW50KChyYXdEYXRhLm1lc3NhZ2VEYXRhLkRhdGFbMF0udGFiSWQgYXMgc3RyaW5nKSwgMTApO1xyXG5cclxuXHRcdC8vIGJ1aWxkIG1lc3NhZ2UgYm9keVxyXG5cdFx0Y29uc3QgZGF0YVRvU2VuZDogRXZlbnRNYXRjaFJlcG9ydCA9IHtcclxuXHRcdFx0bWVzc2FnZVR5cGU6IFwiRXZlbnRNYXRjaFJlcG9ydFwiLFxyXG5cdFx0XHRldmVudDoge1xyXG5cdFx0XHRcdGRvY3VtZW50Q29tbWl0dGVkVXJsOiByYXdEYXRhLm1lc3NhZ2VEYXRhLkRhdGFbMF0uZG9jdW1lbnRDb21taXR0ZWRVcmwgYXMgc3RyaW5nLFxyXG5cdFx0XHRcdG1vZGlmaWVyS2V5czogcmF3RGF0YS5tZXNzYWdlRGF0YS5EYXRhWzBdLmF0ZXJuaXR5TW9kaWZpZXJLZXlzIGFzIHN0cmluZyxcclxuXHRcdFx0XHRkb2N1bWVudFRpdGxlOiByYXdEYXRhLm1lc3NhZ2VEYXRhLkRhdGFbMF0uZG9jdW1lbnRUaXRsZSBhcyBzdHJpbmcsXHJcblx0XHRcdFx0ZXZlbnRUeXBlOiBldmVudFR5cGUsXHJcblx0XHRcdFx0ZnJhbWVJZDogZnJhbWVJZCxcclxuXHRcdFx0XHR0YWJJZDogdGFiSWQsXHJcblx0XHRcdFx0dGltZVN0YW1wOiByYXdEYXRhLnRpbWVTdGFtcCxcclxuXHRcdFx0XHRicm93c2VyOiBicm93c2VySW5mby5uYW1lLFxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChyYXdEYXRhLm1lc3NhZ2VEYXRhLkRhdGFbMF0uYXRlcm5pdHlNb3VzZUJ1dHRvbiAhPSBudWxsKSB7XHJcblx0XHRcdGRhdGFUb1NlbmQuZXZlbnQubW91c2VCdXR0b24gPSByYXdEYXRhLm1lc3NhZ2VEYXRhLkRhdGFbMF0uYXRlcm5pdHlNb3VzZUJ1dHRvbiBhcyBzdHJpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHJhd0RhdGEubWVzc2FnZURhdGEuRGF0YVswXS5rZXkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkYXRhVG9TZW5kLmV2ZW50LmtleSA9IHJhd0RhdGEubWVzc2FnZURhdGEuRGF0YVswXS5rZXkgYXMgc3RyaW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIHRoZXJlIGEgZnJhbWVcclxuXHRcdGlmIChmcmFtZUlkID4gMCkge1xyXG5cdFx0XHRkYXRhVG9TZW5kLmV2ZW50LmZyYW1lQ29tbWl0dGVkVXJsID0gcmF3RGF0YS5tZXNzYWdlRGF0YS5EYXRhWzBdLmZyYW1lQ29tbWl0dGVkVXJsIGFzIHN0cmluZztcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhdGVybml0eUNTU1NlbGVjdG9yID0gcmF3RGF0YS5tZXNzYWdlRGF0YS5EYXRhWzBdLmF0ZXJuaXR5Q1NTU2VsZWN0b3I7XHJcblx0XHRpZiAodHlwZW9mIGF0ZXJuaXR5Q1NTU2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0ZGF0YVRvU2VuZC5ldmVudC5jc3NTZWxlY3RvciA9IGF0ZXJuaXR5Q1NTU2VsZWN0b3I7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgKGlzRXZlbnRNYXRjaFJlcG9ydChkYXRhVG9TZW5kKSkge1xyXG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhkYXRhVG9TZW5kKTtcclxuXHRcdC8vIH1cclxuXHRcdC8vIHNlbmQgbWVzc2FnZSB0byBXQUNcclxuXHRcdHRoaXMud2FjQ29tbXVuaWNhdGlvbi5zZW5kTWVzc2FnZVRvV2FjKGRhdGFUb1NlbmQpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHdhY01vZGUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy53YWNDb21tdW5pY2F0aW9uLmlzQWN0aXZlKCk7XHJcblx0fVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=